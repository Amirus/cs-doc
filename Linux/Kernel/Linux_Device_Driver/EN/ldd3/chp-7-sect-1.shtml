<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>7.1. Measuring Time Lapses</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-7-sect-1"></a>
<h3 class="docSection1Title">7.1. Measuring Time Lapses</h3>

<p class="docText">The kernel keeps track <a name="chp-7-ITERM-5466"></a> <a name="chp-7-ITERM-5467"></a> <a name="chp-7-ITERM-5468"></a> <a name="chp-7-ITERM-5469"></a>of the flow of time by means of timer
interrupts. Interrupts are covered in detail in <a class="docLink" href="chp-10.shtml#chp-10">Chapter 10</a>.</p>

<p class="docText"><a name="chp-7-ITERM-5470"></a><a name="chp-7-ITERM-5471"></a><a name="chp-7-ITERM-5472"></a>Timer interrupts are generated by
<a name="chp-7-ITERM-5473"></a>
<a name="chp-7-ITERM-5474"></a>the
system's timing hardware at regular intervals; this
interval is programmed at boot time by the kernel according to the
value of <tt>HZ</tt>, which is an architecture-dependent
value defined in <I>&lt;linux/param.h&gt;</i> or a
subplatform file included by it. Default values in the distributed
kernel source range from 50 to 1200 ticks per second on real
hardware, down to 24 for software simulators. Most platforms run at
100 or 1000 interrupts per second; the popular x86 PC defaults to
1000, although it used to be 100 in previous versions (up to and
including 2.4). As a general rule, even if you know the value of
<tt>HZ</tt>, you should never count on that specific value
when programming.</P>

<p class="docText">It is possible to change the value of <tt>HZ</tt> for those
who want systems with a different clock interrupt frequency. If you
change <tt>HZ</tt> in the header file, you need to
recompile the kernel and all modules with the new value. You might
want to raise <tt>HZ</tt> to get a more fine-grained
resolution in your asynchronous tasks, if you are willing to pay the
overhead of the extra timer interrupts to achieve your goals.
Actually, raising <tt>HZ</tt> to 1000 was pretty common
with x86 industrial systems using Version 2.4 or 2.2 of the kernel.
With current versions, however, the best approach to the timer
interrupt is to keep the default value for <tt>HZ</tt>, by
virtue of our complete trust in the kernel developers, who have
certainly chosen the best value. Besides, some internal calculations
are currently implemented only for <tt>HZ</tt> in the range
from 12 to 1535 (see <I>&lt;linux/timex.h&gt;</I> and
RFC-1589).</p>

<p class="docText"><a name="chp-7-ITERM-5475"></a>
<a name="chp-7-ITERM-5476"></a>
<a name="chp-7-ITERM-5477"></a>
<a name="chp-7-ITERM-5478"></a><a name="chp-7-ITERM-5479"></a>Every time a timer interrupt occurs,
the value of an internal kernel counter is incremented. The counter
is initialized to <tt>0</tt> at system boot, so it
represents the number of clock ticks since last boot. The counter is
a 64-bit variable (even on 32-bit architectures) and is called
<tt>jiffies_64</tt>. However, driver writers normally
access the <tt>jiffies</tt> variable, an
<tt>unsigned</tt> <tt>long</tt> that is the same
as either <tt>jiffies_64</tt> or its least significant
bits. Using <tt>jiffies</tt> is usually preferred because
it is faster, and accesses to the 64-bit
<tt>jiffies_64</tt> value are not necessarily atomic on all
architectures.</p>

<p class="docText">In addition to the low-resolution kernel-managed jiffy mechanism,
some CPU platforms feature a high-resolution counter that software
can read. Although its actual use varies somewhat across platforms,
it's sometimes a very powerful tool.</p>

<a name="chp-7-sect-1.1"></a>
<h4 class="docSection2Title">7.1.1. Using the jiffies Counter</H4>

<p class="docText">The counter and the utility functions to read it live in
<I>&lt;linux/jiffies.h&gt;</I>, although
you'll usually just include
<i>&lt;linux/sched.h&gt;</I>, that automatically pulls
<I>jiffies.h</i> in. Needless to say, both
<tt>jiffies</tt> and <tt>jiffies_64</tt> must be
considered read-only.</p>

<p class="docText">Whenever your code needs to remember the current value of
<tt>jiffies</tt>, it can simply access the
<tt>unsigned</tt> <tt>long</tt> variable, which
is declared as volatile to tell the compiler not to optimize memory
reads. You need to read the current counter whenever your code needs
to calculate a future time stamp, as shown in the following example:</p>

<pre>#include &lt;linux/jiffies.h&gt;
unsigned long j, stamp_1, stamp_half, stamp_n;

j = jiffies;                      /* read the current value */
stamp_1    = j + HZ;              /* 1 second in the future */
stamp_half = j + HZ/2;            /* half a second */
stamp_n    = j + n * HZ / 1000;   /* n milliseconds */</pre><br>


<p class="docText">This code has no problem with <tt>jiffies</tt> wrapping
around, as long as different values are compared in the right way.
Even though on 32-bit platforms the counter wraps around only once
every 50 days when <tt>HZ</tt> is 1000, your code should be
prepared to face that event. To compare your cached value (like
<tt>stamp_1</tt> above) and the current value, you should
use one of the following macros:</P>

<pre>#include &lt;linux/jiffies.h&gt;
int time_after(unsigned long a, unsigned long b);
int time_before(unsigned long a, unsigned long b);
int time_after_eq(unsigned long a, unsigned long b);
int time_before_eq(unsigned long a, unsigned long b);</pre><br>


<p class="docText">The first evaluates true when <span class="docEmphasis">a</span>, as a snapshot
of <tt>jiffies</tt>, represents a time after
<span class="docEmphasis">b</span>, the second evaluates true when time
<span class="docEmphasis">a</span> is before time <span class="docEmphasis">b</span>, and the
last two compare for "after or
equal" and "before or
equal." The code works by converting the values to
signed long, subtracting them, and comparing the result. If you need
to know the difference between two instances of
<tt>jiffies</tt> in a safe way, you can use the same trick:
<tt>diff = (long)t2 - (long)t1;</tt>.</p>

<p class="docText">You can convert a jiffies difference to milliseconds trivially
through:</P>

<pre>msec = diff * 1000 / HZ;</pre><br>


<p class="docText">Sometimes, however, you need to exchange time representations with
user space programs that tend to represent time values with
<tt>struct</tt> <tt>timeval</tt> and
<tt>struct</tt> <tt>timespec</tt>. The two
structures represent a precise time quantity with two numbers:
seconds and microseconds are used in the older and popular
<tt>struct</tt> <tt>timeval</tt>, and seconds and
nanoseconds are used in the newer <tt>struct</tt>
<tt>timespec</tt>. The kernel exports four helper functions
to convert time values expressed as jiffies to and from those
structures:</p>

<pre>#include &lt;linux/time.h&gt;

unsigned long timespec_to_jiffies(struct timespec *value);
void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);
unsigned long timeval_to_jiffies(struct timeval *value);
void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);</pre><BR>


<p class="docText">Accessing the 64-bit jiffy count is not as straightforward as
accessing <tt>jiffies</tt>. While on 64-bit computer
architectures the two variables are actually one, access to the value
is not atomic for 32-bit processors. This means you might read the
wrong value if both halves of the variable get updated while you are
reading them. It's extremely unlikely
you'll ever need to read the 64-bit counter, but in
case you do, you'll be glad to know that the kernel
exports a specific helper function that does the proper locking for
you:</p>

<pre>#include &lt;linux/jiffies.h&gt;
u64 get_jiffies_64(void);</pre><BR>


<p class="docText">In the above prototype, the <tt>u64</tt> type is used. This
is one of the types defined by
<i>&lt;linux/types.h&gt;</i>
and represents an
unsigned 64-bit type.</p>

<p class="docText">If you're wondering how 32-bit platforms update both
the 32-bit and 64-bit counters at the same time, read the linker
script for your platform (look for a file whose name matches
<i>vmlinux*.lds*</i>). There, the
<tt>jiffies</tt> symbol is defined to access the least
significant word of the 64-bit value, according to whether the
platform is little-endian or big-endian. Actually, the same trick is
used for 64-bit platforms, so that the <tt>unsigned
long</tt> and <tt>u64</tt> variables are accessed at
the same address.</p>

<p class="docText">Finally, note that the actual clock frequency is almost completely
hidden from user space. The macro <tt>HZ</tt> always
expands to 100 when user-space programs include
<i>param.h</i>, and every counter reported to user
space is converted accordingly. This applies to
<span class="docEmphasis">clock(3)</span>, <span class="docEmphasis">times(2)</span>, and any
related function. The only evidence available to users of the
<tt>HZ</tt> value is how fast timer interrupts happen, as
shown in <i>/proc/interrupts</i>. For example, you can
obtain <tt>HZ</tt> by dividing this count by the system
uptime reported in <i>/proc/uptime</i>.</p>


<a name="chp-7-sect-1.2"></a>
<H4 class="docSection2Title">7.1.2. Processor-Specific Registers</h4>

<p class="docText">If you need to measure <a name="chp-7-ITERM-5480"></a>
<a name="chp-7-ITERM-5481"></a>very
short time intervals or you need extremely high precision in your
figures, you can resort to platform-dependent resources, a choice of
precision over portability.</P>

<p class="docText"><a name="chp-7-ITERM-5482"></a>
<a name="chp-7-ITERM-5483"></a><a name="chp-7-ITERM-5484"></a>In modern processors, the pressing
demand for empirical performance figures is thwarted by the intrinsic
unpredictability of instruction timing in most CPU designs due to
cache memories, instruction scheduling, and branch prediction. As a
response, CPU manufacturers introduced a way to count clock cycles as
an easy and reliable way to measure time lapses. Therefore, most
modern processors include a counter register that is steadily
incremented once at each clock cycle. Nowadays, this clock counter is
the only reliable way to carry out high-resolution timekeeping tasks.</P>

<p class="docText">The details differ from platform to platform: the register may or may
not be readable from user space, it may or may not be writable, and
it may be 64 or 32 bits wide. In the last case, you must be prepared
to handle overflows just like we did with the jiffy counter. The
register may even not exist for your platform, or it can be
implemented in an external device by the hardware designer, if the
CPU lacks the feature and you are dealing with a special-purpose
computer.</p>

<p class="docText">Whether or not the register can be zeroed, we strongly discourage
resetting it, even when hardware permits. You might not, after all,
be the only user of the counter at any given time; on some platforms
supporting SMP, for example, the kernel depends on such a counter to
be synchronized across processors. Since you can always measure
differences between values, as long as that difference
doesn't exceed the overflow time, you can get the
work done without claiming exclusive ownership of the register by
modifying its current value.</p>

<p class="docText"><a name="chp-7-ITERM-5485"></a>
<a name="chp-7-ITERM-5486"></a><a name="chp-7-ITERM-5487"></a>The most renowned counter register
is the TSC (timestamp counter), introduced in x86 processors with the
Pentium and present in all CPU designs ever since—including the
x86_64 platform. It is a 64-bit register that counts CPU clock
cycles; it can be read from both kernel space and user space.</p>

<p class="docText">After including <I>&lt;asm/msr.h&gt;</i> (an
x86-specific header whose name stands for
"machine-specific registers"), you
can use one of these macros:</P>

<pre>rdtsc(low32,high32);
rdtscl(low32);
rdtscll(var64);</pre><BR>


<p class="docText">The first macro atomically reads the 64-bit value into two 32-bit
variables; the next one ("read low
half") reads the low half of the register into a
32-bit variable, discarding the high half; the last reads the 64-bit
value into a <tt>long long</tt> variable, hence, the name.
All of these macros store values into their arguments.</P>

<p class="docText">Reading the low half of the counter is enough for most common uses of
the TSC. A 1-GHz CPU overflows it only once every 4.2 seconds, so you
won't need to deal with multiregister variables if
the time lapse you are benchmarking reliably takes less time.
However, as CPU frequencies rise over time and as timing requirements
increase, you'll most likely need to read the 64-bit
counter more often in the future.</p>

<p class="docText">As an example using only the low half of the register, the following
lines measure the execution of the instruction itself:</p>

<pre>unsigned long ini, end;
rdtscl(ini); rdtscl(end);
printk("time lapse: %li\n", end - ini);</pre><br>


<p class="docText"><a name="chp-7-ITERM-5488"></a>
<a name="chp-7-ITERM-5489"></a>Some
of the other platforms offer similar functionality, and kernel
headers offer an architecture-independent function that you can use
instead of <span class="docEmphasis">rdtsc</span>. It is called
<span class="docEmphasis">get_cycles</span>, defined in
<i>&lt;asm/timex.h&gt;</I> (included by
<I>&lt;linux/timex.h&gt;</I>). Its prototype is:</p>

<pre> #include &lt;linux/timex.h&gt;
 cycles_t get_cycles(void);</pre><BR>


<p class="docText"><a name="chp-7-ITERM-5490"></a>This function
is defined for every platform, and it always returns
<tt>0</tt> on the platforms that have no cycle-counter
register. The <tt>cycles_t</tt> type is an appropriate
unsigned type to hold the value read.</P>

<p class="docText"><a name="chp-7-ITERM-5491"></a>
<a name="chp-7-ITERM-5492"></a><a name="chp-7-ITERM-5493"></a><a name="chp-7-ITERM-5494"></a>Despite the availability of
an architecture-independent function, we'd like to
take the opportunity to show an example of inline assembly code. To
this aim, we implement a
<span class="docEmphasis">rdtscl</span><a name="chp-7-ITERM-5495"></a>
<a name="chp-7-ITERM-5496"></a>
function for MIPS processors that works in the same way as the x86
one.</p>

<p class="docText">We base the example on MIPS because most MIPS processors feature a
32-bit counter as register 9 of their internal
"coprocessor 0." To access the
register, readable only from kernel space, you can define the
following macro that executes a "move from
coprocessor 0" assembly instruction:<sup class="docFootnote"><a class="docLink" href="chp-7-sect-1.shtml#chp-7-FNOTE-1">[1]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="chp-7-FNOTE-1">[1]</a></sup> The trailing <span class="docEmphasis">nop</span> instruction is required
to prevent the compiler from accessing the target register in the
instruction immediately following <span class="docEmphasis">mfc0</span>. This
kind of interlock is typical of RISC processors, and the compiler can
still schedule useful instructions in the delay slots. In this case,
we use <span class="docEmphasis">nop</span> because inline assembly is a black
box for the compiler and no optimization can be performed.</p></blockquote>

<pre>#define rdtscl(dest) \
   _ _asm_ _ _ _volatile_ _("mfc0 %0,$9; nop" : "=r" (dest))</pre><br>


<p class="docText">With this macro in place, the MIPS processor can execute the same
code shown earlier for the x86.</P>

<p class="docText"><a name="chp-7-ITERM-5497"></a>
<a name="chp-7-ITERM-5498"></a>With
<span class="docEmphasis">gcc</span> inline assembly, the allocation of
general-purpose registers is left to the compiler. The macro just
shown uses <tt>%0</tt> as a placeholder for
"argument 0," which is later
specified as "any register (<tt>r</tt>)
used as output (<tt>=</tt>)." The macro
also states that the output register must correspond to the C
expression <tt>dest</tt>. The syntax for inline assembly is
very powerful but somewhat complex, especially for architectures that
have constraints on what each register can do (namely, the x86
family). The syntax is described in the <span class="docEmphasis">gcc</span>
documentation, usually available in the <span class="docEmphasis">info</span>
documentation tree.</p>

<p class="docText">The short C-code fragment shown in this section has been run on a
K7-class x86 processor and a MIPS VR4181 (using the macro just
described). The former reported a time lapse of 11 clock ticks and
the latter just 2 clock ticks. The small figure was expected, since
RISC processors usually execute one instruction per clock cycle.</p>

<p class="docText">There is one other thing worth knowing about timestamp counters: they
are not necessarily synchronized across processors in an SMP system.
To be sure of getting a coherent value, you should disable preemption
<a name="chp-7-ITERM-5499"></a>
<a name="chp-7-ITERM-5500"></a>
<a name="chp-7-ITERM-5501"></a>
<a name="chp-7-ITERM-5502"></a>for code
that is querying the counter.</P>



<ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
