<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>10.3. Implementing a Handler</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-10-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-10-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-10-sect-3"></a>
<h3 class="docSection1Title">10.3. Implementing a Handler</h3>

<p class="docText">So far, we've learned to register <a name="chp-10-ITERM-6107"></a> <a name="chp-10-ITERM-6108"></a> <a name="chp-10-ITERM-6109"></a>an interrupt handler but not to write
one. Actually, there's nothing unusual about a
handlerâ€”it's ordinary C code.</p>

<p class="docText">The only peculiarity is that a handler runs at interrupt time and,
therefore, suffers some restrictions on what it can do. These
restrictions are the same as those we saw with kernel timers. A
handler can't transfer data to or from user space,
because it doesn't execute in the context of a
process. Handlers also cannot do anything that would sleep, such as
calling <span class="docEmphasis">wait_event</span>, allocating memory with
anything other than <tt>GFP_ATOMIC</tt>, or locking a
semaphore. Finally, handlers cannot call
<span class="docEmphasis">schedule</span>.</P>

<p class="docText"><a name="chp-10-ITERM-6110"></a><a name="chp-10-ITERM-6111"></a>The
role of an interrupt handler is to give feedback to its device about
interrupt reception and to read or write data according to the
meaning of the interrupt being serviced. The first step usually
consists of clearing a bit on the interface board; most hardware
devices won't generate other interrupts until their
"interrupt-pending" bit has been
cleared. Depending on how your hardware works, this step may need to
be performed last instead of first; there is no catch-all rule here.
Some devices don't require this step, because they
don't have an
"interrupt-pending" bit; such
devices are a minority, although the parallel port is one of them.
For that reason, <span class="docEmphasis">short</span> does not have to clear
such a bit.</p>

<p class="docText">A typical task for an interrupt handler is awakening processes
sleeping on the device if the interrupt signals the event
they're waiting for, such as the arrival of new
data.</P>

<p class="docText">To stick with the frame grabber example, a process could acquire a
sequence of images by continuously reading the device; the
<span class="docEmphasis">read</span> call blocks before reading each frame,
while the interrupt handler awakens the process as soon as each new
frame arrives. This assumes that the grabber interrupts the processor
to signal successful arrival of each new frame.</P>

<p class="docText">The programmer should be careful to write a routine that executes in
a minimum amount of time, independent of its being a fast or slow
handler. If a long computation needs to be performed, the best
approach is to use a tasklet or workqueue to schedule computation at
a safer time (we'll look at how work can be deferred
in this manner in <a class="docLink" href="chp-10-sect-4.shtml#chp-10-sect-4">Section 10.4</a>.)</P>

<p class="docText"><a name="chp-10-ITERM-6112"></a>
<a name="chp-10-ITERM-6113"></a><a name="chp-10-ITERM-6114"></a>Our sample code in
<span class="docEmphasis">short</span> responds to the interrupt by calling
<span class="docEmphasis">do_gettimeofday</span> and printing the current time
into a page-sized circular buffer. It then awakens any reading
process, because there is now data available to be read.</p>

<pre>irqreturn_t short_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
    struct timeval tv;
    int written;

    do_gettimeofday(&amp;tv);

        /* Write a 16 byte record. Assume PAGE_SIZE is a multiple of 16 */
    written = sprintf((char *)short_head,"%08u.%06u\n",
            (int)(tv.tv_sec % 100000000), (int)(tv.tv_usec));
    BUG_ON(written != 16);
    short_incr_bp(&amp;short_head, written);
    wake_up_interruptible(&amp;short_queue); /* awake any reading process */
    return IRQ_HANDLED;
}</pre><br>


<p class="docText">This code, though simple, represents the typical job of an interrupt
handler. It, in turn, calls <span class="docEmphasis">short_incr_bp</span>, which
is defined as follows:</p>

<pre>static inline void short_incr_bp(volatile unsigned long *index, int delta)
{
    unsigned long new = *index + delta;
    barrier(  );  /* Don't optimize these two together */
    *index = (new &gt;= (short_buffer + PAGE_SIZE)) ? short_buffer : new;
}</pre><br>


<p class="docText">This function has been carefully written to wrap a pointer into the
circular buffer without ever exposing an incorrect value. The
<span class="docEmphasis">barrier</span> call is there to block compiler
optimizations across the other two lines of the function. Without the
barrier, the compiler might decide to optimize out the
<tt>new</tt> variable and assign directly to
<tt>*index</tt>. That optimization could expose an
incorrect value of the index for a brief period in the case where it
wraps. By taking care to prevent in inconsistent value from ever
being visible to other threads, we can manipulate the circular buffer
pointers safely without locks.</P>

<p class="docText">The device file used to read the buffer being filled at interrupt
time is <I>/dev/shortint</I>. This device special file,
together with <i>/dev/shortprint</I>,
wasn't introduced in <a class="docLink" href="chp-9.shtml#chp-9">Chapter 9</a>, because its use is
specific to interrupt handling. The internals of
<I>/dev/shortint</i> are specifically tailored for
interrupt generation and reporting. Writing to the device generates
one interrupt every other byte; reading the device gives the time
when each interrupt was reported.</p>

<p class="docText"><a name="chp-10-ITERM-6115"></a>If you connect together pins 9
and 10 of the parallel connector, you can generate interrupts by
raising the high bit of the parallel data byte. This can be
accomplished by writing binary data to
<i>/dev/short0</i> or by writing anything to
<I>/dev/shortint</i>.<sup class="docFootnote"><a class="docLink" href="chp-10-sect-3.shtml#chp-10-FNOTE-2">[2]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="chp-10-FNOTE-2">[2]</a></sup> The
<span class="docEmphasis">shortint</span> device accomplishes its task by
alternately writing 0x00 and 0xff to the parallel port.</P></blockquote>

<p class="docText">The following code implements <span class="docEmphasis">read</span> and
<span class="docEmphasis">write</span> for <i>/dev/shortint</i>:</P>

<pre>ssize_t short_i_read (struct file *filp, char _ _user *buf, size_t count, 
     loff_t *f_pos)
{
    int count0;
    DEFINE_WAIT(wait);

    while (short_head =  = short_tail) {
        prepare_to_wait(&amp;short_queue, &amp;wait, TASK_INTERRUPTIBLE);
        if (short_head =  = short_tail)
            schedule(  );
        finish_wait(&amp;short_queue, &amp;wait);
        if (signal_pending (current))  /* a signal arrived */
            return -ERESTARTSYS; /* tell the fs layer to handle it */
    } 
    /* count0 is the number of readable data bytes */
    count0 = short_head - short_tail;
    if (count0 &lt; 0) /* wrapped */
        count0 = short_buffer + PAGE_SIZE - short_tail;
    if (count0 &lt; count) count = count0;

    if (copy_to_user(buf, (char *)short_tail, count))
        return -EFAULT;
    short_incr_bp (&amp;short_tail, count);
    return count;
}

ssize_t short_i_write (struct file *filp, const char _ _user *buf, size_t count,
        loff_t *f_pos)
{
    int written = 0, odd = *f_pos &amp; 1;
    unsigned long port = short_base; /* output to the parallel data latch */
    void *address = (void *) short_base;

    if (use_mem) {
        while (written &lt; count)
            iowrite8(0xff * ((++written + odd) &amp; 1), address);
    } else {
        while (written &lt; count)
            outb(0xff * ((++written + odd) &amp; 1), port);
    }

    *f_pos += count;
    return written;
}</pre><br>


<p class="docText">The other device special file, <I>/dev/shortprint</i>,
uses the parallel port to drive a printer; you can use it if you want
to avoid connecting pins 9 and 10 of a D-25 connector. The
<span class="docEmphasis">write</span> implementation of
<span class="docEmphasis">shortprint</span> uses a circular buffer to store data
to be printed, while the <span class="docEmphasis">read</span> implementation is
the one just shown (so you can read the time your printer takes to
eat each character).</p>

<p class="docText">In order to support printer operation, the interrupt handler has been
slightly modified from the one just shown, adding the ability to send
the next data byte to the printer if there is more data to transfer.</p>

<a name="chp-10-sect-3.1"></a>
<h4 class="docSection2Title">10.3.1. Handler Arguments and Return Value</h4>

<p class="docText">Though <span class="docEmphasis">short</span> ignores them,
<a name="chp-10-ITERM-6116"></a> <a name="chp-10-ITERM-6117"></a>
<a name="chp-10-ITERM-6118"></a>three arguments are passed to an
interrupt handler: <tt>irq</tt>, <tt>dev_id</tt>,
and <tt>regs</tt>. Let's look at the role
of each.</p>

<p class="docText">The interrupt number (<tt>int irq</tt>) is useful as
information you may print in your log messages, if any. The second
argument, <tt>void *dev_id</tt>, is a sort of client data;
a <tt>void</tt> <tt>*</tt> argument is passed to
<span class="docEmphasis">request_irq</span>, and this same pointer is then
passed back as an argument to the handler when the interrupt happens.
You usually pass a pointer to your device data structure in
<tt>dev_id</tt>, so a driver that manages several instances
of the same device doesn't need any extra code in
the interrupt handler to find out which device is in charge of the
current interrupt event.</p>

<p class="docText">Typical use of the argument in an interrupt handler is as follows:</p>

<pre>static irqreturn_t sample_interrupt(int irq, void *dev_id, struct pt_regs 
                             *regs)
{
    struct sample_dev *dev = dev_id;

    /* now `dev' points to the right hardware item */
    /* .... */
}</pre><br>


<p class="docText">The typical <span class="docEmphasis">open</span> code associated with this
handler looks like this:</p>

<pre>static void sample_open(struct inode *inode, struct file *filp)
{
    struct sample_dev *dev = hwinfo + MINOR(inode-&gt;i_rdev);
    request_irq(dev-&gt;irq, sample_interrupt,
                0 /* flags */, "sample", dev /* dev_id */);
    /*....*/
    return 0;
}</pre><br>


<p class="docText"><a name="chp-10-ITERM-6119"></a>The last argument, <tt>struct
pt_regs *regs</tt>, is rarely used. It holds a snapshot of the
processor's context before the processor entered
interrupt code. The registers can be used for monitoring and
debugging; they are not normally needed for regular device driver
tasks.</p>

<p class="docText">Interrupt handlers should return a value indicating whether there was
actually an interrupt to handle. If the handler found that its device
did, indeed, need attention, it should return
<tt>IRQ_HANDLED</tt>; otherwise the return value should be
<tt>IRQ_NONE</tt>. You can also generate the return value
with this macro:</p>

<pre>IRQ_RETVAL(handled)</pre><BR>


<p class="docText">where <tt>handled</tt> is nonzero if you were able to
handle the interrupt. The return value is used by the kernel to
detect and suppress spurious interrupts. If your device gives you no
way to tell whether it really interrupted, you should return
<tt>IRQ_HANDLED</tt>.</p>


<a name="chp-10-sect-3.2"></a>
<H4 class="docSection2Title">10.3.2. Enabling and Disabling Interrupts</H4>

<p class="docText">There are times when a
<a name="chp-10-ITERM-6120"></a>
<a name="chp-10-ITERM-6121"></a>device driver must block the delivery
of interrupts for a (hopefully short) period of time.
Often,
interrupts must be blocked while holding a spinlock to avoid
deadlocking the system. There are ways of disabling interrupts that
do not involve spinlocks. But before we discuss them, note that
disabling interrupts should be a relatively rare activity, even in
device drivers, and this technique should never be used as a mutual
exclusion mechanism within a driver.</p>

<a name="chp-10-sect-3.2.1"></a>
<h5 class="docSection3Title">10.3.2.1 Disabling a single interrupt</h5>

<p class="docText">Sometimes (but rarely!) a driver needs to disable interrupt delivery
for a specific interrupt line. The kernel offers three functions for
this purpose, all declared in <I>&lt;asm/irq.h&gt;</i>.
These functions are part of the kernel API, so we describe them, but
their use is discouraged in most drivers. Among other things, you
cannot disable shared interrupt lines, and, on modern systems, shared
interrupts are the norm. That said, here they are:</P>

<pre>void disable_irq(int irq);
void disable_irq_nosync(int irq);
void enable_irq(int irq);</pre><BR>


<p class="docText">Calling any of these functions may update the mask for the specified
<tt>irq</tt> in the programmable interrupt controller
(PIC), thus disabling or enabling the specified IRQ across all
processors. Calls to these functions can be nestedâ€”if
<span class="docEmphasis">disable_irq</span> is called twice in succession, two
<span class="docEmphasis">enable_irq</span> calls are required before the IRQ is
truly reenabled. It is possible to call these functions from an
interrupt handler, but enabling your own IRQ while handling it is not
usually good practice.</P>

<p class="docText"><span class="docEmphasis">disable_irq</span> not only disables the given
interrupt but also waits for a currently executing interrupt handler,
if any, to complete. Be aware that if the thread calling
<span class="docEmphasis">disable_irq</span> holds any resources (such as
spinlocks) that the interrupt handler needs, the system can deadlock.
<span class="docEmphasis">disable_irq_nosync</span> differs from
<span class="docEmphasis">disable_irq</span> in that it returns immediately.
Thus, using <span class="docEmphasis">disable_irq_nosync</span> is a little
faster but may leave your driver open to race conditions.</p>

<p class="docText"><a name="chp-10-ITERM-6122"></a>
<a name="chp-10-ITERM-6123"></a>But why disable an
interrupt? Sticking to the parallel port, let's look
at the <span class="docEmphasis">plip</span> network interface. A
<span class="docEmphasis">plip</span> device uses the bare-bones parallel port to
transfer data. Since only five bits can be read from the parallel
connector, they are interpreted as four data bits and a
clock/handshake signal. When the first four bits of a packet are
transmitted by the initiator (the interface sending the packet), the
clock line is raised, causing the receiving interface to interrupt
the processor. The <span class="docEmphasis">plip</span> handler is then invoked
to deal with newly arrived data.</p>

<p class="docText">After the device has been alerted, the data transfer proceeds, using
the handshake line to clock new data to the receiving interface (this
might not be the best implementation, but it is necessary for
compatibility with other packet drivers using the parallel port).
Performance would be unbearable if the receiving interface had to
handle two interrupts for every byte received. Therefore, the driver
disables the interrupt during the reception of the packet; instead, a
poll-and-delay loop is used to bring in the data.</p>

<p class="docText">Similarly, because the handshake line from the receiver to the
transmitter is used to acknowledge data reception, the transmitting
interface disables its IRQ line during packet transmission.</p>



<a name="chp-10-sect-3.2.2"></a>
<H5 class="docSection3Title">10.3.2.2 Disabling all interrupts</H5>

<p class="docText">What if you need to disable <span class="docEmphasis">all</span> interrupts? In
the 2.6 kernel, it is possible to turn off all interrupt handling on
the current processor with either of the following two functions
(which are defined in <I>&lt;asm/system.h&gt;</i>):</P>

<pre>void local_irq_save(unsigned long flags);
void local_irq_disable(void);</pre><BR>


<p class="docText">A call to <span class="docEmphasis">local_irq_save</span> disables interrupt
delivery on the current processor after saving the current interrupt
state into <tt>flags</tt>. Note that
<tt>flags</tt> is passed directly, not by pointer.
<span class="docEmphasis">local_irq_disable</span> shuts off local interrupt
delivery without saving the state; you should use this version only
if you know that interrupts have not already been disabled elsewhere.</p>

<p class="docText">Turning interrupts back on is accomplished with:</p>

<pre>void local_irq_restore(unsigned long flags);
void local_irq_enable(void);</pre><br>


<p class="docText">The first version restores that state which was stored into
<tt>flags</tt> by <span class="docEmphasis">local_irq_save</span>,
while <span class="docEmphasis">local_irq_enable</span> enables interrupts
unconditionally. Unlike <span class="docEmphasis">disable_irq</span>,
<span class="docEmphasis">local_irq_disable</span> does not keep track of
multiple calls. If more than one function in the call chain might
need to disable interrupts, <span class="docEmphasis">local_irq_save</span>
should be used.</p>

<p class="docText">In the 2.6 kernel, there is no way to disable all interrupts globally
across the entire system. The kernel developers have decided that the
cost of shutting off all interrupts is too high and that there is no
need for that capability in any case. If you are working with an
older driver that makes calls to functions such as
<span class="docEmphasis">cli</span> and <span class="docEmphasis">sti</span>, you need to
update it to use proper locking before it will <a name="chp-10-ITERM-6124"></a> <a name="chp-10-ITERM-6125"></a> <a name="chp-10-ITERM-6126"></a>work under 2.6.</P>




<ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-10-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-10-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
