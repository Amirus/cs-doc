<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>4.3. Debugging by Querying</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-4-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-4-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="chp-4-sect-3"></a>
<h3 class="docSection1Title">4.3. Debugging by Querying</h3>

<p class="docText">The previous section<a name="chp-4-ITERM-4785"></a> <a name="chp-4-ITERM-4786"></a>
<a name="chp-4-ITERM-4787"></a> described how
<span class="docEmphasis">printk</span> works and how it can be used. What it
didn't talk about are its disadvantages.</p>

<p class="docText">A massive use of <span class="docEmphasis">printk</span> can
slow<a name="chp-4-ITERM-4788"></a>
down the system noticeably, even if you lower
<span class="docEmphasis">console_loglevel</span> to avoid loading the console
device, because <span class="docEmphasis">syslogd</span> keeps syncing its output
files; thus, every line that is printed causes a disk operation. This
is the right implementation from <span class="docEmphasis">syslogd</span>
's perspective. It tries to write everything to disk
in case the system crashes right after printing the message; however,
you don't want to slow down your system just for the
sake of debugging messages. This problem can be solved by prefixing
the name of your log file as it appears in
<i>/etc/syslogd.conf</I> with a hyphen.<sup class="docFootnote"><a class="docLink" href="chp-4-sect-3.shtml#chp-4-FNOTE-2">[2]</a></sup> The problem with changing
the configuration file is that the modification will likely remain
there after you are done debugging, even though during normal system
operation you do want messages to be flushed to disk as soon as
possible. An alternative to such a permanent change is running a
program other than <span class="docEmphasis">klogd</span> (such as <span class="docEmphasis">cat
/proc/kmsg</span>, as suggested earlier), but this may not
provide a suitable environment for normal system operation.</p><blockquote><p class="docFootnote"><sup><a name="chp-4-FNOTE-2">[2]</a></sup> The hyphen, or minus sign, is a
"magic" marker to prevent
<span class="docEmphasis">syslogd</span> from flushing the file to disk at every
new message, documented in <span class="docEmphasis">syslog.conf(5)</span>, a
manpage worth reading.</P></blockquote>

<p class="docText">More often than not, the best way to get relevant information is to
query the system when you need the information, instead of
continually producing data. In fact, every Unix system provides many
tools for obtaining system information: <span class="docEmphasis">ps</span>,
<span class="docEmphasis">netstat</span>, <span class="docEmphasis">vmstat</span>, and so on.</P>

<p class="docText">A few techniques are available to driver developers for querying the
system: creating a file in the <i>/proc</i> filesystem,
using the <span class="docEmphasis">ioctl</span> driver method, and exporting
attributes via <span class="docEmphasis">sysfs</span>. The use of
<span class="docEmphasis">sysfs</span> requires quite some background on the
driver model. It is discussed in <a class="docLink" href="chp-14.shtml#chp-14">Chapter 14</a>.</p>

<a name="chp-4-sect-3.1"></a>
<H4 class="docSection2Title">4.3.1. Using the /proc Filesystem</h4>

<p class="docText">The <I>/proc</I> filesystem is a special,
software-created filesystem that is used by the kernel to export
information to the world. Each file under <I>/proc</i>
is tied to a kernel function that generates the
file's "contents"
on the fly when the file is read. We have already seen some of these
files in action; <i>/proc/modules</i>, for example,
always returns a list of the currently loaded modules.</p>

<p class="docText"><I>/proc</I> is heavily used in the Linux system. Many
utilities on a modern Linux distribution, such as
<span class="docEmphasis">ps</span>, <span class="docEmphasis">top</span>, and
<span class="docEmphasis">uptime</span>, get their information from
<I>/proc</i>. Some device drivers also export
information via <I>/proc</I>, and yours can do so as
well. The <i>/proc</i> filesystem is dynamic, so your
module can add or remove entries at any time.</p>

<p class="docText">Fully featured <i>/proc</I> entries can be complicated
beasts; among other things, they can be written to as well as read
from. Most of the time, however, <i>/proc</i> entries
are read-only files. This section concerns itself with the simple
read-only case. Those who are interested in implementing something
more complicated can look here for the basics; the kernel source may
then be consulted for the full picture.</P>

<p class="docText">Before we continue, however, we should mention that adding files
under <i>/proc</i> is discouraged. The
<I>/proc</i> filesystem is seen by the kernel
developers as a bit of an uncontrolled mess that has gone far beyond
its original purpose (which was to provide information about the
processes running in the system). The recommended way of making
information available in new code is via sysfs. As suggested, working
with sysfs requires an understanding of the Linux device model,
however, and we do not get to that until <a class="docLink" href="chp-14.shtml#chp-14">Chapter 14</a>. Meanwhile, files under
<I>/proc</i> are slightly easier to create, and they
are entirely suitable for debugging purposes, so we cover them here.</p>

<a name="chp-4-sect-3.1.1"></a>
<h5 class="docSection3Title">4.3.1.1 Implementing files in /proc</h5>

<p class="docText">All modules that work with <i>/proc</i>
<a name="chp-4-ITERM-4789"></a>should include
<i>&lt;linux/proc_fs.h&gt;</i> to define the proper
functions.</p>

<p class="docText">To create a <a name="chp-4-ITERM-4790"></a>read-only <i>/proc</i>
file, your<a name="chp-4-ITERM-4791"></a> driver must implement a
function to produce the data when the file is read. When some process
reads the file (using the <span class="docEmphasis">read</span> system call), the
request reaches your module by means of this function.
We'll look at this function first and get to the
registration interface later in this section.</p>

<p class="docText">When a process reads from your <i>/proc</I> file, the
kernel allocates a page of memory (i.e., <tt>PAGE_SIZE</tt>
bytes) where the driver can write data to be returned to user space.
That buffer is passed to your function, which is a method called
<span class="docEmphasis">read_proc</span>:</p>

<pre>int (*read_proc)(char *page, char **start, off_t offset, int count, 
                 int *eof, void *data);</pre><BR>


<p class="docText">The <tt>page</tt> pointer is the buffer where
you'll write your data; <tt>start</tt> is
used by the function to say where the interesting data has been
written in <tt>page</tt> (more on this later);
<tt>offset</tt> and <tt>count</tt> have the same
meaning as for the <span class="docEmphasis">read</span> method. The
<tt>eof</tt> argument points to an integer that must be set
by the driver to signal that it has no more data to return, while
<tt>data</tt> is a driver-specific data pointer you can use
for internal bookkeeping.</P>

<p class="docText">This function should return the number of bytes of data actually
placed in the <tt>page</tt> buffer, just like the
<span class="docEmphasis">read</span> method does for other files. Other output
values are <tt>*eof</tt> and <tt>*start</tt>.
<tt>eof</tt> is a simple flag, but the use of the
<tt>start</tt> value is somewhat more complicated; its
purpose is to help with the implementation of large (greater than one
page) <i>/proc</i> files.</p>

<p class="docText">The <tt>start</tt> parameter has a somewhat unconventional
use. Its purpose is to indicate where (within
<tt>page</tt>) the data to be returned to the user is
found. When your
<span class="docEmphasis">proc_read</span><a name="chp-4-ITERM-4792"></a>
<a name="chp-4-ITERM-4793"></a>
method is called, <tt>*start</tt> will be
<tt>NULL</tt>. If you leave it <tt>NULL</tt>, the
kernel assumes that the data has been put into
<tt>page</tt> as if <tt>offset</tt> were
<tt>0</tt>; in other words, it assumes a simple-minded
version of <span class="docEmphasis">proc_read</span>, which places the entire
contents of the virtual file in <tt>page</tt> without
paying attention to the <tt>offset</tt> parameter. If,
instead, you set <tt>*start</tt> to a
non-<tt>NULL</tt> value, the kernel assumes that the data
pointed to by <tt>*start</tt> takes
<tt>offset</tt> into account and is ready to be returned
directly to the user. In general, simple
<span class="docEmphasis">proc_read</span> methods that return tiny amounts of
data just ignore <tt>start</tt>. More complex methods set
<tt>*start</tt> to <tt>page</tt> and only place
data beginning at the requested offset there.</P>

<p class="docText"><a name="chp-4-ITERM-4794"></a>There has long been another major issue
with <i>/proc</I> files, which <tt>start</tt>
is meant to solve as well. Sometimes the ASCII representation of
kernel data structures changes between successive calls to
<span class="docEmphasis">read</span>, so the reader process could find
inconsistent data from one call to the next. If
<tt>*start</tt> is set to a small integer value, the caller
uses it to increment <tt>filp-&gt;f_pos</tt> independently
of the amount of data you return, thus making
<tt>f_pos</tt> an internal record number of your
<span class="docEmphasis">read_proc</span> procedure. If, for example, your
<span class="docEmphasis">read_proc</span><a name="chp-4-ITERM-4795"></a>
<a name="chp-4-ITERM-4796"></a>
function is returning information from a big array of structures, and
five of those structures were returned in the first call,
<tt>*start</tt> could be set to <tt>5</tt>. The
next call provides that same value as the offset; the driver then
knows to start returning data from the sixth structure in the array.
This is acknowledged as a "hack" by
its authors and can be seen in
<I>fs/proc/generic.c</I>.</p>

<p class="docText">Note that there is a better way to implement large
<i>/proc</i> files; it's called
<tt>seq_file</tt>, and we'll discuss it
shortly. First, though, it is time for an example. Here is a simple
(if somewhat ugly) <span class="docEmphasis">read_proc</span> implementation for
the<a name="chp-4-ITERM-4797"></a> <span class="docEmphasis">scull</span> device:</p>

<pre>int scull_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
    int i, j, len = 0;
    int limit = count - 80; /* Don't print more than this */

    for (i = 0; i &lt; scull_nr_devs &amp;&amp; len &lt;= limit; i++) {
        struct scull_dev *d = &amp;scull_devices[i];
        struct scull_qset *qs = d-&gt;data;
        if (down_interruptible(&amp;d-&gt;sem))
            return -ERESTARTSYS;
        len += sprintf(buf+len,"\nDevice %i: qset %i, q %i, sz %li\n",
                i, d-&gt;qset, d-&gt;quantum, d-&gt;size);
        for (; qs &amp;&amp; len &lt;= limit; qs = qs-&gt;next) { /* scan the list */
            len += sprintf(buf + len, "  item at %p, qset at %p\n",
                    qs, qs-&gt;data);
            if (qs-&gt;data &amp;&amp; !qs-&gt;next) /* dump only the last item */
                for (j = 0; j &lt; d-&gt;qset; j++) {
                    if (qs-&gt;data[j])
                        len += sprintf(buf + len,
                                "    % 4i: %8p\n",
                                j, qs-&gt;data[j]);
                }
        }
        up(&amp;scull_devices[i].sem);
    }
    *eof = 1;
    return len;
}</pre><BR>


<p class="docText">This is a fairly typical <span class="docEmphasis">read_proc</span>
implementation. It assumes that there will never be a need to
generate more than one page of data and so ignores the
<tt>start</tt> and <tt>offset</tt> values. It is,
however, careful not to overrun its buffer, just in case.</P>



<a name="chp-4-sect-3.1.2"></a>
<H5 class="docSection3Title">4.3.1.2 An older interface</h5>

<p class="docText">If you read through the kernel source,<a name="chp-4-ITERM-4798"></a>
<a name="chp-4-ITERM-4799"></a> you may encounter code
implementing <I>/proc</I> files with an older
interface:</p>

<pre>int (*get_info)(char *page, char **start, off_t offset, int count);</pre><br>


<p class="docText">All of the arguments have the same meaning as they do for
<span class="docEmphasis">read_proc</span>, but the <tt>eof</tt> and
<tt>data</tt> arguments are missing. This interface is
still supported, but it could go away in the future; new code should
use the <span class="docEmphasis">read_proc</span> interface instead.</p>



<a name="chp-4-sect-3.1.3"></a>
<h5 class="docSection3Title">4.3.1.3 Creating your /proc file</H5>

<p class="docText">Once you have a <span class="docEmphasis">read_proc</span>
<a name="chp-4-ITERM-4800"></a>function defined,
<a name="chp-4-ITERM-4801"></a>
<a name="chp-4-ITERM-4802"></a>you need to connect it to
an entry in the <i>/proc</i> hierarchy. This is
<a name="chp-4-ITERM-4803"></a>
<a name="chp-4-ITERM-4804"></a>done with
a call to
<span class="docEmphasis">create_proc_read_entry</span><a name="chp-4-ITERM-4805"></a>
<a name="chp-4-ITERM-4806"></a>:</P>

<pre>struct proc_dir_entry *create_proc_read_entry(const char *name,
                              mode_t mode, struct proc_dir_entry *base, 
                              read_proc_t *read_proc, void *data);</pre><br>


<p class="docText">Here, <tt>name</tt> is the name of the file to create,
<tt>mode</tt> is the protection mask for the file (it can
be passed as 0 for a system-wide default), <tt>base</tt>
indicates the directory in which the file should be created (if
<tt>base</tt> is <tt>NULL</tt>, the file is
created in the <span class="docEmphasis">/proc</span> root),
<tt>read_proc</tt> is the <span class="docEmphasis">read_proc</span>
function that implements the file, and <tt>data</tt> is
ignored by the kernel (but passed to <span class="docEmphasis">read_proc</span>).
Here is the call used by <span class="docEmphasis">scull</span> to make its
<i>/proc</I> function available as
<i>/proc/scullmem</I>:</p>

<pre>create_proc_read_entry("scullmem", 0 /* default mode */,
        NULL /* parent dir */, scull_read_procmem,
        NULL /* client data */);</pre><br>


<p class="docText">Here, we create a file called <i>scullmem</i> directly
under <i>/proc</i>, with the default, world-readable
protections.</p>

<p class="docText">The directory entry pointer can be used to
create<a name="chp-4-ITERM-4807"></a> entire directory hierarchies
under <i>/proc</i>. Note, however, that an entry may be
more easily placed in a subdirectory of <i>/proc</i>
simply by giving the directory name as part of the name of the
entry—as long as the directory itself already exists. For
example, an (often ignored) convention says that
<i>/proc</i> entries associated with device drivers
should go in the subdirectory <I>driver/</i>;
<span class="docEmphasis">scull</span> could place its entry there simply by
giving its name as <I>driver/scullmem</I>.</p>

<p class="docText"><a name="chp-4-ITERM-4808"></a>
<a name="chp-4-ITERM-4809"></a><a name="chp-4-ITERM-4810"></a>Entries in <i>/proc</i>,
of course, should be removed when the module is unloaded.
<span class="docEmphasis">remove_proc_entry</span> is the function that undoes
what <span class="docEmphasis">create_proc_read_entry</span> already did:</P>

<pre>remove_proc_entry("scullmem", NULL /* parent dir */);</pre><br>


<p class="docText">Failure to remove entries can result in calls at unwanted times, or,
if your module has been unloaded, kernel crashes.</P>

<p class="docText">When using <I>/proc</I> files as shown, you must
remember a few nuisances of the implementation—no surprise its
use is discouraged nowadays.</p>

<p class="docText">The most important problem is with
<a name="chp-4-ITERM-4811"></a>removal of
<i>/proc</i> entries. Such removal may well happen
while the file is in use, as there is no owner associated to
<i>/proc</I> entries, so using them
doesn't act on the module's
reference count. This problem is simply triggered by running
<I>sleep 100 &lt; /proc/myfile</I> just before removing
the module, for example.</p>

<p class="docText">Another issue is about registering two entries with the same name.
The kernel trusts the driver and doesn't check if
the name is already registered, so if you are not careful you might
end up with two or more entries with the same name. This is a problem
known to happen in classrooms, and such entries are
indistinguishable, both when you access them and when you call
<span class="docEmphasis">remove_proc_entry</span>.</P>



<a name="chp-4-sect-3.1.4"></a>
<H5 class="docSection3Title">4.3.1.4 The seq_file interface</h5>

<p class="docText">As we noted above, <a name="chp-4-ITERM-4812"></a> <a name="chp-4-ITERM-4813"></a>the
implementation of <a name="chp-4-ITERM-4814"></a>large files under
<i>/proc</i> is a little awkward. Over time,
<i>/proc</I> methods have become notorious for buggy
implementations when the amount of output grows large. As a way of
cleaning up the <i>/proc</i> code and making life
easier for kernel programmers, the <tt>seq_file</tt>
interface was added. This interface provides a simple set of
functions for the implementation of large kernel virtual files.</P>

<p class="docText">The <tt>seq_file</tt> interface assumes that you are
creating a virtual file that steps through a sequence of items that
must be returned to user space. To use <tt>seq_file</tt>,
you must create a simple "iterator"
object that can establish a position within the sequence, step
forward, and output one item in the sequence. It may sound
complicated, but, in fact, the process is quite simple.
We'll step through the creation of a
<i>/proc</i> file in the <span class="docEmphasis">scull</span>
driver to show how it is done.</P>

<p class="docText">The first step, inevitably, is the inclusion of
<i>&lt;linux/seq_file.h&gt;</I>. Then you must create
four iterator methods, called <span class="docEmphasis">start</span>,
<span class="docEmphasis">next</span>, <span class="docEmphasis">stop</span>, and
<span class="docEmphasis">show</span>.</p>

<p class="docText">The <span class="docEmphasis">start</span><a name="chp-4-ITERM-4815"></a>
<a name="chp-4-ITERM-4816"></a>
method is always called first. The prototype for this function is:</p>

<pre>void *start(struct seq_file *sfile, loff_t *pos);</pre><br>


<p class="docText">The <tt>sfile</tt><a name="chp-4-ITERM-4817"></a>
<a name="chp-4-ITERM-4818"></a>
argument can almost always be ignored. <tt>pos</tt> is an
integer position indicating where the reading should start. The
interpretation of the position is entirely up to the implementation;
it need not be a byte position in the resulting file. Since
<tt>seq_file</tt> implementations typically step through a
sequence of interesting items, the position is often interpreted as a
cursor pointing to the next item in the sequence. The
<span class="docEmphasis">scull</span> driver interprets each device as one item
in the sequence, so the incoming <tt>pos</tt> is simply an
index into the <tt>scull_devices</tt> array. Thus, the
<span class="docEmphasis">start</span> method used in <span class="docEmphasis">scull</span>
is:</p>

<pre>static void *scull_seq_start(struct seq_file *s, loff_t *pos)
{
    if (*pos &gt;= scull_nr_devs)
        return NULL;   /* No more to read */
    return scull_devices + *pos;
}</pre><br>


<p class="docText">The return value, if non-<tt>NULL</tt>, is a private value
that can be used by the iterator implementation.</p>

<p class="docText">The <span class="docEmphasis">next</span><a name="chp-4-ITERM-4819"></a>
<a name="chp-4-ITERM-4820"></a>
<a name="chp-4-ITERM-4821"></a> function should move the iterator to
the next position, returning <tt>NULL</tt> if there is
nothing left in the sequence. This method's
prototype is:</p>

<pre>void *next(struct seq_file *sfile, void *v, loff_t *pos);</pre><br>


<p class="docText">Here, <tt>v</tt> is the iterator as returned from the
previous call to <span class="docEmphasis">start</span> or
<span class="docEmphasis">next</span>, and <tt>pos</tt> is the current
position in the file. <span class="docEmphasis">next</span> should increment the
value pointed to by <tt>pos</tt>; depending on how your
iterator works, you might (though probably won't)
want to increment <tt>pos</tt> by more than one.
Here's what <span class="docEmphasis">scull</span> does:</p>

<pre>static void *scull_seq_next(struct seq_file *s, void *v, loff_t *pos)
{
    (*pos)++;
    if (*pos &gt;= scull_nr_devs)
        return NULL;
    return scull_devices + *pos;
}</pre><br>


<p class="docText">When the kernel is done with the iterator, it
calls<a name="chp-4-ITERM-4822"></a>
<a name="chp-4-ITERM-4823"></a>
<a name="chp-4-ITERM-4824"></a> <span class="docEmphasis">stop</span> to clean up:</p>

<pre>void stop(struct seq_file *sfile, void *v);</pre><br>


<p class="docText">The <span class="docEmphasis">scull</span> implementation has no cleanup work to
do, so its <span class="docEmphasis">stop</span> method is empty.</p>

<p class="docText">It is worth noting that the <tt>seq_file</tt> code, by
design, does not sleep or perform other nonatomic tasks between the
calls to <span class="docEmphasis">start</span> and <span class="docEmphasis">stop</span>.
You are also guaranteed to see one <span class="docEmphasis">stop</span> call
sometime shortly after a call to <span class="docEmphasis">start</span>.
Therefore, it is safe for your <span class="docEmphasis">start</span> method to
acquire semaphores or spinlocks. As long as your other
<tt>seq_file</tt> methods are atomic, the whole sequence of
calls is atomic. (If this paragraph does not make sense to you, come
back to it after you've read the next chapter.)</P>

<p class="docText">In between these calls, the kernel calls the <a name="chp-4-ITERM-4825"></a>
<a name="chp-4-ITERM-4826"></a>
<a name="chp-4-ITERM-4827"></a><span class="docEmphasis">show</span> method to
actually output something interesting to the user space. This
method's prototype is:</p>

<pre>int show(struct seq_file *sfile, void *v);</pre><BR>


<p class="docText">This method should create output for the item in the sequence
indicated by the iterator <tt>v</tt>. It should not
use<a name="chp-4-ITERM-4828"></a>
<a name="chp-4-ITERM-4829"></a>
<span class="docEmphasis">printk</span>, however; instead, there is a special set
of functions for <tt>seq_file</tt> output:</P>

<a name="chp-4-ITERM-4830"></a><a name="chp-4-ITERM-4831"></a><a name="chp-4-ITERM-4832"></a><a name="chp-4-ITERM-4833"></a><a name="chp-4-ITERM-4834"></a><a name="chp-4-ITERM-4835"></a><a name="chp-4-ITERM-4836"></a><a name="chp-4-ITERM-4837"></a><a name="chp-4-ITERM-4838"></a><a name="chp-4-ITERM-4839"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int seq_printf(struct seq_file *sfile, const char *fmt, ...);</span></span><a name="chp-4-ITERM-4830"></a>
<a name="chp-4-ITERM-4831"></a></span></dt></p>
<dd>
<p class="docList">This is the <span class="docEmphasis">printf</span> equivalent for
<tt>seq_file</tt> implementations; it takes the usual
format string and additional value arguments. You must also pass it
the <tt>seq_file</tt> structure given to the
<span class="docEmphasis">show</span> function, however. If
<span class="docEmphasis">seq_printf</span> returns a nonzero value, it means
that the buffer has filled, and output is being discarded. Most
implementations ignore the return value, however.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int seq_putc(struct seq_file *sfile, char c);</span></span><a name="chp-4-ITERM-4832"></a>
<a name="chp-4-ITERM-4833"></a></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int seq_puts(struct seq_file *sfile, const char *s);</span></span><a name="chp-4-ITERM-4834"></a>
<a name="chp-4-ITERM-4835"></a></span></dt></p>
<dd>
<p class="docList">These are the equivalents of the user-space <span class="docEmphasis">putc</span>
and <span class="docEmphasis">puts</span> functions.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int seq_escape(struct seq_file *m, const char *s, const char *esc);</span></span><a name="chp-4-ITERM-4836"></a>
<a name="chp-4-ITERM-4837"></a></span></dt></P>
<dd>
<p class="docList">This function is equivalent to <span class="docEmphasis">seq_puts</span> with the
exception that any character in <tt>s</tt> that is also
found in <tt>esc</tt> is printed in octal format. A common
value for <tt>esc</tt> is "<tt> \t\n\\</tt>",
which keeps embedded white space from messing up the output and
possibly confusing shell scripts.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int seq_path(struct seq_file *sfile, struct vfsmount *m, struct dentry</span></span><a name="chp-4-ITERM-4838"></a>
<a name="chp-4-ITERM-4839"></a> </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">*dentry, char *esc);</span></span></span></dt></p>
<dd>
<p class="docList">This function can be used for outputting the file name associated
with a given directory entry. It is unlikely to be useful in device
drivers; we have included it here for completeness.</p>
</dd>
</dl>

<p class="docText">Getting back to our example; the <span class="docEmphasis">show</span> method
used in <span class="docEmphasis">scull</span> is:</P>

<pre>static int scull_seq_show(struct seq_file *s, void *v)
{
    struct scull_dev *dev = (struct scull_dev *) v;
    struct scull_qset *d;
    int i;

    if (down_interruptible(&amp;dev-&gt;sem))
        return -ERESTARTSYS;
    seq_printf(s, "\nDevice %i: qset %i, q %i, sz %li\n",
            (int) (dev - scull_devices), dev-&gt;qset,
            dev-&gt;quantum, dev-&gt;size);
    for (d = dev-&gt;data; d; d = d-&gt;next) { /* scan the list */
        seq_printf(s, "  item at %p, qset at %p\n", d, d-&gt;data);
        if (d-&gt;data &amp;&amp; !d-&gt;next) /* dump only the last item */
            for (i = 0; i &lt; dev-&gt;qset; i++) {
                if (d-&gt;data[i])
                    seq_printf(s, "    % 4i: %8p\n",
                            i, d-&gt;data[i]);
            }
    }
    up(&amp;dev-&gt;sem);
    return 0;
}</pre><br>


<p class="docText">Here, we finally interpret our
"iterator" value, which is simply a
pointer to a <tt>scull_dev</tt> structure.</p>

<p class="docText">Now that it has a full set of iterator operations,
<span class="docEmphasis">scull</span> must package them up and connect them to a
file in <I>/proc</i>. The first step is done by filling
in a <tt>seq_operations</tt> structure:</p>

<pre>static struct seq_operations scull_seq_ops = {
    .start = scull_seq_start,
    .next  = scull_seq_next,
    .stop  = scull_seq_stop,
    .show  = scull_seq_show
};</pre><BR>


<p class="docText">With that structure in place, we must create a file implementation
that the kernel understands. We do not use the
<span class="docEmphasis">read_proc</span> method described previously; when
using <tt>seq_file</tt>, it is best to connect in to
<i>/proc</I> at a slightly lower level. That means
creating a <tt>file_operations</tt> structure (yes, the
same structure used for char drivers) implementing all of the
operations needed by the kernel to handle reads and seeks on the
file. Fortunately, this task is straightforward. The first step is to
create an <span class="docEmphasis">open</span> method that connects the file to
the <tt>seq_file</tt> operations:</p>

<pre>static int scull_proc_open(struct inode *inode, struct file *file)
{
    return seq_open(file, &amp;scull_seq_ops);
}</pre><br>


<p class="docText">The call to <span class="docEmphasis">seq_open</span> connects the
<tt>file</tt> structure with our sequence operations
defined above. As it turns out, <span class="docEmphasis">open</span> is the only
file operation we must implement ourselves, so we can now set up our
<tt>file_operations</tt> structure:</p>

<pre>static struct file_operations scull_proc_ops = {
    .owner   = THIS_MODULE,
    .open    = scull_proc_open,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = seq_release
};</pre><br>


<p class="docText">Here we specify our own <span class="docEmphasis">open</span> method, but use the
canned methods <span class="docEmphasis">seq_read</span>,
<span class="docEmphasis">seq_lseek</span>, and <span class="docEmphasis">seq_release</span>
for everything else.</p>

<p class="docText">The final step is to create the actual file in
<i>/proc</i>:</p>

<pre>entry = create_proc_entry("scullseq", 0, NULL);
if (entry)
    entry-&gt;proc_fops = &amp;scull_proc_ops;</pre><br>


<p class="docText">Rather than using <span class="docEmphasis">create_proc_read_entry</span>, we
call the lower-level <span class="docEmphasis">create_proc_entry</span>, which
has this prototype:</p>

<pre>struct proc_dir_entry *create_proc_entry(const char *name,
                              mode_t mode, 
                              struct proc_dir_entry *parent);</pre><br>


<p class="docText">The arguments are the same as their equivalents in
<span class="docEmphasis">create_proc_read_entry</span>: the name of the file,
its protections, and the parent directory.</p>

<p class="docText">With the above code, <span class="docEmphasis">scull</span> has a new
<i>/proc</I> entry that looks much like the previous
one. It is superior, however, because it works regardless of how
large its output becomes, it handles seeks properly, and it is
generally easier to read and maintain. We recommend the use of
<tt>seq_file</tt> for the implementation <a name="chp-4-ITERM-4840"></a> <a name="chp-4-ITERM-4841"></a>of files that
contain more than a very small number of lines of<a name="chp-4-ITERM-4842"></a> <a name="chp-4-ITERM-4843"></a> output.</p>



<a name="chp-4-sect-3.2"></a>
<H4 class="docSection2Title">4.3.2. The ioctl Method</H4>

<p class="docText"><span class="docEmphasis">ioctl</span>, which we show you
how<a name="chp-4-ITERM-4844"></a>
<a name="chp-4-ITERM-4845"></a>
<a name="chp-4-ITERM-4846"></a> to use in <a class="docLink" href="chp-6.shtml#chp-6">Chapter 6</a>, is a system call
that acts on a file descriptor; it receives a number that identifies
a command to be performed and (optionally) another argument, usually
a pointer. As an alternative to using the <i>/proc</i>
filesystem, you can implement a few <span class="docEmphasis">ioctl</span>
commands tailored for debugging. These commands can copy relevant
data structures from the driver to user space where you can examine
them.</p>

<p class="docText">Using <span class="docEmphasis">ioctl</span> this way to get information is
somewhat more difficult than using <I>/proc</i>,
because you need another program to issue the
<span class="docEmphasis">ioctl</span> and display the results. This program must
be written, compiled, and kept in sync with the module
you're testing. On the other hand, the driver-side
code can be easier than what is needed to implement a
<I>/proc</I> file.</P>

<p class="docText">There are times when <span class="docEmphasis">ioctl</span> is the best way to
get information, because it runs faster than reading
<i>/proc</i>. If some work must be performed on the
data before it's written to the screen, retrieving
the data in binary form is more efficient than reading a text file.
In addition, <span class="docEmphasis">ioctl</span> doesn't
require splitting data into fragments smaller than a page.</p>

<p class="docText"><a name="chp-4-ITERM-4847"></a><a name="chp-4-ITERM-4848"></a>Another interesting advantage of the
<span class="docEmphasis">ioctl</span> approach is that information-retrieval
commands can be left in the driver even when debugging would
otherwise be disabled. Unlike a <i>/proc</I> file,
which is visible to anyone who looks in the directory (and too many
people are likely to wonder "what that strange file
is"), undocumented <span class="docEmphasis">ioctl</span>
commands are likely to remain unnoticed. In addition, they will still
be there should something weird happen to<a name="chp-4-ITERM-4849"></a> <a name="chp-4-ITERM-4850"></a> <a name="chp-4-ITERM-4851"></a> the driver. The
only drawback is that the module will be slightly bigger.</P>



<UL></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-4-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-4-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
