<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>13.3. USB Urbs</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-13-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-13-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="chp-13-sect-3"></a>
<h3 class="docSection1Title">13.3. USB Urbs</h3>

<p class="docText">The USB code in the Linux kernel<a name="chp-13-ITERM-6441"></a> <a name="chp-13-ITERM-6442"></a>
<a name="chp-13-ITERM-6443"></a>
communicates with all USB devices using something called a
<span class="docEmphasis">urb</span> (<a name="chp-13-ITERM-6444"></a>USB request block). This
request block is described with the <tt>struct urb</tt>
structure and can be found in the <span class="docEmphasis">include/linux/usb.h</span>
file.</p>

<p class="docText">A urb is used to send or receive data to or from a specific USB
endpoint on a specific USB device in an asynchronous manner. It is
used much like a <tt>kiocb</tt> structure is used in the
filesystem async I/O code or as a <tt>struct</tt>
<tt>skbuff</tt> is used in the networking code. A USB
device driver may allocate many urbs for a single endpoint or may
reuse a single urb for many different endpoints, depending on the
need of the driver. Every endpoint in a device can handle a queue of
urbs, so that multiple urbs can be sent to the same endpoint before
the queue is empty. The typical
lifecycle<a name="chp-13-ITERM-6445"></a>
of a urb is as follows:</p>

<UL><li><p class="docList">Created by a USB device driver.</P></LI><li><p class="docList">Assigned to a specific endpoint of a specific USB device.</p></li><LI><p class="docList">Submitted to the USB core, by the USB device driver.</p></LI><LI><p class="docList">Submitted to the specific USB host controller driver for the
specified device by the USB core.</P></li><li><p class="docList">Processed by the USB host controller driver that makes a USB transfer
to the device.</p></li><LI><p class="docList">When the urb is completed, the USB host controller driver notifies
the USB device driver.</P></LI></ul>
<p class="docText">Urbs can also be canceled any time by the driver that submitted the
urb, or by the USB core if the device is removed from the system.
urbs are dynamically created and contain an internal reference count
that enables them to be automatically freed when the last user of the
urb releases it.</P>

<p class="docText">The procedure described in this chapter for handling urbs is useful,
because it permits streaming and other complex, overlapping
communications that allow drivers to achieve the highest possible
data transfer speeds. But less cumbersome procedures are available if
you just want to send individual bulk or control messages and do not
care about data throughput rates. (See the <a class="docLink" href="chp-13-sect-5.shtml#chp-13-sect-5">Section 13.5</a>.)</P>

<a name="chp-13-sect-3.1"></a>
<h4 class="docSection2Title">13.3.1. struct urb</h4>

<p class="docText">The fields of the<a name="chp-13-ITERM-6446"></a>
<a name="chp-13-ITERM-6447"></a>
<a name="chp-13-ITERM-6448"></a> <tt>struct urb</tt>
structure that matter to a USB device driver are:</p>

<a name="chp-13-ITERM-6449"></a><a name="chp-13-ITERM-6450"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct usb_device *dev</span></span><a name="chp-13-ITERM-6449"></a>  </span></dt></p>
<dd>
<p class="docList">Pointer to the <tt>struct usb_device</tt> to which this urb
is sent. This variable must be initialized by the USB driver before
the urb can be sent to the USB core.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int pipe</span></span><a name="chp-13-ITERM-6450"></a>  </span></dt></p>
<dd>
<p class="docList">Endpoint information for the specific <tt>struct</tt>
<tt>usb_device</tt> that this urb is to be sent to. This
variable must be initialized by the USB driver before the urb can be
sent to the USB core.</P>
</dd>
</dl>
<p class="docText">To set fields of this structure, the driver uses the following
functions as appropriate, depending on the direction of traffic. Note
that every endpoint can be of only one type.</p>

<a name="chp-13-ITERM-6451"></a><a name="chp-13-ITERM-6452"></a><a name="chp-13-ITERM-6453"></a><a name="chp-13-ITERM-6454"></a><a name="chp-13-ITERM-6455"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int usb_sndctrlpipe(struct usb_device *dev, unsigned int</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">endpoint)</span></span>  </span></dt></p>
<dd>
<p class="docList">Specifies a control OUT endpoint for the specified USB device with
the specified endpoint number.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int usb_rcvctrlpipe(struct usb_device *dev, unsigned int</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">endpoint)</span></span>  </span></dt></p>
<dd>
<p class="docList">Specifies a control IN endpoint for the specified USB device with the
specified endpoint number.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int usb_sndbulkpipe(struct usb_device *dev, unsigned int</span></span> </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">endpoint)</span></span>  </span></dt></p>
<dd>
<p class="docList">Specifies a bulk OUT endpoint for the specified USB device with the
specified endpoint number.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int usb_rcvbulkpipe(struct usb_device *dev, unsigned int</span></span> </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">endpoint)</span></span>  </span></dt></p>
<dd>
<p class="docList">Specifies a bulk IN endpoint for the specified USB device with the
specified endpoint number.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int usb_sndintpipe(struct usb_device *dev, unsigned int</span></span> <span class="docPubcolor"><span class="docMonofont">endpoint)</span></span>  </span></dt></P>
<dd>
<p class="docList">Specifies an interrupt OUT endpoint for the specified USB device with
the specified endpoint number.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int usb_rcvintpipe(struct usb_device *dev, unsigned int</span></span> <span class="docPubcolor"><span class="docMonofont">endpoint)</span></span>  </span></dt></P>
<dd>
<p class="docList">Specifies an interrupt IN endpoint for the specified USB device with
the specified endpoint number.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int usb_sndisocpipe(struct usb_device *dev, unsigned int</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">endpoint)</span></span>  </span></dt></p>
<dd>
<p class="docList">Specifies an isochronous OUT endpoint for the specified USB device
with the specified endpoint number.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int usb_rcvisocpipe(struct usb_device *dev, unsigned int</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">endpoint)</span></span>  </span></dt></P>
<dd>
<p class="docList">Specifies an isochronous IN endpoint for the specified USB device
with the specified endpoint number.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int transfer_flags</span></span><a name="chp-13-ITERM-6451"></a>  </span></dt></p>
<dd>
<p class="docList">This variable can be set to a number of different bit values,
depending on what the USB driver wants to happen to the urb. The
available values are:</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">URB_SHORT_NOT_OK</span></span>  </span></dt></p>
<dd>
<p class="docList">When set, it specifies that any short read on an IN endpoint that
might occur should be treated as an error by the USB core. This value
is useful only for urbs that are to be read from the USB device, not
for write urbs.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">URB_ISO_ASAP</span></span>  </span></dt></p>
<dd>
<p class="docList">If the urb is isochronous, this bit can be set if the driver wants
the urb to be scheduled, as soon as the bandwidth utilization allows
it to be, and to set the <tt>start_frame</tt> variable in
the urb at that point. If this bit is not set for an isochronous urb,
the driver must specify the <tt>start_frame</tt> value and
must be able to recover properly if the transfer cannot start at that
moment. See the upcoming section about isochronous urbs for more
information.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">URB_NO_TRANSFER_DMA_MAP</span></span>  </span></dt></P>
<dd>
<p class="docList">Should be set when the urb contains a DMA buffer to be transferred.
The USB core uses the buffer pointed to by the
<tt>TRansfer_dma</tt> variable and not the buffer pointed
to by the <tt>transfer_buffer</tt> variable.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">URB_NO_SETUP_DMA_MAP</span></span>  </span></dt></p>
<dd>
<p class="docList">Like the <tt>URB_NO_TRANSFER_DMA_MAP</tt> bit, this bit is
used for control urbs that have a DMA buffer already set up. If it is
set, the USB core uses the buffer pointed to by the
<tt>setup_dma</tt> variable instead of the
<tt>setup_packet</tt> variable.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">URB_ASYNC_UNLINK</span></span>  </span></dt></p>
<dd>
<p class="docList">If set, the call to <span class="docEmphasis">usb_unlink_urb</span> for this urb
returns almost immediately, and the urb is unlinked in the
background. Otherwise, the function waits until the urb is completely
unlinked and finished before returning. Use this bit with care,
because it can make synchronization issues very difficult to debug.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">URB_NO_FSBR</span></span>  </span></dt></P>
<dd>
<p class="docList">Used by only the UHCI USB Host controller driver and tells it to not
try to do Front Side Bus Reclamation logic. This bit should generally
not be set, because machines with a UHCI host controller create a lot
of CPU overhead, and the PCI bus is saturated waiting on a urb that
sets this bit.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">URB_ZERO_PACKET</span></span>  </span></dt></P>
<dd>
<p class="docList">If set, a bulk out urb finishes by sending a short packet containing
no data when the data is aligned to an endpoint packet boundary. This
is needed by some broken USB devices (such as a number of USB to IR
devices) in order to work properly.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">URB_NO_INTERRUPT</span></span>  </span></dt></p>
<dd>
<p class="docList">If set, the hardware may not generate an interrupt when the urb is
finished. This bit should be used with care and only when queuing
multiple urbs to the same endpoint. The USB core functions use this
in order to do DMA buffer transfers.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *transfer_buffer</span></span><a name="chp-13-ITERM-6452"></a>  </span></dt></p>
<dd>
<p class="docList">Pointer to the buffer to be used when sending data to the device (for
an OUT urb) or when receiving data from the device (for an IN urb).
In order for the host controller to properly access this buffer, it
must be created with a call to <tt>kmalloc</tt>, not on the
stack or statically. For control endpoints, this buffer is for the
data stage of the transfer.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">dma_addr_t transfer_dma</span></span><a name="chp-13-ITERM-6453"></a>  </span></dt></P>
<dd>
<p class="docList">Buffer to be used to transfer data to the USB device using DMA.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int transfer_buffer_length</span></span><a name="chp-13-ITERM-6454"></a>
<a name="chp-13-ITERM-6455"></a>  </span></dt></p>
<dd>
<p class="docList">The length of the buffer pointed to by the
<tt>transfer_buffer</tt> or the
<tt>transfer_dma</tt> variable (as only one can be used for
a urb). If this is <tt>0</tt>, neither transfer buffers are
used by the USB core.</p>
</dd>
</dl>
<p class="docText">For an OUT endpoint, if the endpoint maximum size is smaller than the
value specified in this variable, the transfer to the USB device is
broken up into smaller chunks in order to properly transfer the data.
This large transfer occurs in consecutive USB frames. It is much
faster to submit a large block of data in one urb, and have the USB
host controller split it up into smaller pieces, than it is to send
smaller buffers in consecutive order.</p>

<a name="chp-13-ITERM-6456"></a><a name="chp-13-ITERM-6457"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned char *setup_packet</span></span><a name="chp-13-ITERM-6456"></a>  </span></dt></p>
<dd>
<p class="docList">Pointer to the setup packet for a control urb. It is transferred
before the data in the transfer buffer. This variable is valid only
for control urbs.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">dma_addr_t setup_dma</span></span><a name="chp-13-ITERM-6457"></a>  </span></dt></p>
<dd>
<p class="docList">DMA buffer for the setup packet for a control urb. It is transferred
before the data in the normal transfer buffer. This variable is valid
only for control urbs.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">usb_complete_t complete</span></span>  </span></dt></P>
<dd>
<p class="docList">Pointer to the completion handler function that is called by the USB
core when the urb is completely transferred or when an error occurs
to the urb. Within this function, the USB driver may inspect the urb,
free it, or resubmit it for another transfer. (See the <a class="docLink" href="chp-13-sect-3.shtml#chp-13-sect-3.4">Section 13.3.4</a> for more details
about the completion handler.)</p>
</dd>
</dl>
<p class="docText">The <tt>usb_complete_t</tt> typedef is defined as:</p>

<pre>typedef void (*usb_complete_t)(struct urb *, struct pt_regs *);</pre><br>


<a name="chp-13-ITERM-6458"></a><a name="chp-13-ITERM-6459"></a><a name="chp-13-ITERM-6460"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *context</span></span><a name="chp-13-ITERM-6458"></a>  </span></dt></P>
<dd>
<p class="docList">Pointer to a data blob that can be set by the USB driver. It can be
used in the completion handler when the urb is returned to the
driver. See the following section for more details about this
variable.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int actual_length</span></span><a name="chp-13-ITERM-6459"></a>  </span></dt></p>
<dd>
<p class="docList">When the urb is finished, this variable is set to the actual length
of the data either sent by the urb (for OUT urbs) or received by the
urb (for IN urbs.) For IN urbs, this must be used instead of the
<tt>transfer_buffer_length</tt> variable, because the data
received could be smaller than the whole buffer size.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int status</span></span><a name="chp-13-ITERM-6460"></a>  </span></dt></P>
<dd>
<p class="docList">When the urb is finished, or being processed by the USB core, this
variable is set to the current status of the urb. The only time a USB
driver can safely access this variable is in the urb completion
handler function (described in <a class="docLink" href="chp-13-sect-3.shtml#chp-13-sect-3.4">Section 13.3.4</a>). This
restriction is to prevent race conditions that occur while the urb is
being processed by the USB core. For isochronous urbs, a successful
value (<tt>0</tt>) in this variable merely indicates
whether the urb has been unlinked. To obtain a detailed status on
isochronous urbs, the <tt>iso_frame_desc</tt> variables
should be checked.</p>
</dd>
</dl>
<p class="docText">Valid values for this variable include:</P>

<a name="chp-13-ITERM-6461"></a><a name="chp-13-ITERM-6462"></a><a name="chp-13-ITERM-6463"></a><a name="chp-13-ITERM-6464"></a><a name="chp-13-ITERM-6465"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">0</span></span></span></dt></p>
<dd>
<p class="docList">The urb transfer was successful.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-ENOENT</span></span>  </span></dt></p>
<dd>
<p class="docList">The urb was stopped by a call to <span class="docEmphasis">usb_kill_urb</span>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-ECONNRESET</span></span>  </span></dt></p>
<dd>
<p class="docList">The urb was unlinked by a call to
<span class="docEmphasis">usb_unlink_urb</span>, and the
<tt>TRansfer_flags</tt> variable of the urb was set to
<tt>URB_ASYNC_UNLINK</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-EINPROGRESS</span></span>  </span></dt></p>
<dd>
<p class="docList">The urb is still being processed by the USB host controllers. If your
driver ever sees this value, it is a bug in your driver.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-EPROTO</span></span>  </span></dt></p>
<dd>
<p class="docList">One of the following errors occurred with this urb:</p>

<ul><li><p class="docList">A bitstuff error happened during the transfer.</p></li><li><p class="docList">No response packet was received in time by the hardware.</p></LI></ul>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-EILSEQ</span></span>  </span></dt></p>
<dd>
<p class="docList">There was a CRC mismatch in the urb transfer.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-EPIPE</span></span>  </span></dt></p>
<dd>
<p class="docList">The endpoint is now stalled. If the endpoint involved is not a
control endpoint, this error can be cleared through a call to the
function <span class="docEmphasis">usb_clear_halt</span>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-ECOMM</span></span>  </span></dt></p>
<dd>
<p class="docList">Data was received faster during the transfer than it could be written
to system memory. This error value happens only for an IN urb.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-ENOSR</span></span>  </span></dt></P>
<dd>
<p class="docList">Data could not be retrieved from the system memory during the
transfer fast enough to keep up with the requested USB data rate.
This error value happens only for an OUT urb.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-EOVERFLOW</span></span>  </span></dt></P>
<dd>
<p class="docList">A "babble" error happened to the
urb. A "babble" error occurs when
the endpoint receives more data than the endpoint's
specified maximum packet size.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-EREMOTEIO</span></span>  </span></dt></p>
<dd>
<p class="docList">Occurs only if the <tt>URB_SHORT_NOT_OK</tt> flag is set in
the urb's <tt>transfer_flags</tt> variable
and means that the full amount of data requested by the urb was not
received.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-ENODEV</span></span>  </span></dt></P>
<dd>
<p class="docList">The USB device is now gone from the system.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-EXDEV</span></span>  </span></dt></p>
<dd>
<p class="docList">Occurs only for a isochronous urb and means that the transfer was
only partially completed. In order to determine what was transferred,
the driver must look at the individual frame status.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-EINVAL</span></span>  </span></dt></p>
<dd>
<p class="docList">Something very bad happened with the urb. The USB kernel
documentation describes what this value means:</p>

<pre>ISO madness, if this happens: Log off and go home</pre><br>


<p class="docList">It also can happen if a parameter is incorrectly set in the urb
stucture or if an incorrect function parameter in the
<i>usb_submit_urb</i> call submitted the urb to the USB
core.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">-ESHUTDOWN</span></span>  </span></dt></p>
<dd>
<p class="docList">There was a severe error with the USB host controller driver; it has
now been disabled, or the device was disconnected from the system,
and the urb was submitted after the device was removed. It can also
occur if the configuration was changed for the device, while the urb
was submitted to the device.</p>

<p class="docList">Generally, the error values <tt>-EPROTO</tt>,
<tt>-EILSEQ</tt>, and <tt>-EOVERFLOW</tt>
indicate hardware problems with the device, the device firmware, or
the cable connecting the device to the computer.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int start_frame</span></span><a name="chp-13-ITERM-6461"></a>  </span></dt></P>
<dd>
<p class="docList">Sets or returns the initial frame number for isochronous transfers to
use.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int interval</span></span><a name="chp-13-ITERM-6462"></a>  </span></dt></p>
<dd>
<p class="docList">The interval at which the urb is polled. This is valid only for
interrupt or isochronous urbs. The value's units
differ depending on the speed of the device. For low-speed and
full-speed devices, the units are frames, which are equivalent to
milliseconds. For devices, the units are in microframes, which is
equivalent to units of 1/8 milliseconds. This value must be set by
the USB driver for isochronous or interrupt urbs before the urb is
sent to the USB core.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int number_of_packets</span></span><a name="chp-13-ITERM-6463"></a>  </span></dt></P>
<dd>
<p class="docList">Valid only for isochronous urbs and specifies the number of
isochronous transfer buffers to be handled by this urb. This value
must be set by the USB driver for isochronous urbs before the urb is
sent to the USB core.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int error_count</span></span><a name="chp-13-ITERM-6464"></a>  </span></dt></p>
<dd>
<p class="docList">Set by the USB core only for isochronous urbs after their completion.
It specifies the number of isochronous transfers that reported any
type of error.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct usb_iso_packet_descriptor iso_frame_desc[0]</span></span><a name="chp-13-ITERM-6465"></a>  </span></dt></P>
<dd>
<p class="docList">Valid only for isochronous urbs. This variable is an array of the
<tt>struct usb_iso_packet_descriptor</tt> structures that
make up this urb. This structure allows a single urb to define a
number of isochronous transfers at once. It is also used to collect
the transfer status of each individual transfer.</p>
</dd>
</dl>
<p class="docText">The <tt>struct usb_iso_packet_descriptor</tt> is made up of
the following fields:</P>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int offset</span></span>  </span></dt></p>
<dd>
<p class="docList">The offset into the transfer buffer (starting at <tt>0</tt>
for the first byte) where this packet's data is
located.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int length</span></span>  </span></dt></p>
<dd>
<p class="docList">The length of the transfer buffer for this packet.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int actual_length</span></span>  </span></dt></p>
<dd>
<p class="docList">The length of the data received into the transfer buffer for this
isochronous packet.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int status</span></span>  </span></dt></p>
<dd>
<p class="docList">The status of the individual isochronous transfer of this packet. It
can take the same return values as the main <tt>struct
urb</tt> structure's <tt>status</tt>
variable.</p>
</dd>
</dl>


<a name="chp-13-sect-3.2"></a>
<h4 class="docSection2Title">13.3.2. Creating and Destroying Urbs</h4>

<p class="docText">The <tt>struct</tt> <tt>urb</tt> structure must
never
<a name="chp-13-ITERM-6466"></a>
<a name="chp-13-ITERM-6467"></a>
<a name="chp-13-ITERM-6468"></a>be created statically in a driver or
within another structure, because that would break the reference
counting scheme used by the USB core for urbs. It must be created
with a call to the<a name="chp-13-ITERM-6469"></a>
<a name="chp-13-ITERM-6470"></a>
<span class="docEmphasis">usb_alloc_urb</span> function. This function has the
prototype:</p>

<pre>struct urb *usb_alloc_urb(int iso_packets, int mem_flags);</pre><br>


<p class="docText">The first parameter, <tt>iso_packets</tt>, is the number of
isochronous packets this urb should contain. If you do not want to
create an isochronous urb, this variable should be set to
<tt>0</tt>. The second parameter,
<tt>mem_flags</tt>, is the same type of flag that is passed
to the <span class="docEmphasis">kmalloc</span> function call to allocate memory
from the kernel (see <a class="docLink" href="chp-8-sect-1.shtml#chp-8-sect-1.1">Section 8.1.1</a>
for the details on these
flags). If the function is successful in allocating enough space for
the urb, a pointer to the urb is returned to the caller. If the
return value is <tt>NULL</tt>, some error occurred within
the USB core, and the driver needs to clean up properly.</p>

<p class="docText">After a urb has been created, it must be properly initialized before
it can be used by the USB core. See the next sections for how to
initialize different types of urbs.</p>

<p class="docText">In order to tell the USB core that the driver is finished with the
urb, the driver must call the <span class="docEmphasis">usb_free_urb</span>
function. This function only has one argument:</p>

<pre>void usb_free_urb(struct urb *urb);</pre><br>


<p class="docText">The argument is a pointer to the <tt>struct urb</tt> you
want to release. After this function is called, the urb structure is
gone, and the driver cannot access it any more.</p>

<a name="chp-13-sect-3.2.1"></a>
<h5 class="docSection3Title">13.3.2.1 Interrupt urbs</h5>

<p class="docText">The function <a name="chp-13-ITERM-6471"></a>
<a name="chp-13-ITERM-6472"></a><span class="docEmphasis">usb_fill_int_urb</span>
is a helper
function<a name="chp-13-ITERM-6473"></a>
<a name="chp-13-ITERM-6474"></a>
to properly initialize a urb to be sent to a interrupt endpoint of a
USB device:</P>

<pre>void usb_fill_int_urb(struct urb *urb, struct usb_device *dev,
                      unsigned int pipe, void *transfer_buffer,
                      int buffer_length, usb_complete_t complete,
                      void *context, int interval);</pre><br>


<p class="docText">This function contains a lot of parameters:</P>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct urb *urb</span></span>  </span></dt></p>
<dd>
<p class="docList">A pointer to the urb to be initialized.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct usb_device *dev</span></span>  </span></dt></P>
<dd>
<p class="docList">The USB device to which this urb is to be sent.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int pipe</span></span>  </span></dt></p>
<dd>
<p class="docList">The specific endpoint of the USB device to which this urb is to be
sent. This value is created with the previously mentioned
<span class="docEmphasis">usb_sndintpipe</span> or
<span class="docEmphasis">usb_rcvintpipe</span> functions.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *transfer_buffer</span></span>  </span></dt></P>
<dd>
<p class="docList">A pointer to the buffer from which outgoing data is taken or into
which incoming data is received. Note that this can not be a static
buffer and must be created with a call to
<span class="docEmphasis">kmalloc</span>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int buffer_length</span></span>  </span></dt></P>
<dd>
<p class="docList">The length of the buffer pointed to by the
<tt>transfer_buffer</tt> pointer.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">usb_complete_t complete</span></span>  </span></dt></P>
<dd>
<p class="docList">Pointer to the completion handler that is called when this urb is
completed.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *context</span></span>  </span></dt></p>
<dd>
<p class="docList">Pointer to the blob that is added to the urb structure for later
retrieval by the completion handler function.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int interval</span></span>  </span></dt></P>
<dd>
<p class="docList">The interval at which that this urb should be scheduled. See the
previous description of the <tt>struct urb</tt> structure
to find the proper units for this value.</p>
</dd>
</dl>



<a name="chp-13-sect-3.2.2"></a>
<h5 class="docSection3Title">13.3.2.2 Bulk urbs</h5>

<p class="docText">Bulk urbs are initialized<a name="chp-13-ITERM-6475"></a> much like interrupt urbs. The function
that does this is<a name="chp-13-ITERM-6476"></a>
<a name="chp-13-ITERM-6477"></a>
<span class="docEmphasis">usb_fill_bulk_urb</span>, and it looks like:</p>

<pre>void usb_fill_bulk_urb(struct urb *urb, struct usb_device *dev,
                       unsigned int pipe, void *transfer_buffer,
                       int buffer_length, usb_complete_t complete,
                       void *context);</pre><br>


<p class="docText">The function parameters are all the same as in the
<span class="docEmphasis">usb_fill_int_urb</span> function. However, there is no
<tt>interval</tt> parameter because bulk urbs have no
interval value. Please note that the <tt>unsigned</tt>
<tt>int</tt> <tt>pipe</tt> variable must be
initialized with a call to the <span class="docEmphasis">usb_sndbulkpipe</span>
or <span class="docEmphasis">usb_rcvbulkpipe</span> function.</p>

<p class="docText">The <span class="docEmphasis">usb_fill_int_urb</span> function does not set the
<tt>transfer_flags</tt> variable in the urb, so any
modification to this field has to be done by the driver itself.</p>



<a name="chp-13-sect-3.2.3"></a>
<h5 class="docSection3Title">13.3.2.3 Control urbs</h5>

<p class="docText">Control urbs <a name="chp-13-ITERM-6478"></a>are initialized almost the same way as
bulk urbs, with a call to the function
<a name="chp-13-ITERM-6479"></a>
<a name="chp-13-ITERM-6480"></a><span class="docEmphasis">usb_fill_control_urb</span>:</p>

<pre>void usb_fill_control_urb(struct urb *urb, struct usb_device *dev,
                          unsigned int pipe, unsigned char *setup_packet,
                          void *transfer_buffer, int buffer_length,
                          usb_complete_t complete, void *context);</pre><br>


<p class="docText">The function parameters are all the same as in the
<span class="docEmphasis">usb_fill_bulk_urb</span> function, except that there is
a new parameter, <tt>unsigned</tt> <tt>char</tt>
<tt>*setup_packet</tt>, which must point to the setup
packet data that is to be sent to the endpoint. Also, the
<tt>unsigned int</tt> <tt>pipe</tt> variable must
be initialized with a call to the
<span class="docEmphasis">usb_sndctrlpipe</span> or
<span class="docEmphasis">usb_rcvictrlpipe</span> function.</p>

<p class="docText">The <span class="docEmphasis">usb_fill_control_urb</span> function does not set
the <tt>TRansfer_flags</tt> variable in the urb, so any
modification to this field has to be done by the driver itself. Most
drivers do not use this function, as it is much simpler to use the
synchronous API calls as described in <a class="docLink" href="chp-13-sect-5.shtml#chp-13-sect-5">Section 13.5</a>.</p>



<a name="chp-13-sect-3.2.4"></a>
<H5 class="docSection3Title">13.3.2.4 Isochronous urbs</H5>

<p class="docText"><a name="chp-13-ITERM-6481"></a>Isochronous urbs unfortunately do not have
an initializer function like the interrupt, control, and bulk urbs
do. So they must be initialized "by
hand" in the driver before they can be submitted to
the USB core. The following is an example of how to properly
initialize this type of urb. It was taken from the
<span class="docEmphasis">konicawc.c</span> kernel driver located in the
<span class="docEmphasis">drivers/usb/media</span> directory in the main kernel
source tree.</p>

<pre>urb-&gt;dev = dev;
urb-&gt;context = uvd;
urb-&gt;pipe = usb_rcvisocpipe(dev, uvd-&gt;video_endp-1);
urb-&gt;interval = 1;
urb-&gt;transfer_flags = URB_ISO_ASAP;
urb-&gt;transfer_buffer = cam-&gt;sts_buf[i];
urb-&gt;complete = konicawc_isoc_irq;
urb-&gt;number_of_packets = FRAMES_PER_DESC;
urb-&gt;transfer_buffer_length = FRAMES_PER_DESC;
for (j=0; j &lt; FRAMES_PER_DESC; j++) {
        urb-&gt;iso_frame_desc[j].offset = j;
        urb-&gt;iso_frame_desc[j].length = 1;
}</pre><br>




<a name="chp-13-sect-3.3"></a>
<h4 class="docSection2Title">13.3.3. Submitting Urbs</H4>

<p class="docText">Once the urb has been <a name="chp-13-ITERM-6482"></a>
<a name="chp-13-ITERM-6483"></a>properly
created and initialized by the USB driver, it is ready to be
submitted to the USB core to be sent out to the USB device. This is
done with a call to the function
<a name="chp-13-ITERM-6484"></a>
<a name="chp-13-ITERM-6485"></a><span class="docEmphasis">usb_submit_urb</span>:</p>

<pre>int usb_submit_urb(struct urb *urb, int mem_flags);</pre><BR>


<p class="docText">The <tt>urb</tt> parameter is a pointer to the urb that is
to be sent to the device. The <tt>mem_flags</tt> parameter
is equivalent to the same parameter that is passed to the
<span class="docEmphasis">kmalloc</span> call and is used to tell the USB core
how to allocate any memory buffers at this moment in time.</P>

<p class="docText">After a urb has been submitted to the USB core successfully, it
should never try to access any fields of the urb structure until the
<span class="docEmphasis">complete</span> function is called.</P>

<p class="docText">Because the function <span class="docEmphasis">usb_submit_urb</span> can be
called at any time (including from within an interrupt context), the
specification of the <tt>mem_flags</tt> variable must be
correct. There are really only three valid values that should be
used, depending on when <span class="docEmphasis">usb_submit_urb</span> is being
called:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GFP_ATOMIC</span></span>  </span></dt></p>
<dd>
<p class="docList">This value should be used whenever the following are true:</P>

<UL><LI><p class="docList">The caller is within a urb completion handler, an interrupt, a bottom
half, a tasklet, or a timer callback.</p></LI><LI><p class="docList">The caller is holding a spinlock or rwlock. Note that if a semaphore
is being held, this value is not necessary.</p></li><li><p class="docList">The <tt>current-&gt;state</tt> is not
<tt>TASK_RUNNING</tt>. The state is always
<tt>TASK_RUNNING</tt> unless the driver has changed the
current state itself.</p></LI></ul>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GFP_NOIO</span></span>  </span></dt></p>
<dd>
<p class="docList">This value should be used if the driver is in the block I/O patch. It
should also be used in the error handling path of all storage-type
devices.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GFP_KERNEL</span></span>  </span></dt></P>
<dd>
<p class="docList">This should be used for all other situations that do not fall into
one of the previously mentioned categories.</p>
</dd>
</dl>


<a name="chp-13-sect-3.4"></a>
<h4 class="docSection2Title">13.3.4. Completing Urbs: The Completion Callback Handler</h4>

<p class="docText">If the call to <span class="docEmphasis">usb_submit_urb</span>
was<a name="chp-13-ITERM-6486"></a>
<a name="chp-13-ITERM-6487"></a>
<a name="chp-13-ITERM-6488"></a>
successful, transferring control of the urb to the USB core, the
function returns <tt>0</tt>; otherwise, a negative error
number is returned. If the function succeeds, the completion handler
of the urb (as specified by the <span class="docEmphasis">complete</span>
function pointer) is called exactly once when the urb is completed.
When this function is called, the USB core is finished with the URB,
and control of it is now returned to the device driver.</p>

<p class="docText">There are only three ways a urb can be finished and have the
<span class="docEmphasis">complete</span><a name="chp-13-ITERM-6489"></a>
<a name="chp-13-ITERM-6490"></a> function called:</p>

<ul><li><p class="docList">The urb is successfully sent to the device, and the device returns
the proper acknowledgment. For an OUT urb, the data was successfully
sent, and for an IN urb, the requested data was successfully
received. If this has happened, the <tt>status</tt>
variable in the urb is set to <tt>0</tt>.</p></li><li><p class="docList">Some kind of error happened when sending or receiving data from the
device. This is noted by the error value in the
<tt>status</tt> variable in the urb structure.</p></li><li><p class="docList">The urb was "unlinked" from the USB
core. This happens either when the driver tells the USB core to
cancel a submitted urb with a call to
<span class="docEmphasis">usb_unlink_urb</span> or
<span class="docEmphasis">usb_kill_urb</span>, or when a device is removed from
the system and a urb had been submitted to it.</P></li></UL>
<p class="docText">An example of how to test for the different return values within a
urb completion call is shown later in this chapter.</P>


<a name="chp-13-sect-3.5"></a>
<h4 class="docSection2Title">13.3.5. Canceling Urbs</h4>

<p class="docText">To stop a urb that has been<a name="chp-13-ITERM-6491"></a>
<a name="chp-13-ITERM-6492"></a> submitted to the USB core, the functions
<a name="chp-13-ITERM-6493"></a>
<a name="chp-13-ITERM-6494"></a>
<a name="chp-13-ITERM-6495"></a>
<a name="chp-13-ITERM-6496"></a><span class="docEmphasis">usb_kill_urb</span>
or<a name="chp-13-ITERM-6497"></a>
<a name="chp-13-ITERM-6498"></a>
<a name="chp-13-ITERM-6499"></a>
<a name="chp-13-ITERM-6500"></a>
<span class="docEmphasis">usb_unlink_urb</span> should be called:</p>

<pre>int usb_kill_urb(struct urb *urb);
int usb_unlink_urb(struct urb *urb);</pre><BR>


<p class="docText">The <tt>urb</tt> parameter for both of these functions is a
pointer to the urb that is to be canceled.</p>

<p class="docText">When the function is <span class="docEmphasis">usb_kill_urb</span>, the urb
lifecycle is stopped. This function is usually used when the device
is disconnected from the system, in the disconnect callback.</P>

<p class="docText">For some drivers, the <span class="docEmphasis">usb_unlink_urb</span> function
should be used to tell the USB core to stop an urb. This function
does not wait for the urb to be fully stopped before returning to the
caller. This is useful for stopping the urb while in an interrupt
handler or when a spinlock is held, as waiting for a urb to fully
stop requires the ability for the USB core to put the calling process
to sleep. This function requires that the
<tt>URB_ASYNC_UNLINK</tt> flag value <a name="chp-13-ITERM-6501"></a> <a name="chp-13-ITERM-6502"></a> <a name="chp-13-ITERM-6503"></a>be set in the urb
that is being asked to be stopped in order to work properly.</P>



<UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-13-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-13-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
