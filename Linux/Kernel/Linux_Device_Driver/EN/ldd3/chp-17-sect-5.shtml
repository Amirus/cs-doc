<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>17.5. Packet Transmission</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17-sect-6.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-17-sect-5"></a>
<h3 class="docSection1Title" >17.5. Packet Transmission</H3>

<p class="docText">The most important tasks <a name="chp-17-ITERM-7699"></a>
<a name="chp-17-ITERM-7700"></a>performed by network interfaces are data
transmission and reception. We start with transmission because it is
slightly easier to understand.</p>

<p class="docText"><a name="chp-17-ITERM-7701"></a>
<a name="chp-17-ITERM-7702"></a><a name="chp-17-ITERM-7703"></a><a name="chp-17-ITERM-7704"></a><a name="chp-17-ITERM-7705"></a><i>Transmission</I> refers
to the act of sending a packet over a network link. Whenever the
kernel needs to transmit a data packet, it calls the
driver's <span class="docEmphasis">hard_start_transmit</span>
method to put the data on an outgoing queue. Each packet handled by
the kernel is contained in a socket buffer structure
(<tt>struct</tt> <tt>sk_buff</tt>), whose
definition is found in <span class="docEmphasis">&lt;linux/skbuff.h&gt;</span>.
The structure gets its name from the Unix abstraction used to
represent a network connection, the <span class="docEmphasis">socket</span>. Even
if the interface has nothing to do with sockets, each network packet
belongs to a socket in the higher network layers, and the
input/output buffers of any socket are lists of
<tt>struct</tt> <tt>sk_buff</tt> structures. The
same <tt>sk_buff</tt> structure is used to host network
data throughout all the Linux network subsystems, but a socket buffer
is just a packet as far as the interface is concerned.</p>

<p class="docText">A pointer to <tt>sk_buff</tt> is usually called
<tt>skb</tt>, and we follow this practice both in the
sample code and in the text.</P>

<p class="docText">The socket buffer is a complex structure, and the kernel offers a
number of functions to act on it. The functions are described later
in <a class="docLink" href="chp-17-sect-10.shtml#chp-17-sect-10">Section 17.10</a>; for now, a few basic facts about
<tt>sk_buff</tt> are enough for us to write a working
driver.</p>

<p class="docText"><a name="chp-17-ITERM-7706"></a>
<a name="chp-17-ITERM-7707"></a>The
socket buffer passed to <span class="docEmphasis">hard_start_xmit</span> contains
the physical packet as it should appear on the media, complete with
the transmission-level headers. The interface
doesn't need to modify the data being transmitted.
<tt>skb-&gt;data</tt> points to the packet being
transmitted, and <tt>skb-&gt;len</tt> is its length in
octets. This situation gets a little more complicated if your driver
can handle scatter/gather I/O; we get to that in <a class="docLink" href="chp-17-sect-5.shtml#chp-17-sect-5.3">Section 17.5.3</a>.</p>

<p class="docText">The <span class="docEmphasis">snull</span> packet transmission code follows; the
physical transmission machinery has been isolated in another
function, because every interface driver must implement it according
to the specific hardware being driven:</p>

<pre>int snull_tx(struct sk_buff *skb, struct net_device *dev)
{
    int len;
    char *data, shortpkt[ETH_ZLEN];
    struct snull_priv *priv = netdev_priv(dev);
    
    data = skb-&gt;data;
    len = skb-&gt;len;
    if (len &lt; ETH_ZLEN) {
        memset(shortpkt, 0, ETH_ZLEN);
        memcpy(shortpkt, skb-&gt;data, skb-&gt;len);
        len = ETH_ZLEN;
        data = shortpkt;
    }
    dev-&gt;trans_start = jiffies; /* save the timestamp */

    /* Remember the skb, so we can free it at interrupt time */
    priv-&gt;skb = skb;

    /* actual deliver of data is device-specific, and not shown here */
    snull_hw_tx(data, len, dev);

    return 0; /* Our simple device can not fail */
}</pre><br>


<p class="docText">The transmission function, thus, just performs some sanity checks on
the packet and transmits the data through the hardware-related
function. Do note, however, the care that is taken when the packet to
be transmitted is shorter than the minimum length supported by the
underlying media (which, for <span class="docEmphasis">snull</span>, is our
virtual "Ethernet"). Many Linux
network drivers (and those for other operating systems as well) have
been found to leak data in such situations. Rather than create that
sort of security vulnerability, we copy short packets into a separate
array that we can explicitly zero-pad out to the full length required
by the media. (We can safely put that data on the stack, since the
minimum length—60 bytes—is quite small).</p>

<p class="docText">The return value from <span class="docEmphasis">hard_start_xmit</span> should be
<tt>0</tt> on success; at that point, your driver has taken
responsibility for the packet, should make its best effort to ensure
that transmission succeeds, and must free the skb at the end. A
nonzero return value indicates that the packet could not be
transmitted at this time; the kernel will retry later. In this
situation, your driver should stop the queue until whatever situation
caused the failure has been resolved.</p>

<p class="docText">The "hardware-related" transmission
function (<span class="docEmphasis">snull_hw_tx</span>) is omitted here since it
is entirely occupied with implementing the trickery of the
<span class="docEmphasis">snull</span> device, including manipulating the source
and destination addresses, and has little of interest to authors of
real network drivers. It is present, of course, in the sample source
for those who want to go in and see how it works.</p>

<a name="chp-17-sect-5.1"></a>
<h4 class="docSection2Title">17.5.1. Controlling Transmission Concurrency</h4>

<p class="docText"><a name="chp-17-ITERM-7708"></a><a name="chp-17-ITERM-7709"></a><a name="chp-17-ITERM-7710"></a>The
<span class="docEmphasis">hard_start_xmit</span> function is
protected<a name="chp-17-ITERM-7711"></a>
<a name="chp-17-ITERM-7712"></a> from concurrent calls by a
spinlock (<tt>xmit_lock</tt>) in the
<tt>net_device</tt> structure. As soon as the function
returns, however, it may be called again. The function returns when
the software is done instructing the hardware about packet
transmission, but hardware transmission will likely not have been
completed. This is not an issue with <span class="docEmphasis">snull</span>,
which does all of its work using the CPU, so packet transmission is
complete before the transmission function returns.</p>

<p class="docText">Real hardware interfaces, on the other hand, transmit packets
asynchronously and have a limited amount of memory available to store
outgoing packets. When that memory is exhausted (which, for some
hardware, happens with a single outstanding packet to transmit), the
driver needs to tell the networking system not to start any more
transmissions until the hardware is ready to accept new data.</p>

<p class="docText"><a name="chp-17-ITERM-7713"></a>
<a name="chp-17-ITERM-7714"></a>
<a name="chp-17-ITERM-7715"></a><a name="chp-17-ITERM-7716"></a>
<a name="chp-17-ITERM-7717"></a>This
notification is accomplished by calling
<span class="docEmphasis">netif_stop_queue</span>, the function introduced
earlier to stop the queue. Once your driver has stopped its queue, it
<span class="docEmphasis">must</span> arrange to restart the queue at some point
in the future, when it is again able to accept packets for
transmission. To do so, it should call:</p>

<pre>void netif_wake_queue(struct net_device *dev);</pre><br>


<p class="docText">This function is just like <span class="docEmphasis">netif_start_queue</span>,
except that it also pokes the networking system to make it start
transmitting packets again.</P>

<p class="docText">Most modern network hardware maintains an internal queue with
multiple packets to transmit; in this way it can get the best
performance from the network. Network drivers for these devices must
support having multiple transmisions outstanding at any given time,
but device memory can fill up whether or not the hardware supports
multiple outstanding transmissions. Whenever device memory fills to
the point that there is no room for the largest possible packet, the
driver should stop the queue until space becomes available again.</p>

<p class="docText">If you must disable
packet<a name="chp-17-ITERM-7718"></a> transmission from anywhere
other than your <span class="docEmphasis">hard_start_xmit</span> function (in
response to a reconfiguration request, perhaps), the function you
want to use is:</P>

<pre>void netif_tx_disable(struct net_device *dev);</pre><BR>


<p class="docText">This function behaves much like
<span class="docEmphasis">netif_stop_queue</span>, but it also ensures that, when
it returns, your <span class="docEmphasis">hard_start_xmit</span> method is not
running on another CPU. The queue can be restarted with
<span class="docEmphasis">netif_wake_queue</span>, as usual.</p>


<a name="chp-17-sect-5.2"></a>
<h4 class="docSection2Title">17.5.2. Transmission Timeouts</h4>

<p class="docText"><a name="chp-17-ITERM-7719"></a><a name="chp-17-ITERM-7720"></a>Most drivers that deal with real hardware
have to be prepared for that hardware to fail to respond
occasionally. Interfaces can forget what they are doing, or the
system can lose an interrupt. This sort of problem is common with
some devices designed to run on personal computers.</P>

<p class="docText">Many drivers handle this problem by setting timers; if the operation
has not completed by the time the timer expires, something is wrong.
The network system, as it happens, is essentially a complicated
assembly of state machines controlled by a mass of timers. As such,
the networking code is in a good position to detect transmission
timeouts as part of its regular operation.</p>

<p class="docText"><a name="chp-17-ITERM-7721"></a>Thus, network drivers need not worry
about detecting such problems themselves. Instead, they need only set
a timeout period, which goes in the <tt>watchdog_timeo</tt>
field of the <tt>net_device</tt> structure. This period,
which is in jiffies, should be long enough to account for normal
transmission delays (such as collisions caused by congestion on the
network media).</P>

<p class="docText">If the current system time exceeds the device's
<tt>TRans_start</tt> time by at least the timeout period,
the networking layer eventually calls the driver's
<span class="docEmphasis">tx_timeout</span> method. That
method's job is to do whatever is needed to clear up
the problem and to ensure the proper completion of any transmissions
that were already in progress. It is important, in particular, that
the driver not lose track of any socket buffers that have been
entrusted to it by the networking code.</P>

<p class="docText"><span class="docEmphasis">snull</span> has the ability to simulate transmitter
lockups, which is controlled by two load-time parameters:</p>

<pre>static int lockup = 0;
module_param(lockup, int, 0);

static int timeout = SNULL_TIMEOUT;
module_param(timeout, int, 0);</pre><br>


<p class="docText">If the driver is loaded with the parameter
<tt>lockup=n</tt>, a lockup is simulated once every
<tt>n</tt> packets transmitted, and the
<tt>watchdog_timeo</tt> field is set to the given
<tt>timeout</tt> value. When simulating lockups,
<span class="docEmphasis">snull</span> also calls
<span class="docEmphasis">netif_stop_queue</span> to prevent other transmission
attempts from occurring.</p>

<p class="docText">The <span class="docEmphasis">snull</span> transmission timeout handler looks
like this:</p>

<pre>void snull_tx_timeout (struct net_device *dev)
{
    struct snull_priv *priv = netdev_priv(dev);

    PDEBUG("Transmit timeout at %ld, latency %ld\n", jiffies,
            jiffies - dev-&gt;trans_start);
        /* Simulate a transmission interrupt to get things moving */
    priv-&gt;status = SNULL_TX_INTR;
    snull_interrupt(0, dev, NULL);
    priv-&gt;stats.tx_errors++;
    netif_wake_queue(dev);
    return;
}</pre><BR>


<p class="docText">When a transmission timeout happens, the driver must mark the error
in the interface statistics and arrange for the device to be reset to
a sane state so that new packets can be transmitted. When a timeout
happens in <span class="docEmphasis">snull</span>, the driver calls
<span class="docEmphasis">snull_interrupt</span> to fill in the
"missing" interrupt and restarts
the <a name="chp-17-ITERM-7722"></a>
<a name="chp-17-ITERM-7723"></a>transmit
queue with <span class="docEmphasis">netif_wake_queue</span>.</P>


<a name="chp-17-sect-5.3"></a>
<H4 class="docSection2Title">17.5.3. Scatter/Gather I/O</h4>

<p class="docText">The process of
creating<a name="chp-17-ITERM-7724"></a>
<a name="chp-17-ITERM-7725"></a>
a packet for transmission on the network involves assembling multiple
pieces. Packet data must often be copied in from user space, and the
headers used by various levels of the network stack must be added as
well. This assembly can require a fair amount of data copying. If,
however, the network interface that is destined to transmit the
packet can perform scatter/gather I/O, the packet need not be
assembled into a single chunk, and much of that copying can be
avoided. Scatter/gather I/O also enables
"zero-copy" transmission of network
data directly from user-space buffers.</P>

<p class="docText">The kernel does not pass scattered packets to your
<span class="docEmphasis">hard_start_xmit</span> method unless the
<tt>NETIF_F_SG</tt> bit has been set in the
<tt>features</tt> field of your device structure. If you
have set that flag, you need to look at a special
"shared info" field within the skb
to see whether the packet is made up of a single fragment or many and
to find the scattered fragments if need be. A special macro exists to
access this information; it is called
<span class="docEmphasis">skb_shinfo</span>. The first step when transmitting
potentially fragmented packets usually looks something like this:</P>

<pre>if (skb_shinfo(skb)-&gt;nr_frags =  = 0) {
    /* Just use skb-&gt;data and skb-&gt;len as usual */
}</pre><br>


<p class="docText">The <tt>nr_frags</tt><a name="chp-17-ITERM-7726"></a> field tells how many fragments have been
used to build the packet. If it is <tt>0</tt>, the packet
exists in a single piece and can be accessed via the
<tt>data</tt> field as usual. If, however, it is nonzero,
your driver must pass through and arrange to transfer each individual
fragment. The <tt>data</tt> field of the skb structure
points conveniently to the first fragment (as compared to the full
packet, as in the unfragmented case). The length of the fragment must
be calculated by subtracting <tt>skb-&gt;data_len</tt> from
<tt>skb-&gt;len</tt> (which still contains the length of
the full packet). The remaining fragments are to be found in an array
called <tt>frags</tt> in the shared information structure;
each entry in <tt>frags</tt> is an
<tt>skb_frag_struct</tt> structure:</p>

<pre>struct skb_frag_struct {
    struct page *page;
    _ _u16 page_offset;
    _ _u16 size;
};</pre><br>


<p class="docText">As you can see, we are once again dealing with
<tt>page</tt> structures, rather than kernel virtual
addresses. Your driver should loop through the fragments, mapping
each for a DMA transfer and not forgetting the first fragment, which
is pointed to by the skb directly. Your hardware, of course, must
assemble the fragments and transmit them as a single packet. Note
that, if you have set the <tt>NETIF_F_HIGHDMA</tt> feature
flag, some or all of the fragments may be located in high memory.</p>



<UL></ul></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17-sect-6.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
