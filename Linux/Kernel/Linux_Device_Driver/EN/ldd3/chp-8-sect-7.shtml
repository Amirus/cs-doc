<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>8.7. Quick Reference</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-8-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-9.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-8-sect-7"></a>
<h3 class="docSection1Title">8.7. Quick Reference</h3>

<p class="docText">The functions and symbols related to memory allocation are:</p>

<a name="chp-8-ITERM-5806"></a><a name="chp-8-ITERM-5807"></a><a name="chp-8-ITERM-5808"></a><a name="chp-8-ITERM-5809"></a><a name="chp-8-ITERM-5810"></a><a name="chp-8-ITERM-5811"></a><a name="chp-8-ITERM-5812"></a><a name="chp-8-ITERM-5813"></a><a name="chp-8-ITERM-5814"></a><a name="chp-8-ITERM-5815"></a><a name="chp-8-ITERM-5816"></a><a name="chp-8-ITERM-5817"></a><a name="chp-8-ITERM-5818"></a><a name="chp-8-ITERM-5819"></a><a name="chp-8-ITERM-5820"></a><a name="chp-8-ITERM-5821"></a><a name="chp-8-ITERM-5822"></a><a name="chp-8-ITERM-5823"></a><a name="chp-8-ITERM-5824"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/slab.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *kmalloc(size_t size, int flags);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void kfree(void *obj);</span></span></span></dt></p>
<dd>
<p class="docList">The most frequently used interface to memory allocation.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/mm.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GFP_USER</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GFP_KERNEL</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GFP_NOFS</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GFP_NOIO</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GFP_ATOMIC</span></span></span></dt></P>
<dd>
<p class="docList">Flags that control
how<a name="chp-8-ITERM-5806"></a>
<a name="chp-8-ITERM-5807"></a>
<a name="chp-8-ITERM-5808"></a>
memory allocations are performed, from the least restrictive to the
most. The <tt>GFP_USER</tt> and
<tt>GFP_KERNEL</tt> priorities allow the current process to
be put to sleep to satisfy the request. <tt>GFP_NOFS</tt>
and <tt>GFP_NOIO</tt> disable filesystem operations and all
I/O operations, respectively, while <tt>GFP_ATOMIC</tt>
allocations cannot sleep at all.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _GFP_DMA</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _GFP_HIGHMEM</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _GFP_COLD</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _GFP_NOWARN</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _GFP_HIGH</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _GFP_REPEAT</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _GFP_NOFAIL</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _GFP_NORETRY</span></span></span></dt></P>
<dd>
<p class="docList">These flags modify the kernel's behavior when
allocating memory.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/malloc.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">kmem_cache_t *kmem_cache_create(char *name, size_t size, size_t offset</span></span>, </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">unsigned long flags, constructor(  ), destructor(  ));</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int kmem_cache_destroy(kmem_cache_t *cache);</span></span></span></dt></p>
<dd>
<p class="docList">Create and destroy a slab cache. The cache can be used to allocate
several objects of the same size.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SLAB_NO_REAP</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SLAB_HWCACHE_ALIGN</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SLAB_CACHE_DMA</span></span></span></dt></P>
<dd>
<p class="docList">Flags that can be specified while creating a cache.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SLAB_CTOR_ATOMIC</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SLAB_CTOR_CONSTRUCTOR</span></span></span></dt></p>
<dd>
<p class="docList">Flags that the allocator <a name="chp-8-ITERM-5809"></a>
<a name="chp-8-ITERM-5810"></a>
<a name="chp-8-ITERM-5811"></a>
<a name="chp-8-ITERM-5812"></a>can
pass to the constructor and the destructor functions.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *kmem_cache_alloc(kmem_cache_t *cache, int flags);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void kmem_cache_free(kmem_cache_t *cache, const void *obj);</span></span></span></dt></P>
<dd>
<p class="docList">Allocate and release a single object from the cache.</p>
</dd>
<dt><span class="docPubcolor"><i>/proc/slabinfo</i></span></dt></p>
<dd>
<p class="docList">A virtual file containing statistics on slab cache usage.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/mempool.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn, mempool_free_t</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">*free_fn, void *data);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void mempool_destroy(mempool_t *pool);</span></span></span></dt></p>
<dd>
<p class="docList">Functions for the creation
of<a name="chp-8-ITERM-5813"></a>
<a name="chp-8-ITERM-5814"></a>
memory pools, which try to avoid memory allocation failures by
keeping an "emergency list" of
allocated items.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *mempool_alloc(mempool_t *pool, int gfp_mask);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void mempool_free(void *element, mempool_t *pool);</span></span></span></dt></P>
<dd>
<p class="docList">Functions for allocating items from (and returning them to) memory
pools.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long get_zeroed_page(int flags);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long _ _get_free_page(int flags);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long _ _get_free_pages(int flags, unsigned long order);</span></span></span></dt></p>
<dd>
<p class="docList">The page-oriented allocation functions.
<span class="docEmphasis">get_zeroed_page</span> returns a single, zero-filled
page. All the other versions of the call do not initialize the
contents of the returned page(s).</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int get_order(unsigned long size);</span></span></span></dt></p>
<dd>
<p class="docList">Returns the allocation order<a name="chp-8-ITERM-5815"></a>
<a name="chp-8-ITERM-5816"></a>
<a name="chp-8-ITERM-5817"></a> associated to
<span class="docEmphasis">size</span> in the current platform, according to
<tt>PAGE_SIZE</tt>. The argument must be a power of two,
and the return value is at least <tt>0</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void free_page(unsigned long addr);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void free_pages(unsigned long addr, unsigned long order);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that release page-oriented allocations.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page *alloc_pages_node(int nid, unsigned int flags, unsigned int</span></span> <span class="docPubcolor"><span class="docMonofont">order);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page *alloc_pages(unsigned int flags, unsigned int order);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page *alloc_page(unsigned int flags);</span></span></span></dt></P>
<dd>
<p class="docList">All variants of the lowest-level page allocator in the Linux kernel.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void _ _free_page(struct page *page);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void _ _free_pages(struct page *page, unsigned int order);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void free_hot_page(struct page *page);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void free_cold_page(struct page *page);</span></span></span></dt></p>
<dd>
<p class="docList">Various ways of freeing pages allocated with one of the forms of
<span class="docEmphasis">alloc_page</span>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/vmalloc.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void * vmalloc(unsigned long size);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void vfree(void * addr);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/io.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void * ioremap(unsigned long offset, unsigned long size);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void iounmap(void *addr);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that allocate or free a contiguous
<span class="docEmphasis">virtual</span> address space.
<span class="docEmphasis">ioremap</span> accesses physical memory through virtual
addresses, while <span class="docEmphasis">vmalloc</span> allocates free pages.
Regions mapped with <span class="docEmphasis">ioremap</span> are freed
<a name="chp-8-ITERM-5818"></a>
<a name="chp-8-ITERM-5819"></a>with <span class="docEmphasis">iounmap</span>,
while pages obtained from <span class="docEmphasis">vmalloc</span> are released
with <span class="docEmphasis">vfree</span>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/percpu.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DEFINE_PER_CPU(type, name);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DECLARE_PER_CPU(type, name);</span></span></span></dt></P>
<dd>
<p class="docList">Macros that define and declare per-CPU variables.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">per_cpu(variable, int cpu_id)</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">get_cpu_var(variable)</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">put_cpu_var(variable)</span></span></span></dt></p>
<dd>
<p class="docList">Macros that provide access to statically declared per-CPU variables.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *alloc_percpu(type);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *_ _alloc_percpu(size_t size, size_t align);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void free_percpu(void *variable);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that perform runtime allocation and freeing of per-CPU
variables.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int get_cpu(  );</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void put_cpu(  );</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">per_cpu_ptr(void *variable, int cpu_id)</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">get_cpu</span> obtains a reference to the current
processor (therefore, preventing preemption and movement to another
processor) and returns the ID number of the processor;
<span class="docEmphasis">put_cpu</span> returns that reference. To access a
dynamically allocated per-CPU variable, use
<span class="docEmphasis">per_cpu_ptr</span> with the ID of the CPU whose version
should be accessed. Manipulations of the current
CPU's version of a dynamic, per-CPU variable should
probably be surrounded by calls to <span class="docEmphasis">get_cpu</span> and
<span class="docEmphasis">put_cpu</span>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/bootmem.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *alloc_bootmem(unsigned long size);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *alloc_bootmem_low(unsigned long size);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *alloc_bootmem_pages(unsigned long size);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *alloc_bootmem_low_pages(unsigned long size);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void free_bootmem(unsigned long addr, unsigned long size);</span></span></span></dt></p>
<dd>
<p class="docList">Functions (which can be used only by drivers directly linked into the
kernel) that perform allocation and freeing of memory at
<a name="chp-8-ITERM-5820"></a>
<a name="chp-8-ITERM-5821"></a>
<a name="chp-8-ITERM-5822"></a>
<a name="chp-8-ITERM-5823"></a>
<a name="chp-8-ITERM-5824"></a>system bootstrap time.</p>
</dd>
</dl>


<ul></UL></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-8-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-9.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
