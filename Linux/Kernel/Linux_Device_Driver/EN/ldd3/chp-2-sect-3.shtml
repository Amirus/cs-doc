<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>2.3. Kernel Modules Versus Applications</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-2-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-2-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-2-sect-3"></a>
<h3 class="docSection1Title">2.3. Kernel Modules Versus Applications</H3>

<p class="docText">Before we go further, it's worth<a name="chp-2-ITERM-4117"></a> <a name="chp-2-ITERM-4118"></a> <a name="chp-2-ITERM-4119"></a>
underlining the<a name="chp-2-ITERM-4120"></a>
various differences between a kernel module and an application.</p>

<p class="docText"><a name="chp-2-ITERM-4121"></a><a name="chp-2-ITERM-4122"></a>
<a name="chp-2-ITERM-4123"></a>While
most small and medium-sized applications perform a single task from
beginning to end, every kernel module just registers itself in order
to serve future requests, and its initialization function terminates
immediately. In other words, the task of the
module's initialization function is to prepare for
later invocation of the module's functions;
it's as though the module were saying,
"Here I am, and this is what I can
do." The module's exit function
(<span class="docEmphasis">hello_exit</span> in the example) gets invoked just
before the module is unloaded. It should tell the kernel,
"I'm not there anymore;
don't ask me to do anything else."
This kind of approach to programming is similar to event-driven
programming, but while not all applications are event-driven, each
and every kernel module is. Another major difference between
event-driven applications and kernel code is in the exit function:
whereas an application that terminates can be lazy in releasing
resources or avoids clean up altogether, the exit function of a
module must carefully undo everything the <span class="docEmphasis">init</span>
function built up, or the pieces remain around until the system is
rebooted.</p>

<p class="docText">Incidentally, the ability to unload a module is one of the features
of modularization that you'll most appreciate,
because it helps cut down development time; you can test successive
versions of your new driver without going through the lengthy
shutdown/reboot cycle each time.</P>

<p class="docText"><a name="chp-2-ITERM-4124"></a>As a programmer, you know
that an application can call functions it doesn't
define: the linking stage resolves external references using the
appropriate library of functions. <span class="docEmphasis">printf</span> is one
of those callable functions and is defined in
<span class="docEmphasis">libc</span>. A module, on the other hand, is linked
only to the kernel, and <a name="chp-2-ITERM-4125"></a>the only functions it can call are the
ones exported by the kernel; there are no libraries to link to. The
<span class="docEmphasis">printk</span> function used in
<i>hello.c</I> earlier, for example, is the version of
<span class="docEmphasis">printf</span> defined within the kernel and exported to
modules. It behaves similarly to the original function, with a few
minor differences, the main one being lack of floating-point support.</p>

<p class="docText"><a class="docLink" href="chp-2-sect-3.shtml#chp-2-FIG-1">Figure 2-1</a> shows how
function calls and function pointers are used in a module to add new
functionality to a running kernel.</p>

<a name="chp-2-FIG-1"></a><p><center>
<h5 class="docFigureTitle">Figure 2-1. Linking a module to the kernel</h5>
<img border="0" alt="" width="416" height="257" SRC="images/0596005903/figs/ldr3_0201.gif"></center></p><br>

<p class="docText"><a name="chp-2-ITERM-4126"></a><a name="chp-2-ITERM-4127"></a><a name="chp-2-ITERM-4128"></a><a name="chp-2-ITERM-4129"></a><a name="chp-2-ITERM-4130"></a><a name="chp-2-ITERM-4131"></a>Because no library is linked to
modules, source files should never include the usual header files,
<i>&lt;stdarg.h&gt;</i> and very special situations
being the only exceptions. Only functions that are actually part of
the kernel itself may be used in kernel modules. Anything related to
the kernel is declared in headers found in the kernel source tree you
have set up and configured; most of the relevant headers live in
<i>include/linux</i> and
<i>include/asm</i>, but other subdirectories of
<I>include </i>have been added to host material
associated to specific kernel subsystems.</P>

<p class="docText">The role of individual kernel headers is introduced throughout the
book as each of them is needed.</P>

<p class="docText"><a name="chp-2-ITERM-4132"></a>Another
important difference between kernel programming and application
programming is in how each environment handles
<a name="chp-2-ITERM-4133"></a>faults: whereas a
segmentation fault is harmless during application development and a
debugger can always be used to trace the error to the problem in the
source code, a kernel fault kills the current process at least, if
not the whole system. We see how to trace kernel errors in <a class="docLink" href="chp-4.shtml#chp-4">Chapter 4</a>.</p>

<a name="chp-2-sect-3.1"></a>
<a name="chp-2-ITERM-4134"></a><h4 class="docSection2Title">2.3.1. User Space and Kernel Space</h4>

<p class="docText"><a name="chp-2-ITERM-4135"></a><a name="chp-2-ITERM-4136"></a>A module runs in <span class="docEmphasis">kernel
space</span>, whereas
applications<a name="chp-2-ITERM-4137"></a>
<a name="chp-2-ITERM-4138"></a>
<a name="chp-2-ITERM-4139"></a> run in <span class="docEmphasis">user
space</span>. This concept is at the base of operating systems
theory.</P>

<p class="docText">The role of the operating system, in practice, is to provide programs
with a consistent view of the computer's hardware.
In addition, the operating system must account for independent
operation of programs and protection against unauthorized access to
resources. This nontrivial task is possible only if the CPU enforces
protection of system software from the applications.</p>

<p class="docText"><a name="chp-2-ITERM-4140"></a><a name="chp-2-ITERM-4141"></a><a name="chp-2-ITERM-4142"></a><a name="chp-2-ITERM-4143"></a><a name="chp-2-ITERM-4144"></a>Every modern processor is able to enforce
this behavior. The chosen approach is to implement different
operating modalities (or levels) in the CPU itself. The levels have
different roles, and some operations are disallowed at the lower
levels; program code can switch from one level to another only
through a limited number of gates. Unix systems are designed to take
advantage of this hardware feature, using two such levels. All
current processors have at least two protection levels, and some,
like the x86 family, have more levels; when several levels exist, the
highest and lowest levels are used. Under Unix, the kernel executes
in the highest level (also called <span class="docEmphasis">supervisor
mode</span><a name="chp-2-ITERM-4145"></a>), where everything is allowed, whereas
applications execute in the lowest level (the so-called
<span class="docEmphasis">user mode</span><a name="chp-2-ITERM-4146"></a>), where the processor regulates direct
access to hardware and unauthorized access to memory.</P>

<p class="docText"><a name="chp-2-ITERM-4147"></a>We
usually refer to the
<a name="chp-2-ITERM-4148"></a>execution
modes as <span class="docEmphasis">kernel space</span> and <span class="docEmphasis">user
space</span>. These terms encompass not only the different
privilege levels inherent in the two modes, but also the fact that
each mode can have its own memory mapping—its own address
space—as well.</P>

<p class="docText">Unix transfers execution from user space to kernel space whenever an
application issues a system call or is suspended by a hardware
interrupt. Kernel code executing a system call is working in the
context of a process—it operates on behalf of the calling
process and is able to access data in the process's
address space. Code that handles interrupts, on the other hand, is
asynchronous with respect to processes and is not related to any
particular process.</P>

<p class="docText">The role of a module is to extend kernel functionality; modularized
code runs in kernel space. Usually a driver performs both the tasks
outlined previously: some functions in the module are executed as
part of system calls, and some are in charge of interrupt handling.</p>


<a name="chp-2-sect-3.2"></a>
<h4 class="docSection2Title">2.3.2. Concurrency in the Kernel</h4>

<p class="docText"><a name="chp-2-ITERM-4149"></a>One
way in which kernel
<a name="chp-2-ITERM-4150"></a>
<a name="chp-2-ITERM-4151"></a>
<a name="chp-2-ITERM-4152"></a>programming
differs greatly from conventional application programming is the
issue of concurrency. Most applications, with the notable exception
of multithreading applications, typically run sequentially, from the
beginning to the end, without any need to worry about what else might
be happening to change their environment. Kernel code does not run in
such a simple world, and even the simplest kernel modules must be
written with the idea that many things can be happening at once.</p>

<p class="docText">There are a few sources of concurrency in kernel programming.
Naturally, Linux systems run multiple processes, more than one of
which can be trying to use your driver at the same time. Most devices
are capable of interrupting the processor; interrupt handlers run
asynchronously and can be invoked at the same time that your driver
is trying to do something else. Several software abstractions (such
as kernel timers, introduced in <a class="docLink" href="chp-7.shtml#chp-7">Chapter 7</a>) run asynchronously as
well. Moreover, of course, Linux can run on
<a name="chp-2-ITERM-4153"></a> <a name="chp-2-ITERM-4154"></a>symmetric multiprocessor
(SMP) systems, with the result that your driver could be executing
concurrently on more than one CPU. Finally, in 2.6, kernel code has
been made preemptible; this change causes even
<a name="chp-2-ITERM-4155"></a>uniprocessor systems to have many of the same
concurrency issues as multiprocessor systems.</P>

<p class="docText"><a name="chp-2-ITERM-4156"></a>As a result,
Linux kernel code, including driver code, must be
<I>reentrant</I><a name="chp-2-ITERM-4157"></a>—it
must be capable of running in more than one context at the same time.
Data structures must be carefully designed to keep multiple threads
of execution separate, and the code must take care to access shared
data in ways that prevent corruption of the data. Writing code that
handles concurrency and avoids race conditions (situations in which
an unfortunate order of execution causes undesirable behavior)
requires thought and can be tricky. Proper management of concurrency
is required to write correct kernel code; for that reason, every
sample driver in this book has been written with concurrency in mind.
The techniques used are explained as we come to them; <a class="docLink" href="chp-5.shtml#chp-5">Chapter 5</a> has also been dedicated to
this issue and the kernel primitives available for concurrency
management.</p>

<p class="docText"><a name="chp-2-ITERM-4158"></a><a name="chp-2-ITERM-4159"></a>A common mistake made by driver
programmers is to assume that concurrency is not a problem as long as
a particular segment of code does not go to sleep (or
"block"). Even in previous kernels
(which were not preemptive), this assumption was not valid on
multiprocessor systems. In 2.6, kernel code can (almost) never assume
that it can hold the processor over a given stretch of code. If you
do not write your code with concurrency in mind, it will be subject
to catastrophic
<a name="chp-2-ITERM-4160"></a>
<a name="chp-2-ITERM-4161"></a>failures
that can be exceedingly difficult to debug.</P>


<a name="chp-2-sect-3.3"></a>
<H4 class="docSection2Title">2.3.3. The Current Process</h4>

<p class="docText"><a name="chp-2-ITERM-4162"></a><a name="chp-2-ITERM-4163"></a><a name="chp-2-ITERM-4164"></a><a name="chp-2-ITERM-4165"></a>Although kernel modules
<a name="chp-2-ITERM-4166"></a>
<a name="chp-2-ITERM-4167"></a>
<a name="chp-2-ITERM-4168"></a>don't
execute sequentially as applications do, most actions performed by
the kernel are done on behalf of a specific process. Kernel code can
refer to the current process by accessing the global item
<tt>current</tt>, defined in
<i>&lt;asm/current.h&gt;</i>, which yields a pointer to
<tt>struct</tt> <tt>task_struct</tt>, defined by
<i>&lt;linux/sched.h&gt;</I>. The
<tt>current</tt> pointer refers to the process that is
currently executing. During the execution of a system call, such as
<span class="docEmphasis">open</span> or <span class="docEmphasis">read</span>, the current
process is the one that invoked the call. Kernel code can use
process-specific information by using <tt>current</tt>, if
it needs to do so. An example of this technique is presented in <a class="docLink" href="chp-6.shtml#chp-6">Chapter 6</a>.</p>

<p class="docText">Actually, <tt>current</tt> is not truly a global variable.
The need to support SMP systems forced the kernel developers to
develop a mechanism that finds the current process on the relevant
CPU. This mechanism must also be fast, since references to
<tt>current</tt> happen frequently. The result is an
architecture-dependent mechanism that, usually, hides a pointer to
the <tt>task_struct</tt> structure on the kernel stack. The
details of the implementation remain hidden to other kernel
subsystems though, and a device driver can just include
<i>&lt;linux/sched.h&gt;</I> and refer to the
<tt>current</tt> process. For example, the following
statement prints the process ID and the command name of the current
process by accessing certain fields in <tt>struct
task_struct</tt>:</p>

<pre>printk(KERN_INFO "The process is \"%s\" (pid %i)\n",
        current-&gt;comm, current-&gt;pid);</pre><br>


<p class="docText">The command name stored in <tt>current-&gt;comm</tt> is the
base name of the program file (trimmed to 15 characters if need be)
that is being executed by the current process.</P>


<a name="chp-2-sect-3.4"></a>
<h4 class="docSection2Title">2.3.4. A Few Other Details</H4>

<p class="docText">Kernel programming differs from user-space programming in many ways.
We'll point things out as we get to them over the
course of the book, but there are a few fundamental issues which,
while not warranting a section of their own, are worth a mention. So,
as you dig into the kernel, the following issues should be kept in
mind.</p>

<p class="docText">Applications are laid out in virtual memory with a very large stack
area. The stack, of course, is used to hold the function call history
and all automatic variables created by currently active functions.
The kernel, instead, has a very small stack; it can be as small as a
single, 4096-byte page. Your functions must share that stack with the
entire kernel-space call chain. Thus, it is never a good idea to
declare large automatic variables; if you need larger structures, you
should allocate them dynamically at call time.</p>

<p class="docText">Often, as you look at the kernel API, you will encounter function
names starting with a double <a name="chp-2-ITERM-4169"></a>
<a name="chp-2-ITERM-4170"></a>underscore (<tt>_ _</tt>).
Functions so marked are generally a low-level component of the
interface and should be used with caution. Essentially, the double
underscore says to the programmer: "If you call this
function, be sure you know what you are doing."</p>

<p class="docText">Kernel code cannot do floating point arithmetic. Enabling floating
point would require that the kernel save and restore the floating
point processor's state on each entry to, and exit
from, kernel space—at least, on some architectures. Given that
there really is no need for floating point in kernel<a name="chp-2-ITERM-4171"></a> <a name="chp-2-ITERM-4172"></a> code, the extra
overhead is not worthwhile.</p>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-2-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-2-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
