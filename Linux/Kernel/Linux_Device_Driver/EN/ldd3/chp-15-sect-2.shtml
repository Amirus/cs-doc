<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>15.2. The mmap Device Operation</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-15-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-15-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-15-sect-2"></a>
<h3 class="docSection1Title">15.2. The mmap Device Operation</h3>

<p class="docText">Memory mapping is one of the <a name="chp-15-ITERM-7053"></a> <a name="chp-15-ITERM-7054"></a> <a name="chp-15-ITERM-7055"></a> <a name="chp-15-ITERM-7056"></a> <a name="chp-15-ITERM-7057"></a> <a name="chp-15-ITERM-7058"></a>most interesting features of modern
Unix systems. As far as drivers are concerned, memory mapping can be
implemented to provide user programs with direct access to device
memory.</p>

<p class="docText">A definitive example of <span class="docEmphasis">mmap</span> usage can be seen
by looking at a subset of the virtual memory areas for the X Window
System server:</p>

<pre><b>cat /proc/731/maps</b>
000a0000-000c0000 rwxs 000a0000 03:01 282652      /dev/mem
000f0000-00100000 r-xs 000f0000 03:01 282652      /dev/mem
00400000-005c0000 r-xp 00000000 03:01 1366927     /usr/X11R6/bin/Xorg
006bf000-006f7000 rw-p 001bf000 03:01 1366927     /usr/X11R6/bin/Xorg
2a95828000-2a958a8000 rw-s fcc00000 03:01 282652  /dev/mem
2a958a8000-2a9d8a8000 rw-s e8000000 03:01 282652  /dev/mem
...</pre><br>


<p class="docText">The full list of the X server's VMAs is lengthy, but
most of the entries are not of interest here. We do see, however,
four separate mappings of <i>/dev/mem</i>, which give
some insight into how the X server works with the video card. The
first mapping is at <tt>a0000</tt>, which is the standard
location for video RAM in the 640-KB ISA hole. Further down, we see a
large mapping at <tt>e8000000</tt>, an address which is
above the highest RAM address on the system. This is a direct mapping
of the <a name="chp-15-ITERM-7059"></a>
<a name="chp-15-ITERM-7060"></a>video memory on the adapter.</p>

<p class="docText">These regions can also be seen in <i>/proc/iomem</i>:</p>

<pre>000a0000-000bffff : Video RAM area
000c0000-000ccfff : Video ROM
000d1000-000d1fff : Adapter ROM
000f0000-000fffff : System ROM
d7f00000-f7efffff : PCI Bus #01
  e8000000-efffffff : 0000:01:00.0
fc700000-fccfffff : PCI Bus #01
  fcc00000-fcc0ffff : 0000:01:00.0</pre><BR>


<p class="docText">Mapping a device means associating a range of user-space addresses to
device memory. Whenever the program reads or writes in the assigned
address range, it is actually accessing the device. In the X server
example, using <span class="docEmphasis">mmap</span> allows quick and easy access
to the video card's memory. For a
performance-critical application like this, direct access makes a
large difference.</p>

<p class="docText"><a name="chp-15-ITERM-7061"></a>
<a name="chp-15-ITERM-7062"></a>As
you might suspect, not every device lends itself to the
<span class="docEmphasis">mmap</span> abstraction; it makes no sense, for
instance, for serial ports and other stream-oriented devices. Another
limitation of <span class="docEmphasis">mmap</span> is that mapping is
<tt>PAGE_SIZE</tt> grained. The kernel can manage virtual
addresses only at the level of page tables; therefore, the mapped
area must be a multiple of <tt>PAGE_SIZE</tt> and must live
in physical memory starting at an address that is a multiple of
<tt>PAGE_SIZE</tt>. The kernel forces size granularity by
making a region slightly bigger if its size isn't a
multiple of the page size.</P>

<p class="docText">These limits are not a big constraint for drivers, because the
program accessing the device is device dependent anyway. Since the
program must know about how the device works, the programmer is not
unduly bothered by the need to see to details like page alignment. A
bigger constraint exists when ISA devices are used on some non-x86
platforms, because their hardware view of ISA may not be contiguous.
For example, some Alpha computers see ISA memory as a scattered set
of 8-bit, 16-bit, or 32-bit items, with no direct mapping. In such
cases, you can't use <span class="docEmphasis">mmap</span> at
all. The inability to perform direct mapping of ISA addresses to
Alpha addresses is due to the incompatible data transfer
specifications of the two systems. Whereas early Alpha processors
could issue only 32-bit and 64-bit memory accesses, ISA can do only
8-bit and 16-bit transfers, and there's no way to
transparently map one protocol onto the other.</P>

<p class="docText"><a name="chp-15-ITERM-7063"></a>There are sound advantages to using
<span class="docEmphasis">mmap</span> when it's feasible to do
so. For instance, we have already looked at the X server, which
transfers a lot of data to and from video memory; mapping the graphic
display to user space dramatically improves the throughput, as
opposed to an <span class="docEmphasis">lseek</span>/<span class="docEmphasis">write</span>
implementation. Another typical example is a program controlling a
PCI device. Most PCI peripherals map their control registers to a
memory address, and a high-performance application might prefer to
have direct access to the registers instead of repeatedly having to
call <span class="docEmphasis">ioctl</span> to get its work done.</p>

<p class="docText"><a name="chp-15-ITERM-7064"></a>
<a name="chp-15-ITERM-7065"></a>The
<span class="docEmphasis">mmap</span> method is part of the
<tt>file_operations</tt> structure and is invoked when the
<span class="docEmphasis">mmap</span> system call is issued. With
<span class="docEmphasis">mmap</span>, the kernel performs a good deal of work
before the actual method is invoked, and, therefore, the prototype of
the method is quite different from that of the system call. This is
unlike calls such as <span class="docEmphasis">ioctl</span> and
<span class="docEmphasis">poll</span>, where the kernel does not do much before
calling the method.</p>

<p class="docText">The system call is declared as follows (as described in the
<span class="docEmphasis">mmap(2)</span> manual page):</p>

<pre>mmap (caddr_t addr, size_t len, int prot, int flags, int fd, off_t offset)</pre><BR>


<p class="docText">On the other hand, the file operation is declared as:</p>

<pre>int (*mmap) (struct file *filp, struct vm_area_struct *vma);</pre><BR>


<p class="docText">The <tt>filp</tt> argument in the method is the same as
that introduced in <a class="docLink" href="chp-3.shtml#chp-3">Chapter 3</a>,
while <tt>vma</tt> contains the information about the
virtual address range that is used to access the device. Therefore,
much of the work has been done by the kernel; to implement
<span class="docEmphasis">mmap</span>, the driver only has to build suitable page
tables for the address range and, if necessary, replace
<tt>vma-&gt;vm_ops</tt> with a new set of operations.</P>

<p class="docText">There are two ways of building the page tables: doing it all at once
with a function called <tt>remap_pfn_range</tt> or doing it
a page at a time via the <span class="docEmphasis">nopage</span> VMA method. Each
method has its advantages and limitations. We start with the
"all at once" approach, which is
simpler. From there, we add the complications needed for a real-world
implementation.</P>

<a name="chp-15-sect-2.1"></a>
<h4 class="docSection2Title">15.2.1. Using remap_pfn_range</h4>

<p class="docText">The job of building new page <a name="chp-15-ITERM-7066"></a>
<a name="chp-15-ITERM-7067"></a>tables
to map a range of physical addresses is handled by
<span class="docEmphasis">remap_pfn_range</span> and
<span class="docEmphasis">io_remap_page_range</span>, which have the following
prototypes:</p>

<pre>int remap_pfn_range(struct vm_area_struct *vma, 
                     unsigned long virt_addr, unsigned long pfn,
                     unsigned long size, pgprot_t prot);
int io_remap_page_range(struct vm_area_struct *vma, 
                        unsigned long virt_addr, unsigned long phys_addr,
                        unsigned long size, pgprot_t prot);</pre><br>


<p class="docText">The value returned by the function is the usual <tt>0</tt>
or a negative error code. Let's look at the exact
meaning of the function's arguments:</P>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">vma</span></span></span></dt></p>
<dd>
<p class="docList">The virtual memory area into which the page range is being mapped.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">virt_addr</span></span></span></dt></p>
<dd>
<p class="docList">The user virtual address where remapping should begin. The function
builds page tables for the virtual address range between
<tt>virt_addr</tt> and <tt>virt_addr+size</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">pfn</span></span></span></dt></p>
<dd>
<p class="docList">The page frame number corresponding to the physical address to which
the virtual address should be mapped. The page frame number is simply
the physical address right-shifted by <tt>PAGE_SHIFT</tt>
bits. For most uses, the <tt>vm_pgoff</tt> field of the VMA
structure contains exactly the value you need. The function affects
physical addresses from <tt>(pfn&lt;&lt;PAGE_SHIFT)</tt> to
<tt>(pfn&lt;&lt;PAGE_SHIFT)+size</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">size</span></span></span></dt></p>
<dd>
<p class="docList">The dimension, in bytes, of the area being remapped.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">prot</span></span></span></dt></p>
<dd>
<p class="docList">The "protection" requested for the
new VMA. The driver can (and should) use the value found in
<tt>vma-&gt;vm_page_prot</tt>.</p>
</dd>
</dl>

<p class="docText"><a name="chp-15-ITERM-7068"></a>
<a name="chp-15-ITERM-7069"></a><a name="chp-15-ITERM-7070"></a>The arguments to
<span class="docEmphasis">remap_pfn_range</span> are fairly straightforward, and
most of them are already provided to you in the VMA when your
<span class="docEmphasis">mmap</span> method is called. You may be wondering why
there are two functions, however. The first
(<span class="docEmphasis">remap_pfn_range</span>) is intended for situations
where <tt>pfn</tt> refers to actual system RAM, while
<span class="docEmphasis">io_remap_page_range</span> should be used when
<tt>phys_addr</tt> points to I/O memory. In practice, the
two functions are identical on every architecture except the SPARC,
and you see <span class="docEmphasis">remap_pfn_range</span> used in most
situations. In the interest of writing portable drivers, however, you
should use the variant of <span class="docEmphasis">remap_pfn_range</span> that
is suited to your particular situation.</p>

<p class="docText">One other complication has to do with caching: usually, references to
device memory should not be cached by the processor. Often the system
BIOS sets things up properly, but it is also possible to disable
caching of specific VMAs via the protection field. Unfortunately,
disabling caching at this level is highly processor dependent. The
curious reader may wish to look at the
<span class="docEmphasis">pgprot_noncached</span> function from
<i>drivers/char/mem.c</i> to see
what's involved. We won't discuss
the topic further here.</p>


<a name="chp-15-sect-2.2"></a>
<h4 class="docSection2Title">15.2.2. A Simple Implementation</h4>

<p class="docText">If your driver needs to do a simple, linear mapping of device memory
into a user address space, <span class="docEmphasis">remap_pfn_range</span> is
almost all you really need to do the job. The following code is
derived from <i>drivers/char/mem.c</i> and shows how
this task is performed in a typical module called
<span class="docEmphasis">simple</span> (Simple Implementation Mapping Pages with
Little Enthusiasm):</p>

<pre>static int simple_remap_mmap(struct file *filp, struct vm_area_struct *vma)
{
    if (remap_pfn_range(vma, vma-&gt;vm_start, vm-&gt;vm_pgoff,
                vma-&gt;vm_end - vma-&gt;vm_start,
                vma-&gt;vm_page_prot))
        return -EAGAIN;

    vma-&gt;vm_ops = &amp;simple_remap_vm_ops;
    simple_vma_open(vma);
    return 0;
}</pre><br>


<p class="docText">As you can see, remapping memory just a matter of calling
<span class="docEmphasis">remap_pfn_range</span> to create the necessary page
tables.</p>


<a name="chp-15-sect-2.3"></a>
<H4 class="docSection2Title">15.2.3. Adding VMA Operations</h4>

<p class="docText"><a name="chp-15-ITERM-7071"></a><a name="chp-15-ITERM-7072"></a>As
we have seen, the <tt>vm_area_struct</tt> structure
contains a set of operations that may be applied to the VMA.
<a name="chp-15-ITERM-7073"></a>
<a name="chp-15-ITERM-7074"></a>
<a name="chp-15-ITERM-7075"></a>Now we look at providing those
operations in a simple way. In particular, we provide
<span class="docEmphasis">open</span> and <span class="docEmphasis">close</span> operations
for our VMA. These operations are called whenever a process opens or
closes the VMA; in particular, the <span class="docEmphasis">open</span> method
is invoked anytime a process forks and creates a new reference to the
VMA. The <span class="docEmphasis">open</span> and <span class="docEmphasis">close</span> VMA
methods are called in addition to the processing performed by the
kernel, so they need not reimplement any of the work done there. They
exist as a way for drivers to do any additional processing that they
may require.</P>

<p class="docText">As it turns out, a simple driver such as <span class="docEmphasis">simple</span>
need not do any extra processing in particular. So we have created
<span class="docEmphasis">open</span> and <span class="docEmphasis">close</span> methods,
which print a message to the system log informing the world that they
have been called. Not particularly useful, but it does allow us to
show how these methods can be provided, and see when they are
invoked.</P>

<p class="docText">To this end, we override the default
<tt>vma-&gt;vm_ops</tt> with operations that call
<span class="docEmphasis">printk</span>:</p>

<pre>void simple_vma_open(struct vm_area_struct *vma)
{
    printk(KERN_NOTICE "Simple VMA open, virt %lx, phys %lx\n",
            vma-&gt;vm_start, vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);
}

void simple_vma_close(struct vm_area_struct *vma)
{
    printk(KERN_NOTICE "Simple VMA close.\n");
}

static struct vm_operations_struct simple_remap_vm_ops = {
    .open =  simple_vma_open,
    .close = simple_vma_close,
};</pre><br>


<p class="docText">To make these operations active for a specific mapping, it is
necessary to store a pointer to
<tt>simple_remap_vm_ops</tt> in the
<tt>vm_ops</tt> field of the relevant VMA. This is usually
done in the <span class="docEmphasis">mmap</span> method. If you turn back to the
<span class="docEmphasis">simple_remap_mmap</span> example, you see these lines
of code:</p>

<pre>vma-&gt;vm_ops = &amp;simple_remap_vm_ops;
simple_vma_open(vma);</pre><BR>


<p class="docText">Note the explicit call to <span class="docEmphasis">simple_vma_open</span>. Since
the <span class="docEmphasis">open</span> method is not invoked on the initial
<span class="docEmphasis">mmap</span>, we must call it explicitly if we want it
to run.</p>


<a name="chp-15-sect-2.4"></a>
<H4 class="docSection2Title">15.2.4. Mapping Memory with nopage</H4>

<p class="docText">Although <span class="docEmphasis">remap_pfn_range</span> works
<a name="chp-15-ITERM-7076"></a>
<a name="chp-15-ITERM-7077"></a>well for many, if not most, driver
<span class="docEmphasis">mmap</span> implementations, sometimes it is necessary
to be a little more flexible. In such situations, an implementation
using the <span class="docEmphasis">nopage</span> VMA method may be called for.</P>

<p class="docText"><a name="chp-15-ITERM-7078"></a><a name="chp-15-ITERM-7079"></a>One situation in which the
<span class="docEmphasis">nopage</span> approach is useful can be brought about
by the <span class="docEmphasis">mremap</span> system call, which is used by
applications to change the bounding addresses of a mapped region. As
it happens, the kernel does not notify drivers directly when a mapped
VMA is changed by <span class="docEmphasis">mremap</span>. If the VMA is reduced
in size, the kernel can quietly flush out the unwanted pages without
telling the driver. If, instead, the VMA is expanded, the driver
eventually finds out by way of calls to <span class="docEmphasis">nopage</span>
when mappings must be set up for the new pages, so there is no need
to perform a separate notification. The <span class="docEmphasis">nopage</span>
method, therefore, must be implemented if you want to support the
<span class="docEmphasis">mremap</span> system call. Here, we show a simple
implementation of <span class="docEmphasis">nopage</span> for the
<span class="docEmphasis">simple</span> device.</p>

<p class="docText">The <span class="docEmphasis">nopage</span><a name="chp-15-ITERM-7080"></a>
<a name="chp-15-ITERM-7081"></a>
method, remember, has the following prototype:</p>

<pre>struct page *(*nopage)(struct vm_area_struct *vma, 
                       unsigned long address, int *type);</pre><br>


<p class="docText"><a name="chp-15-ITERM-7082"></a>
<a name="chp-15-ITERM-7083"></a>When
a user process attempts to access a page in a VMA that is not present
in memory, the associated <span class="docEmphasis">nopage</span> function is
called. The <tt>address</tt> parameter contains the virtual
address that caused the fault, rounded down to the beginning of the
page. The <span class="docEmphasis">nopage</span> function must locate and return
the <tt>struct page</tt> pointer that refers to the page
the user wanted. This function must also take care to increment the
usage count for the page it returns by calling the
<span class="docEmphasis">get_page</span> macro:</p>

<pre> get_page(struct page *pageptr);</pre><BR>


<p class="docText">This step is necessary to keep the reference counts correct on the
mapped pages. The kernel maintains this count for every page; when
the count goes to <tt>0</tt>, the kernel knows that the
page may be placed on the free list. When a VMA is unmapped, the
kernel decrements the usage count for every page in the area. If your
driver does not increment the count when adding a page to the area,
the usage count becomes <tt>0</tt> prematurely, and the
integrity of the system is compromised.</P>

<p class="docText">The <span class="docEmphasis">nopage</span> method should also store the type of
fault in the location pointed to by the <tt>type</tt>
argument—but only if that argument is not
<tt>NULL</tt>. In device drivers, the proper value for
<tt>type</tt> will invariably be
<tt>VM_FAULT_MINOR</tt>.</P>

<p class="docText">If you are using <span class="docEmphasis">nopage</span>, there is usually very
little work to be done when <span class="docEmphasis">mmap</span> is called; our
version looks like this:</p>

<pre>static int simple_nopage_mmap(struct file *filp, struct vm_area_struct *vma)
{
    unsigned long offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;

    if (offset &gt;= _ _pa(high_memory) || (filp-&gt;f_flags &amp; O_SYNC))
        vma-&gt;vm_flags |= VM_IO;
    vma-&gt;vm_flags |= VM_RESERVED;

    vma-&gt;vm_ops = &amp;simple_nopage_vm_ops;
    simple_vma_open(vma);
    return 0;
}</pre><BR>


<p class="docText">The main thing <span class="docEmphasis">mmap</span> has to do is to replace the
default (<tt>NULL</tt>) <tt>vm_ops</tt> pointer
with our own operations. The <span class="docEmphasis">nopage</span> method then
takes care of "remapping" one page
at a time and returning the address of its <tt>struct</tt>
<tt>page</tt> structure. Because we are just implementing a
window onto physical memory here, the remapping step is simple: we
only need to locate and return a pointer to the
<tt>struct</tt> <tt>page</tt> for the desired
address. Our <span class="docEmphasis">nopage</span> method looks like the
following:</P>

<pre>struct page *simple_vma_nopage(struct vm_area_struct *vma,
                unsigned long address, int *type)
{
    struct page *pageptr;
    unsigned long offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;
    unsigned long physaddr = address - vma-&gt;vm_start + offset;
    unsigned long pageframe = physaddr &gt;&gt; PAGE_SHIFT;

    if (!pfn_valid(pageframe))
        return NOPAGE_SIGBUS;
    pageptr = pfn_to_page(pageframe);
    get_page(pageptr);
    if (type)
        *type = VM_FAULT_MINOR;
    return pageptr;
}</pre><br>


<p class="docText">Since, once again, we are simply mapping main memory here, the
<span class="docEmphasis">nopage</span> function need only find the correct
<tt>struct</tt> <tt>page</tt> for the faulting
address and increment its reference count. Therefore, the required
sequence of events is to calculate the desired physical address, and
turn it into a page frame number by right-shifting it
<tt>PAGE_SHIFT</tt> bits. Since user space can give us any
address it likes, we must ensure that we have a valid page frame; the
<span class="docEmphasis">pfn_valid</span> function does that for us. If the
address is out of range, we return <tt>NOPAGE_SIGBUS</tt>,
which causes a bus signal to be delivered to the calling process.
Otherwise, <span class="docEmphasis">pfn_to_page</span> gets the necessary
<tt>struct</tt> <tt>page</tt> pointer; we can
increment its reference count (with a call to
<span class="docEmphasis">get_page</span>) and return it.</p>

<p class="docText">The <span class="docEmphasis">nopage</span> method normally returns a pointer to
a <tt>struct page</tt>. If, for some reason, a normal page
cannot be returned (e.g., the requested address is beyond the
device's memory region),
<tt>NOPAGE_SIGBUS</tt> can be returned to signal the error;
that is what the <span class="docEmphasis">simple</span> code above does.
<span class="docEmphasis">nopage</span> can also return
<tt>NOPAGE_OOM</tt> to indicate failures caused by resource
limitations.</p>

<p class="docText">Note that this implementation works for ISA memory regions but not
for those on the PCI bus. PCI memory is mapped above the highest
system memory, and there are no entries in the system memory map for
those addresses. Because there is no <tt>struct page</tt>
to return a pointer to, <span class="docEmphasis">nopage</span> cannot be used in
these situations; you must use <span class="docEmphasis">remap_pfn_range</span>
instead.</p>

<p class="docText">If the <span class="docEmphasis">nopage</span> method is left
<tt>NULL</tt>, kernel code that handles page faults maps
the zero page to the faulting virtual address. The <I>zero
page</i> is a copy-on-write page that reads as
<tt>0</tt> and that is used, for example, to map the BSS
segment. Any process referencing the zero page sees exactly that: a
page filled with zeroes. If the process writes to the page, it ends
up modifying a private copy. Therefore, if a process extends a mapped
region by calling <span class="docEmphasis">mremap</span>, and the driver
hasn't implemented <span class="docEmphasis">nopage</span>, the
process ends up with zero-filled memory instead of a segmentation
fault.</p>


<a name="chp-15-sect-2.5"></a>
<H4 class="docSection2Title">15.2.5. Remapping Specific I/O Regions</h4>

<p class="docText">All the examples we've seen
so<a name="chp-15-ITERM-7084"></a>
<a name="chp-15-ITERM-7085"></a> far are reimplementations of
<i>/dev/mem</I>; they remap physical addresses into
user space. The typical driver, however, wants to map only the small
address range that applies to its peripheral device, not all memory.
In order to map to user space only a subset of the whole memory
range, the driver needs only to play with the offsets. The following
does the trick for a driver mapping a region of
<tt>simple_region_size</tt> bytes, beginning at physical
address <tt>simple_region_start</tt> (which should be
page-aligned):</p>

<pre>unsigned long off = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;
unsigned long physical = simple_region_start + off;
unsigned long vsize = vma-&gt;vm_end - vma-&gt;vm_start;
unsigned long psize = simple_region_size - off;

if (vsize &gt; psize)
    return -EINVAL; /*  spans too high */
remap_pfn_range(vma, vma_&gt;vm_start, physical, vsize, vma-&gt;vm_page_prot);</pre><BR>


<p class="docText">In addition to calculating the offsets, this code introduces a check
that reports an error when the program tries to map more memory than
is available in the I/O region of the target device. In this code,
<tt>psize</tt> is the physical I/O size that is left after
the offset has been specified, and <tt>vsize</tt> is the
requested size of virtual memory; the function refuses to map
addresses that extend beyond the allowed memory range.</p>

<p class="docText"><a name="chp-15-ITERM-7086"></a><a name="chp-15-ITERM-7087"></a>Note that the user process can always
use <span class="docEmphasis">mremap</span> to extend its mapping, possibly past
the end of the physical device area. If your driver fails to define a
<span class="docEmphasis">nopage</span> method, it is never notified of this
extension, and the additional area maps to the zero page. As a driver
writer, you may well want to prevent this sort of behavior; mapping
the zero page onto the end of your region is not an explicitly bad
thing to do, but it is highly unlikely that the programmer wanted
that to happen.</p>

<p class="docText">The simplest way to prevent extension of the mapping is to implement
a simple <span class="docEmphasis">nopage</span> method that always causes a bus
signal to be sent to the faulting process. Such a method would look
like this:</p>

<pre>struct page *simple_nopage(struct vm_area_struct *vma,
                           unsigned long address, int *type);
{ return NOPAGE_SIGBUS; /* send a SIGBUS */}</pre><br>


<p class="docText">As we have seen, the <span class="docEmphasis">nopage</span> method is called
only when the process dereferences an address that is within a known
VMA but for which there is currently no valid page table entry. If we
have used <span class="docEmphasis">remap_pfn_range</span> to map the entire
device region, the <span class="docEmphasis">nopage</span> method shown here is
called only for references outside of that region. Thus, it can
safely return <tt>NOPAGE_SIGBUS</tt> to signal an error. Of
course, a more thorough implementation of <span class="docEmphasis">nopage</span>
could check to see whether the faulting address is within the device
area, and perform the remapping if that is the case. Once again,
however, <span class="docEmphasis">nopage</span> does not work with PCI memory
areas, so extension of PCI mappings is not possible.</p>


<a name="chp-15-sect-2.6"></a>
<h4 class="docSection2Title">15.2.6. Remapping RAM</h4>

<p class="docText">An interesting limitation of <a name="chp-15-ITERM-7088"></a>
<a name="chp-15-ITERM-7089"></a><span class="docEmphasis">remap_pfn_range</span>
<a name="chp-15-ITERM-7090"></a>
<a name="chp-15-ITERM-7091"></a>
<a name="chp-15-ITERM-7092"></a>is that it gives access only to reserved
pages and physical addresses above the top of physical memory. In
Linux, a page of physical addresses is marked as
"reserved" in the memory map to
indicate that it is not available for memory management. On the PC,
for example, the range between 640 KB and 1 MB is marked as reserved,
as are the pages that host the kernel code itself. Reserved pages are
locked in memory and are the only ones that can be safely mapped to
user space; this limitation is a basic requirement for system
stability.</p>

<p class="docText">Therefore, <span class="docEmphasis">remap_pfn_range</span>
won't allow you to remap conventional addresses,
which include the ones you obtain by calling
<span class="docEmphasis">get_free_page</span>. Instead, it maps in the zero
page. Everything appears to work, with the exception that the process
sees private, zero-filled pages rather than the remapped RAM that it
was hoping for. Nonetheless, the function does everything that most
hardware drivers need it to do, because it can remap high PCI buffers
and ISA memory.</p>

<p class="docText"><a name="chp-15-ITERM-7093"></a>
<a name="chp-15-ITERM-7094"></a>The
limitations of <span class="docEmphasis">remap_pfn_range</span> can be seen by
running <span class="docEmphasis">mapper</span>, one of the sample programs in
<i>misc-progs</i> in the files provided on
O'Reilly's FTP site.
<span class="docEmphasis">mapper</span> is a simple tool that can be used to
quickly test the <span class="docEmphasis">mmap</span> system call; it maps
read-only parts of a file specified by command-line options and dumps
the mapped region to standard output. The following session, for
instance, shows that <i>/dev/mem</i>
doesn't map the physical page located at address 64
KB—instead, we see a page full of zeros (the host computer in
this example is a PC, but the result would be the same on other
platforms):</P>

<pre>morgana.root# ./mapper /dev/mem 0x10000 0x1000 | od -Ax -t x1
mapped "/dev/mem" from 65536 to 69632
000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
001000</pre><br>


<p class="docText">The inability of <span class="docEmphasis">remap_pfn_range</span> to deal with
RAM suggests that memory-based devices like
<span class="docEmphasis">scull</span> can't easily implement
<span class="docEmphasis">mmap</span>, because its device memory is conventional
RAM, not I/O memory. Fortunately, a relatively easy workaround is
available to any driver that needs to map RAM into user space; it
uses the <span class="docEmphasis">nopage</span> method that we have seen
earlier.</P>

<a name="chp-15-sect-2.6.1"></a>
<H5 class="docSection3Title">15.2.6.1 Remapping RAM with the nopage method</h5>

<p class="docText">The way to map real RAM to user<a name="chp-15-ITERM-7095"></a>
<a name="chp-15-ITERM-7096"></a>
space is to use <tt>vm_ops-&gt;nopage</tt> to deal with
page faults one at a time. A sample implementation is part of the
<span class="docEmphasis">scullp</span> module, introduced in <a class="docLink" href="chp-8.shtml#chp-8">Chapter 8</a>.</p>

<p class="docText"><span class="docEmphasis">scullp</span> is a page-oriented char device. Because
it is page oriented, it can implement <span class="docEmphasis">mmap</span> on
its memory. The code implementing memory mapping uses some of the
concepts introduced in <a class="docLink" href="chp-15-sect-1.shtml#chp-15-sect-1">Section 15.1</a>.</p>

<p class="docText">Before examining the code, let's look at the design
choices that affect the <span class="docEmphasis">mmap</span> implementation in
<span class="docEmphasis">scullp</span><a name="chp-15-ITERM-7097"></a>:</P>

<ul><LI><p class="docList"><span class="docEmphasis">scullp</span> doesn't release device
memory as long as the device is mapped. This is a matter of policy
rather than a requirement, and it is different from the behavior of
<span class="docEmphasis">scull</span> and similar devices, which are truncated
to a length of <tt>0</tt> when opened for writing. Refusing
to free a mapped <span class="docEmphasis">scullp</span> device allows a process
to overwrite regions actively mapped by another process, so you can
test and see how processes and device memory interact. To avoid
releasing a mapped device, the driver must keep a count of active
mappings; the <tt>vmas</tt> field in the device structure
is used for this purpose.</P></LI><li><p class="docList">Memory mapping is performed only when the <span class="docEmphasis">scullp</span>
<tt>order</tt> parameter (set at module load time) is
<tt>0</tt>. The parameter controls how <span class="docEmphasis">_
_get_free_pages</span> is invoked (see <a class="docLink" href="chp-8-sect-3.shtml#chp-8-sect-3">Section 8.3</a>).
The zero-order limitation
(which forces pages to be allocated one at a time, rather than in
larger groups) is dictated by the internals of <span class="docEmphasis">_
_get_free_pages</span>, the allocation function used by
<span class="docEmphasis">scullp</span>. To maximize allocation performance, the
Linux kernel maintains a list of free pages for each allocation
order, and only the reference count of the first page in a cluster is
incremented by <span class="docEmphasis">get_free_pages</span> and decremented by
<span class="docEmphasis">free_pages</span>. The <span class="docEmphasis">mmap</span> method
is disabled for a <span class="docEmphasis">scullp</span> device if the
allocation order is greater than zero, because
<span class="docEmphasis">nopage</span> deals with single pages rather than
clusters of pages. <span class="docEmphasis">scullp</span> simply does not know
how to properly manage reference counts for pages that are part of
higher-order allocations. (Return to <a class="docLink" href="chp-8-sect-3.shtml#chp-8-sect-3.1">Section 8.3.1</a>
if you need a refresher on
<span class="docEmphasis">scullp</span> and the memory allocation order value.)</p></li></ul>
<p class="docText"><a name="chp-15-ITERM-7098"></a>The <a name="chp-15-ITERM-7099"></a>zero-order limitation is mostly
intended to keep the code simple. It <span class="docEmphasis">is</span> possible
to correctly implement <span class="docEmphasis">mmap</span> for multipage
allocations by playing with the usage count of the pages, but it
would only add to the complexity of the example without introducing
any interesting information.</P>

<p class="docText">Code that is intended to map RAM according to the rules just outlined
needs to implement the <span class="docEmphasis">open</span>,
<span class="docEmphasis">close</span>, and <span class="docEmphasis">nopage</span> VMA
methods; it also needs to access the memory map to adjust the page
usage counts.</P>

<p class="docText">This implementation of <span class="docEmphasis">scullp_mmap</span> is very
short, because it relies on the <span class="docEmphasis">nopage</span> function
to do all the interesting work:</P>

<pre>int scullp_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;

    /* refuse to map if order is not 0 */
    if (scullp_devices[iminor(inode)].order)
        return -ENODEV;

    /* don't do anything here: "nopage" will fill the holes */
    vma-&gt;vm_ops = &amp;scullp_vm_ops;
    vma-&gt;vm_flags |= VM_RESERVED;
    vma-&gt;vm_private_data = filp-&gt;private_data;
    scullp_vma_open(vma);
    return 0;
}</pre><br>


<p class="docText">The purpose of the <tt>if</tt> statement is to avoid
mapping devices whose allocation order is not <tt>0</tt>.
<span class="docEmphasis">scullp</span>'s operations are stored
in the <tt>vm_ops</tt> field, and a pointer to the device
structure is stashed in the <tt>vm_private_data</tt> field.
At the end, <tt>vm_ops-&gt;open</tt> is called to update
the count of active mappings for the device.</P>

<p class="docText"><span class="docEmphasis">open</span> and <span class="docEmphasis">close</span> simply keep
track of the mapping count and are defined as follows:</P>

<pre>void scullp_vma_open(struct vm_area_struct *vma)
{
    struct scullp_dev *dev = vma-&gt;vm_private_data;

    dev-&gt;vmas++;
}

void scullp_vma_close(struct vm_area_struct *vma)
{
    struct scullp_dev *dev = vma-&gt;vm_private_data;

    dev-&gt;vmas--;
}</pre><br>


<p class="docText">Most of the work is then performed by <span class="docEmphasis">nopage</span>. In
the <span class="docEmphasis">scullp</span> implementation, the
<tt>address</tt> parameter to <span class="docEmphasis">nopage</span>
is used to calculate an offset into the device; the offset is then
used to look up the correct page in the <span class="docEmphasis">scullp</span>
memory tree:</p>

<pre>struct page *scullp_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
    unsigned long offset;
    struct scullp_dev *ptr, *dev = vma-&gt;vm_private_data;
    struct page *page = NOPAGE_SIGBUS;
    void *pageptr = NULL; /* default to "missing" */

    down(&amp;dev-&gt;sem);
    offset = (address - vma-&gt;vm_start) + (vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);
    if (offset &gt;= dev-&gt;size) goto out; /* out of range */

    /*
     * Now retrieve the scullp device from the list,then the page.
     * If the device has holes, the process receives a SIGBUS when
     * accessing the hole.
     */
    offset &gt;&gt;= PAGE_SHIFT; /* offset is a number of pages */
    for (ptr = dev; ptr &amp;&amp; offset &gt;= dev-&gt;qset;) {
        ptr = ptr-&gt;next;
        offset -= dev-&gt;qset;
    }
    if (ptr &amp;&amp; ptr-&gt;data) pageptr = ptr-&gt;data[offset];
    if (!pageptr) goto out; /* hole or end-of-file */
    page = virt_to_page(pageptr);
    
    /* got it, now increment the count */
    get_page(page);
    if (type)
        *type = VM_FAULT_MINOR;
  out:
    up(&amp;dev-&gt;sem);
    return page;
}</pre><br>


<p class="docText"><span class="docEmphasis">scullp</span> uses memory obtained with
<span class="docEmphasis">get_free_pages</span>. That memory is addressed using
logical addresses, so all <span class="docEmphasis">scullp_nopage</span> has to
do to get a <tt>struct</tt> <tt>page</tt> pointer
is to call <span class="docEmphasis">virt_to_page</span>.</p>

<p class="docText">The <span class="docEmphasis">scullp</span> device now works as expected, as you
can see in this sample output from the <span class="docEmphasis">mapper</span>
utility. Here, we send a directory listing of
<I>/dev</i> (which is long) to the
<span class="docEmphasis">scullp</span> device and then use the
<span class="docEmphasis">mapper</span> utility to look at pieces of that listing
with <span class="docEmphasis">mmap</span>:</p>

<pre>morgana% <B>ls -l /dev &gt; /dev/scullp</b>
morgana% <b>./mapper /dev/scullp 0 140</b>
mapped "/dev/scullp" from 0 (0x00000000) to 140 (0x0000008c)
total 232
crw-------    1 root     root      10,  10 Sep 15 07:40 adbmouse
crw-r--r--    1 root     root      10, 175 Sep 15 07:40 agpgart
morgana% <b>./mapper /dev/scullp 8192 200</b>
mapped "/dev/scullp" from 8192 (0x00002000) to 8392 (0x000020c8)
d0h1494
brw-rw----    1 root     floppy     2,  92 Sep 15 07:40 fd0h1660
brw-rw----    1 root     floppy     2,  20 Sep 15 07:40 fd0h360
brw-rw----    1 root     floppy     2,  12 Sep 15 07:40 fd0H360</pre><BR>




<a name="chp-15-sect-2.7"></a>
<h4 class="docSection2Title">15.2.7. Remapping Kernel Virtual Addresses</H4>

<p class="docText">Although it's rarely
<a name="chp-15-ITERM-7100"></a>
<a name="chp-15-ITERM-7101"></a> <a name="chp-15-ITERM-7102"></a>
<a name="chp-15-ITERM-7103"></a>necessary,
it's interesting to see how a driver can map a
kernel virtual address to user space using <span class="docEmphasis">mmap</span>.
A true kernel virtual address, remember, is an address returned by a
function<a name="chp-15-ITERM-7104"></a> such as
<span class="docEmphasis">vmalloc</span>—that is, a virtual address mapped
in the kernel page tables. The code in this section is taken from
<span class="docEmphasis">scullv</span>, which is the module that works like
<span class="docEmphasis">scullp</span> but allocates its storage through
<span class="docEmphasis">vmalloc</span>.</p>

<p class="docText">Most of the <span class="docEmphasis">scullv</span> implementation is like the
one we've just seen for <span class="docEmphasis">scullp</span>,
except that there is no need to check the <tt>order</tt>
parameter that controls memory allocation. The reason for this is
that <span class="docEmphasis">vmalloc</span> allocates its pages one at a time,
because single-page allocations are far more likely to succeed than
multipage allocations. Therefore, the allocation order problem
doesn't apply to <span class="docEmphasis">vmalloc</span>ed
space.</p>

<p class="docText">Beyond that, there is only one difference between the
<span class="docEmphasis">nopage</span> implementations used by
<span class="docEmphasis">scullp</span> and <span class="docEmphasis">scullv</span>. Remember
that <span class="docEmphasis">scullp</span>, once it found the page of interest,
would obtain the corresponding <tt>struct</tt>
<tt>page</tt> pointer with
<span class="docEmphasis">virt_to_page</span>. That function does not work with
kernel virtual addresses, however. Instead, you must use
<span class="docEmphasis">vmalloc_to_page</span>. So the final part of the
<span class="docEmphasis">scullv</span> version of <span class="docEmphasis">nopage</span>
looks like:</p>

<pre>  /*
   * After scullv lookup, "page" is now the address of the page
   * needed by the current process. Since it's a vmalloc address,
   * turn it into a struct page.
   */
  page = vmalloc_to_page(pageptr);
    
  /* got it, now increment the count */
  get_page(page);
  if (type)
      *type = VM_FAULT_MINOR;
out:
  up(&amp;dev-&gt;sem);
  return page;</pre><br>


<p class="docText">Based on this discussion, <a name="chp-15-ITERM-7105"></a> <a name="chp-15-ITERM-7106"></a> <a name="chp-15-ITERM-7107"></a> <a name="chp-15-ITERM-7108"></a> <a name="chp-15-ITERM-7109"></a> <a name="chp-15-ITERM-7110"></a>you might also want to map addresses
returned by <span class="docEmphasis">ioremap</span> to user space. That would be
a mistake, however; addresses from <span class="docEmphasis">ioremap</span> are
special and cannot be treated like normal kernel virtual addresses.
Instead, you should use <span class="docEmphasis">remap_pfn_range</span> to remap
I/O memory areas into user space.</p>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-15-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-15-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
