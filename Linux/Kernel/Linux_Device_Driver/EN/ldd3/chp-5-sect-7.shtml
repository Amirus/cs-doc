<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>5.7. Alternatives to Locking</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-5-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-5-sect-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-5-sect-7"></a>
<h3 class="docSection1Title">5.7. Alternatives to Locking</h3>

<p class="docText">The Linux kernel provides a<a name="chp-5-ITERM-5058"></a> <a name="chp-5-ITERM-5059"></a> <a name="chp-5-ITERM-5060"></a> <a name="chp-5-ITERM-5061"></a> <a name="chp-5-ITERM-5062"></a> number of powerful locking
primitives that can be used to keep the kernel from tripping over its
own feet. But, as we have seen, the design and implementation of a
locking scheme is not without its pitfalls. Often there is no
alternative to semaphores and spinlocks; they may be the only way to
get the job done properly. There are situations, however, where
atomic access can be set up without the need for full locking. This
section looks at other ways of doing things.</p>

<a name="chp-5-sect-7.1"></a>
<h4 class="docSection2Title">5.7.1. Lock-Free Algorithms</H4>

<p class="docText">Sometimes, you can recast your<a name="chp-5-ITERM-5063"></a> <a name="chp-5-ITERM-5064"></a> algorithms to avoid the need for
locking altogether. A number of reader/writer situations—if
there is only one writer—can often work in this manner. If the
writer takes care that the view of the data structure, as seen by the
reader, is always consistent, it may be possible to create a
lock-free data structure.</P>

<p class="docText">A data structure that can often be useful for lockless
producer/consumer tasks is the <I>circular
buffer</i><a name="chp-5-ITERM-5065"></a>
<a name="chp-5-ITERM-5066"></a>.
This algorithm involves a producer placing data into one end of an
array, while the consumer removes data from the other. When the end
of the array is reached, the producer wraps back around to the
beginning. So a circular buffer requires an array and two index
values to track where the next new value goes and which value should
be removed from the buffer next.</P>

<p class="docText">When carefully implemented, a circular buffer requires no locking in
the absence of multiple producers or consumers. The producer is the
only thread that is allowed to modify the write index and the array
location it points to. As long as the writer stores a new value into
the buffer before updating the write index, the reader will always
see a consistent view. The reader, in turn, is the only thread that
can access the read index and the value it points to. With a bit of
care to ensure that the two pointers do not overrun each other, the
producer and the consumer can access the buffer concurrently with no
race conditions.</P>

<p class="docText"><a class="docLink" href="chp-5-sect-7.shtml#chp-5-FIG-1">Figure 5-1</a> shows circular
buffer in several states of fill. This buffer has been defined such
that an empty condition is indicated by the read and write pointers
being equal, while a full condition happens whenever the write
pointer is immediately behind the read pointer (being careful to
account for a wrap!). When carefully programmed, this buffer can be
used without locks.</p>

<a name="chp-5-FIG-1"></a><p><center>
<h5 class="docFigureTitle">Figure 5-1. A circular buffer</h5>
<img border="0" alt="" width="346" height="189" SRC="images/0596005903/figs/ldr3_0501.gif"></center></P><br>

<p class="docText">Circular buffers show up reasonably often in device drivers.
Networking adaptors, in particular, often use circular buffers to
exchange data (packets) with the processor. Note that, as of 2.6.10,
there is a generic circular buffer implementation available in the
kernel; see <i>&lt;linux/kfifo.h&gt;</I> for
information on how to use it.</p>


<a name="chp-5-sect-7.2"></a>
<h4 class="docSection2Title">5.7.2. Atomic Variables</H4>

<p class="docText">Sometimes, a shared resource <a name="chp-5-ITERM-5067"></a>
<a name="chp-5-ITERM-5068"></a>
<a name="chp-5-ITERM-5069"></a>is a simple integer value. Suppose
your driver maintains a shared variable <tt>n_op</tt> that
tells how many device operations are currently outstanding. Normally,
even a simple operation such as:</p>

<pre>n_op++;</pre><BR>


<p class="docText">would require locking. Some processors might perform that sort of
increment in an atomic manner, but you can't count
on it. But a full locking regime seems like overhead for a simple
integer value. For cases like this, the kernel provides an atomic
integer type called <tt>atomic_t</tt>, defined in
<i>&lt;asm/atomic.h&gt;</i>.</p>

<p class="docText">An <tt>atomic_t</tt> holds an <tt>int</tt> value
on all supported architectures. Because of the way this type works on
some processors, however, the full integer range may not be
available; thus, you should not count on an
<tt>atomic_t</tt> holding more than 24 bits. The following
operations are defined for the type and are guaranteed to be atomic
with respect to all processors of an SMP computer. The operations are
very fast, because they compile to a single machine instruction
whenever possible.</p>

<a name="chp-5-ITERM-5070"></a><a name="chp-5-ITERM-5071"></a><a name="chp-5-ITERM-5072"></a><a name="chp-5-ITERM-5073"></a><a name="chp-5-ITERM-5074"></a><a name="chp-5-ITERM-5075"></a><a name="chp-5-ITERM-5076"></a><a name="chp-5-ITERM-5077"></a><a name="chp-5-ITERM-5078"></a><a name="chp-5-ITERM-5079"></a><a name="chp-5-ITERM-5080"></a><a name="chp-5-ITERM-5081"></a><a name="chp-5-ITERM-5082"></a><a name="chp-5-ITERM-5083"></a><a name="chp-5-ITERM-5084"></a><a name="chp-5-ITERM-5085"></a><a name="chp-5-ITERM-5086"></a><a name="chp-5-ITERM-5087"></a><a name="chp-5-ITERM-5088"></a><a name="chp-5-ITERM-5089"></a><a name="chp-5-ITERM-5090"></a><a name="chp-5-ITERM-5091"></a><a name="chp-5-ITERM-5092"></a><a name="chp-5-ITERM-5093"></a><a name="chp-5-ITERM-5094"></a><a name="chp-5-ITERM-5095"></a><a name="chp-5-ITERM-5096"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void atomic_set(atomic_t *v, int i);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">atomic_t v = ATOMIC_INIT(0);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-5-ITERM-5070"></a>
<a name="chp-5-ITERM-5071"></a>
<a name="chp-5-ITERM-5072"></a>Set
the atomic variable <tt>v</tt> to the integer value
<tt>i</tt>. You can also initialize atomic values at
compile time with the <tt>ATOMIC_INIT</tt> macro.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_read(atomic_t *v);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-5-ITERM-5073"></a>
<a name="chp-5-ITERM-5074"></a>
<a name="chp-5-ITERM-5075"></a>Return
the current value of <tt>v</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void atomic_add(int i, atomic_t *v);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-5-ITERM-5076"></a>
<a name="chp-5-ITERM-5077"></a>
<a name="chp-5-ITERM-5078"></a>Add
<tt>i</tt> to the atomic variable pointed to by
<tt>v</tt>. The return value is <tt>void</tt>,
because there is an extra cost to returning the new value, and most
of the time there's no need to know it.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void atomic_sub(int i, atomic_t *v);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-5-ITERM-5079"></a>
<a name="chp-5-ITERM-5080"></a>
<a name="chp-5-ITERM-5081"></a>Subtract
<tt>i</tt> from <tt>*v</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void atomic_inc(atomic_t *v);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void atomic_dec(atomic_t *v);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-5-ITERM-5082"></a>
<a name="chp-5-ITERM-5083"></a>
<a name="chp-5-ITERM-5084"></a><a name="chp-5-ITERM-5085"></a>
<a name="chp-5-ITERM-5086"></a>
<a name="chp-5-ITERM-5087"></a>Increment
or decrement an atomic variable.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_inc_and_test(atomic_t *v);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_dec_and_test(atomic_t *v);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_sub_and_test(int i, atomic_t *v);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-5-ITERM-5088"></a>
<a name="chp-5-ITERM-5089"></a>
<a name="chp-5-ITERM-5090"></a><a name="chp-5-ITERM-5091"></a>
<a name="chp-5-ITERM-5092"></a>
<a name="chp-5-ITERM-5093"></a><a name="chp-5-ITERM-5094"></a>
<a name="chp-5-ITERM-5095"></a>
<a name="chp-5-ITERM-5096"></a>Perform
the specified operation and test the result; if, after the operation,
the atomic value is <tt>0</tt>, then the return value is
true; otherwise, it is false. Note that there is no
<span class="docEmphasis">atomic_add_and_test</span>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_add_negative(int i, atomic_t *v);</span></span></span></dt></P>
<dd>
<p class="docList">Add the integer variable <tt>i</tt> to
<tt>v</tt>. The return value is true if the result is
negative, false otherwise.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_add_return(int i, atomic_t *v);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_sub_return(int i, atomic_t *v);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_inc_return(atomic_t *v);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int atomic_dec_return(atomic_t *v);</span></span></span></dt></p>
<dd>
<p class="docList">Behave just like <span class="docEmphasis">atomic_add</span> and friends, with
the exception that they return the new value of the atomic variable
to the caller.</p>
</dd>
</dl>

<p class="docText">As stated earlier, <tt>atomic_t</tt> data items must be
accessed only through these functions. If you pass an atomic item to
a function that expects an integer argument, you'll
get a compiler error.</p>

<p class="docText">You should also bear in mind that <tt>atomic_t</tt> values
work only when the quantity in question is truly atomic. Operations
requiring multiple <tt>atomic_t</tt> variables still
require some other sort of locking. Consider the following code:</p>

<pre>atomic_sub(amount, &amp;first_atomic);
atomic_add(amount, &amp;second_atomic);</pre><br>


<p class="docText">There is a period of time where the <tt>amount</tt> has
been subtracted from the first atomic value but not yet added to the
second. If that state of affairs could create trouble for code that
might run between the two operations, some form of locking must be
employed.</p>


<a name="chp-5-sect-7.3"></a>
<H4 class="docSection2Title">5.7.3. Bit Operations</h4>

<p class="docText">The <tt>atomic_t</tt> type is good for
performing<a name="chp-5-ITERM-5097"></a>
<a name="chp-5-ITERM-5098"></a>
<a name="chp-5-ITERM-5099"></a>
integer arithmetic. It doesn't work as well,
however, when you need to manipulate individual bits in an atomic
manner. For that purpose, instead, the kernel offers a set of
functions that modify or test single bits atomically. Because the
whole operation happens in a single step, no interrupt (or other
processor) can interfere.</P>

<p class="docText">Atomic bit operations are very fast, since they perform the operation
using a single machine instruction without disabling interrupts
whenever the underlying platform can do that. The functions are
architecture dependent and are declared in
<I>&lt;asm/bitops.h&gt;</i>. They are guaranteed to be
atomic even on SMP computers and are useful to keep coherence across
processors.</p>

<p class="docText">Unfortunately, data typing in these functions is architecture
dependent as well. The <tt>nr</tt> argument (describing
which bit to manipulate) is usually defined as <tt>int</tt>
but is <tt>unsigned long</tt> for a few architectures. The
address to be modified is usually a pointer to <tt>unsigned
long</tt>, but a few architectures use <tt>void *</tt>
instead.</p>

<p class="docText">The available bit operations are:</P>

<a name="chp-5-ITERM-5100"></a><a name="chp-5-ITERM-5101"></a><a name="chp-5-ITERM-5102"></a><a name="chp-5-ITERM-5103"></a><a name="chp-5-ITERM-5104"></a><a name="chp-5-ITERM-5105"></a><a name="chp-5-ITERM-5106"></a><a name="chp-5-ITERM-5107"></a><a name="chp-5-ITERM-5108"></a><a name="chp-5-ITERM-5109"></a><a name="chp-5-ITERM-5110"></a><a name="chp-5-ITERM-5111"></a><a name="chp-5-ITERM-5112"></a><a name="chp-5-ITERM-5113"></a><a name="chp-5-ITERM-5114"></a><a name="chp-5-ITERM-5115"></a><a name="chp-5-ITERM-5116"></a><a name="chp-5-ITERM-5117"></a><a name="chp-5-ITERM-5118"></a><a name="chp-5-ITERM-5119"></a><a name="chp-5-ITERM-5120"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void set_bit(nr, void *addr);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-5-ITERM-5100"></a>
<a name="chp-5-ITERM-5101"></a>
<a name="chp-5-ITERM-5102"></a>Sets
bit number <tt>nr</tt> in the data item pointed to by
<tt>addr</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void clear_bit(nr, void *addr);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-5-ITERM-5103"></a>
<a name="chp-5-ITERM-5104"></a>
<a name="chp-5-ITERM-5105"></a>Clears
the specified bit in the <tt>unsigned long</tt> datum that
lives at <tt>addr</tt>. Its semantics are otherwise the
same as <span class="docEmphasis">set_bit</span>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void change_bit(nr, void *addr);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-5-ITERM-5106"></a>
<a name="chp-5-ITERM-5107"></a>
<a name="chp-5-ITERM-5108"></a>Toggles
the bit.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">test_bit(nr, void *addr);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-5-ITERM-5109"></a>
<a name="chp-5-ITERM-5110"></a>
<a name="chp-5-ITERM-5111"></a>This
function is the only bit operation that doesn't need
to be atomic; it simply returns the current value of the bit.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int test_and_set_bit(nr, void *addr);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int test_and_clear_bit(nr, void *addr);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int test_and_change_bit(nr, void *addr);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-5-ITERM-5112"></a>
<a name="chp-5-ITERM-5113"></a>
<a name="chp-5-ITERM-5114"></a><a name="chp-5-ITERM-5115"></a>
<a name="chp-5-ITERM-5116"></a>
<a name="chp-5-ITERM-5117"></a><a name="chp-5-ITERM-5118"></a>
<a name="chp-5-ITERM-5119"></a>
<a name="chp-5-ITERM-5120"></a>Behave
atomically like those listed previously, except that they also return
the previous value of the bit.</p>
</dd>
</dl>

<p class="docText">When these functions are used to access and modify a shared flag, you
don't have to do anything except call them; they
perform their operations in an atomic manner. Using bit operations to
manage a lock variable that controls access to a shared variable, on
the other hand, is a little more complicated and deserves an example.
Most modern code does not use bit operations in this way, but code
like the following still exists in the kernel.</P>

<p class="docText">A code segment that needs to access a shared data item tries to
atomically acquire a lock using either
<span class="docEmphasis">test_and_set_bit</span> or
<span class="docEmphasis">test_and_clear_bit</span>. The usual implementation is
shown here; it assumes that the lock lives at bit
<tt>nr</tt> of address <tt>addr</tt>. It also
assumes that the bit is <tt>0</tt> when the lock is free or
nonzero when the lock is busy.</p>

<pre>/* try to set lock */
while (test_and_set_bit(nr, addr) != 0)
    wait_for_a_while(  );

/* do your work */

/* release lock, and check... */
if (test_and_clear_bit(nr, addr) =  = 0)
    something_went_wrong(  ); /* already released: error */</pre><br>


<p class="docText">If you read through the kernel source, you find code that works like
this example. It is, however, far better to use spinlocks in new
code; spinlocks are well debugged, they handle issues like interrupts
and kernel preemption, and others reading your code do not have to
work to understand what you are doing.</p>


<a name="chp-5-sect-7.4"></a>
<h4 class="docSection2Title">5.7.4. seqlocks</h4>

<p class="docText">The 2.6 kernel contains
<a name="chp-5-ITERM-5121"></a>
<a name="chp-5-ITERM-5122"></a>
<a name="chp-5-ITERM-5123"></a>a
couple of new mechanisms that are intended to provide fast, lockless
access to a shared resource. Seqlocks work in situations where the
resource to be protected is small, simple, and frequently accessed,
and where write access is rare but must be fast. Essentially, they
work by allowing readers free access to the resource but requiring
those readers to check for collisions with writers and, when such a
collision happens, retry their access. Seqlocks generally cannot be
used to protect data structures involving pointers, because the
reader may be following a pointer that is invalid while the writer is
changing the data structure.</p>

<p class="docText">Seqlocks are defined in <i>&lt;linux/seqlock.h&gt;</i>.
There are the two usual methods for initializing a
<a name="chp-5-ITERM-5124"></a>seqlock
(which has type <tt>seqlock_t</tt>):</p>

<pre>seqlock_t lock1 = SEQLOCK_UNLOCKED;

seqlock_t lock2;
seqlock_init(&amp;lock2);</pre><br>


<p class="docText">Read access works by obtaining an (unsigned) integer sequence value
on entry into the critical section. On exit, that sequence value is
compared with the current value; if there is a mismatch, the read
access must be retried. As a result, reader code has a form like the
following:</p>

<pre>unsigned int seq;

do {
    seq = read_seqbegin(&amp;the_lock);
    /* Do what you need to do */
} while read_seqretry(&amp;the_lock, seq);</pre><br>


<p class="docText">This sort of lock is usually used to protect some sort of simple
computation that requires multiple, consistent values. If the test at
the end of the computation shows that a concurrent write occurred,
the results can be simply discarded and recomputed.</p>

<p class="docText">If your seqlock might be accessed from an interrupt handler, you
should use the IRQ-safe versions instead:</P>

<pre>unsigned int read_seqbegin_irqsave(seqlock_t *lock, 
                                   unsigned long flags);
int read_seqretry_irqrestore(seqlock_t *lock, unsigned int seq,
                             unsigned long flags);</pre><br>


<p class="docText">Writers must obtain an exclusive lock to enter the critical section
protected by a seqlock. To do so, call:</P>

<pre>void write_seqlock(seqlock_t *lock);</pre><BR>


<p class="docText">The write lock is implemented with a spinlock, so all the usual
constraints apply. Make a call to:</p>

<pre>void write_sequnlock(seqlock_t *lock);</pre><br>


<p class="docText">to release the lock. Since spinlocks are used to control write
access, all of the usual variants are available:</p>

<pre>void write_seqlock_irqsave(seqlock_t *lock, unsigned long flags);
void write_seqlock_irq(seqlock_t *lock);
void write_seqlock_bh(seqlock_t *lock);

void write_sequnlock_irqrestore(seqlock_t *lock, unsigned long flags);
void write_sequnlock_irq(seqlock_t *lock);
void write_sequnlock_bh(seqlock_t *lock);</pre><BR>


<p class="docText">There is also a <span class="docEmphasis">write_tryseqlock</span> that returns
nonzero if it was able to obtain the lock.</p>


<a name="chp-5-sect-7.5"></a>
<H4 class="docSection2Title">5.7.5. Read-Copy-Update</H4>

<p class="docText"><a name="chp-5-ITERM-5125"></a>
<a name="chp-5-ITERM-5126"></a>
<a name="chp-5-ITERM-5127"></a>Read-copy-update (RCU) is an advanced mutual
exclusion scheme that can yield high performance in the right
conditions. Its use in drivers is rare but not unknown, so it is
worth a quick overview here. Those who are interested in the full
details of the RCU algorithm can find them in the white paper
published by its creator (<a class="docLink" target="_blank" href="http://www.rdrop.com/users/paulmck/rclock/intro/rclock_intro.html">http://www.rdrop.com/users/paulmck/rclock/intro/rclock_intro.html</a>).</P>

<p class="docText">RCU places a number of constraints on the sort of data structure that
it can protect. It is optimized for situations where reads are common
and writes are rare. The resources being protected should be accessed
via pointers, and all references to those resources must be held only
by atomic code. When the data structure needs to be changed, the
writing thread makes a copy, changes the copy, then aims the relevant
pointer at the new version—thus, the name of the algorithm.
When the kernel is sure that no references to the old version remain,
it can be freed.</p>

<p class="docText">As an example of real-world use of RCU, consider the network routing
tables. Every outgoing packet requires a check of the routing tables
to determine which interface should be used. The check is fast, and,
once the kernel has found the target interface, it no longer needs
the routing table entry. RCU allows route lookups to be performed
without locking, with significant performance benefits. The Starmode
radio IP driver in the kernel also uses RCU to keep track of its list
of devices.</p>

<p class="docText">Code using RCU should include
<i>&lt;linux/rcupdate.h&gt;</i>.</P>

<p class="docText">On the read side, code using an RCU-protected data structure should
bracket its references with calls to
<span class="docEmphasis">rcu_read_lock</span> and
<span class="docEmphasis">rcu_read_unlock</span>. As a result, RCU code tends to
look like:</P>

<pre>struct my_stuff *stuff;

rcu_read_lock(  );
stuff = find_the_stuff(args...);
do_something_with(stuff);
rcu_read_unlock(  );</pre><BR>


<p class="docText">The <span class="docEmphasis">rcu_read_lock</span> call is fast; it disables
kernel preemption but does not wait for anything. The code that
executes while the read "lock" is
held must be atomic. No reference to the protected resource may be
used after the call to <span class="docEmphasis">rcu_read_unlock</span>.</p>

<p class="docText">Code that needs to change the protected structure has to carry out a
few steps. The first part is easy; it allocates a new structure,
copies data from the old one if need be, then replaces the pointer
that is seen by the read code. At this point, for the purposes of the
read side, the change is complete; any code entering the critical
section sees the new version of the data.</P>

<p class="docText">All that remains is to free the old version. The problem, of course,
is that code running on other processors may still have a reference
to the older data, so it cannot be freed immediately. Instead, the
write code must wait until it knows that no such reference can exist.
Since all code holding references to this data structure must (by the
rules) be atomic, we know that once every processor on the system has
been scheduled at least once, all references must be gone. So that is
what RCU does; it sets aside a callback that waits until all
processors have scheduled; that callback is then run to perform the
cleanup work.</P>

<p class="docText">Code that changes an RCU-protected data structure must get its
cleanup callback by allocating a <tt>struct</tt>
<tt>rcu_head</tt>, although it doesn't
need to initialize that structure in any way. Often, that structure
is simply embedded within the larger resource that is protected by
RCU. After the change to that resource is complete, a call should be
made to:</p>

<pre>void call_rcu(struct rcu_head *head, void (*func)(void *arg), void *arg);</pre><br>


<p class="docText">The given <tt>func</tt> is called when it is safe to free
the resource; it is passed to the same <tt>arg</tt> that
was passed to <span class="docEmphasis">call_rcu</span>. Usually, the only thing
<tt>func</tt> needs to do is to call
<span class="docEmphasis">kfree</span>.</p>

<p class="docText">The full RCU interface is more complex than we have seen here; it
includes, for example, utility functions for <a name="chp-5-ITERM-5128"></a> <a name="chp-5-ITERM-5129"></a> <a name="chp-5-ITERM-5130"></a> <a name="chp-5-ITERM-5131"></a> <a name="chp-5-ITERM-5132"></a>working with
protected linked lists. See the relevant header files for the full
story.</p>



<UL></ul></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-5-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-5-sect-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
