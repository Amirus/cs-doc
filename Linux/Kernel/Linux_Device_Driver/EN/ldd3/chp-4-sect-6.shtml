<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>4.6. Debuggers and Related Tools</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-4-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="chp-4-sect-6"></a>
<h3 class="docSection1Title">4.6. Debuggers and Related Tools</h3>

<p class="docText">The last resort in debugging<a name="chp-4-ITERM-4915"></a> <a name="chp-4-ITERM-4916"></a>
<a name="chp-4-ITERM-4917"></a>
modules is <a name="chp-4-ITERM-4918"></a>using a
debugger to step through the code, watching the value of variables
and machine registers. This approach is time-consuming and should be
avoided whenever possible. Nonetheless, the fine-grained perspective
on the code that is achieved through a debugger is sometimes
invaluable.</p>

<p class="docText">Using an interactive debugger on the kernel is a challenge. The
kernel runs in its own address space on behalf of all the processes
on the system. As a result, a number of common capabilities provided
by user-space debuggers, such as breakpoints and single-stepping, are
harder to come by in the kernel. In this section we look at several
ways of debugging the kernel; each of them has advantages and
disadvantages.</p>

<a name="chp-4-sect-6.1"></a>
<H4 class="docSection2Title">4.6.1. Using gdb</h4>

<p class="docText"><span class="docEmphasis">gdb</span> can be quite useful for looking at the
system internals. Proficient use of the debugger at this level
requires some confidence with
<span class="docEmphasis">gdb</span><a name="chp-4-ITERM-4919"></a>
<a name="chp-4-ITERM-4920"></a>
commands, some understanding of assembly code for the target
platform, and the ability to match source code and optimized
assembly.</P>

<p class="docText"><a name="chp-4-ITERM-4921"></a><a name="chp-4-ITERM-4922"></a><a name="chp-4-ITERM-4923"></a>The debugger must be invoked as though the
kernel were an application. In addition to specifying the filename
for the ELF kernel image, you need to provide the name of a core file
on the command line. For a running kernel, that core file is the
kernel core image, <I>/proc/kcore</i>. A typical
invocation of <span class="docEmphasis">gdb</span> looks like the following:</p>

<pre>gdb /usr/src/linux/vmlinux /proc/kcore</pre><br>


<p class="docText">The first argument is the name of the uncompressed ELF kernel
executable, not the <I>zImage</i> or
<I>bzImage</I> or anything built specifically for the
boot environment.</P>

<p class="docText">The second argument on the <span class="docEmphasis">gdb</span> command line is
the name of the core file. Like any file in
<i>/proc</i>, <i>/proc/kcore</i> is
generated when it is read. When the <span class="docEmphasis">read</span> system
call executes in the <I>/proc</I> filesystem, it maps
to a data-generation function rather than a data-retrieval one;
we've already exploited this feature in the section
<a class="docLink" href="chp-4-sect-3.shtml#chp-4-sect-3.1">Section 4.3.1</a>.
<I>kcore</i> is used to represent the kernel
"executable" in the format of a
core file; it is a huge file, because it represents the whole kernel
address space, which corresponds to all physical memory. From within
<span class="docEmphasis">gdb</span>, you can look at kernel variables by issuing
the standard <span class="docEmphasis">gdb</span> commands. For example,
<tt>p jiffies</tt> prints the number of clock ticks from
system boot to the current time.</P>

<p class="docText"><a name="chp-4-ITERM-4924"></a>When you print
data from <span class="docEmphasis">gdb</span>, the kernel is still running, and
the various data items have different values at different times;
<span class="docEmphasis">gdb</span>, however, optimizes access to the core file
by caching data that has already been read. If you try to look at the
<tt>jiffies</tt> variable once again,
you'll get the same answer as before. Caching values
to avoid extra disk access is a correct behavior for conventional
core files but is inconvenient when a
"dynamic" core image is used. The
solution is to issue the command <span class="docEmphasis">core-file
/proc/kcore</span> whenever you want to flush the
<span class="docEmphasis">gdb</span> cache; the debugger gets ready to use a new
core file and discards any old information. You
won't, however, always need to issue
<span class="docEmphasis">core-file</span> when reading a new datum;
<span class="docEmphasis">gdb</span> reads the core in chunks of a few kilobytes
and caches only chunks it has already referenced.</P>

<p class="docText">Numerous capabilities normally provided by <span class="docEmphasis">gdb</span>
are not available when you are working with the kernel. For example,
<span class="docEmphasis">gdb</span> is not able to modify kernel data; it
expects to be running a program to be debugged under its own control
before playing with its memory image. It is also not possible to set
breakpoints or watchpoints, or to single-step through kernel
functions.</p>

<p class="docText">Note that, in order to have symbol information available for
<span class="docEmphasis">gdb</span>, you must compile your kernel with the
<tt>CONFIG_DEBUG_INFO</tt> option set. The result is a far
larger kernel image on disk, but, without that information, digging
through kernel variables is almost impossible.</p>

<p class="docText">With the debugging information available, you can learn a lot about
what is going on inside the kernel. <span class="docEmphasis">gdb</span> happily
prints out structures, follows pointers, etc. One thing that is
harder, however, is examining modules. Since modules are not part of
the <i>vmlinux</i> image passed to
<span class="docEmphasis">gdb</span>, the debugger knows nothing about them.
Fortunately, as of kernel 2.6.7, it is possible to teach
<span class="docEmphasis">gdb</span> what it needs to know to examine loadable
modules.</P>

<p class="docText">Linux loadable modules are ELF-format executable images; as such,
they have been divided up into numerous sections. A typical module
can contain a dozen or more sections, but there are typically three
that are relevant in a debugging session:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">.text</span></span></span></dt></p>
<dd>
<p class="docList">This section contains the executable code for the module. The
debugger must know where this section is to be able to give
tracebacks or set breakpoints. (Neither of these operations is
relevant when running the debugger on
<i>/proc/kcore</I>, but they can useful when working
with <span class="docEmphasis">kgdb</span>, described below).</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">.bss</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">.data</span></span></span></dt></p>
<dd>
<p class="docList">These two sections hold the module's variables. Any
variable that is not initialized at compile time ends up in
<tt>.bss</tt>, while those that are initialized go into
<tt>.data</tt>.</p>
</dd>
</dl>

<p class="docText">Making <span class="docEmphasis">gdb</span> work with loadable modules requires
informing the debugger about where a given module's
sections have been loaded. That information is available in sysfs,
under <i>/sys/module</i>. For example, after loading
the <span class="docEmphasis">scull</span> module, the directory
<i>/sys/module/scull/sections</i> contains files with
names such as <i>.text</i>; the content of each file is
the base address for that section.</p>

<p class="docText">We are now in a position to issue a <span class="docEmphasis">gdb</span> command
telling it about our module. The command we need is
<tt>add-symbol-file</tt>; this command takes as parameters
the name of the module object file, the <I>.text</i>
base address, and a series of optional parameters describing where
any other sections of interest have been put. After digging through
the module section data in sysfs, we can construct a command such as:</P>

<pre>(gdb) <B>add-symbol-file .../scull.ko 0xd0832000 \</b>
        <b>-s .bss 0xd0837100 \</b>
<b>        -s .data 0xd0836be0</b></pre><br>


<p class="docText">We have included a small script in the sample source
(<span class="docEmphasis">gdbline</span>) that can create this command for a
given module.</P>

<p class="docText">We can now use <span class="docEmphasis">gdb</span> to examine variables in our
loadable module. Here is a quick example taken from a
<span class="docEmphasis">scull</span> debugging session:</p>

<pre>(gdb) <B>add-symbol-file scull.ko 0xd0832000 \</b>
      <B>-s .bss 0xd0837100 \</b>
<B>      -s .data 0xd0836be0</b>
add symbol table from file "scull.ko" at
        .text_addr = 0xd0832000
        .bss_addr = 0xd0837100
        .data_addr = 0xd0836be0
(y or n) <b>y</b>
Reading symbols from scull.ko...done.
(gdb) <b>p scull_devices[0]</b>
$1 = {data = 0xcfd66c50, 
      quantum = 4000, 
      qset = 1000, 
      size = 20881,
      access_key = 0, 
      ...}</pre><br>


<p class="docText">Here we see that the first <span class="docEmphasis">scull</span> device
currently holds 20,881 bytes. If we wanted, we could follow the
<tt>data</tt> chain, or look at anything else of interest
in the module.</p>

<p class="docText">One other useful trick worth knowing about is this:</P>

<pre>(gdb) <B>print *(address)</b></pre><BR>


<p class="docText">Here, fill in a hex address for <tt>address</tt>; the
output is a file and line number for the code corresponding to that
address. This technique may be useful, for example, to find out where
a function pointer really points.</p>

<p class="docText">We still cannot perform typical debugging tasks like setting
breakpoints or modifying data; to perform those operations, we need
to use a tool like <span class="docEmphasis">kdb</span> (described next) or
<span class="docEmphasis">kgdb</span> (which we get to shortly).</P>


<a name="chp-4-sect-6.2"></a>
<H4 class="docSection2Title">4.6.2. The kdb Kernel Debugger</h4>

<p class="docText">Many readers may be wondering why the kernel does not have any more
advanced debugging features built into it. The answer, quite simply,
is that Linus does not believe in interactive debuggers. He fears
that they lead to poor fixes, those which patch up symptoms rather
than addressing the real cause of problems. Thus, no built-in
debuggers.</p>

<p class="docText">Other kernel developers, however, see an occasional use for
interactive debugging tools. One such tool is the
<span class="docEmphasis">kdb</span> built-in kernel debugger, available as a
nonofficial patch from <span class="docEmphasis">oss.sgi.com</span>. To use
<span class="docEmphasis">kdb</span>, you must obtain the patch (be sure to get a
version that matches your kernel version), apply it, and rebuild and
reinstall the kernel. Note that, as of this writing,
<span class="docEmphasis">kdb</span> works only on IA-32 (x86) systems (though a
version for the IA-64 existed for a while in the mainline kernel
source before being removed).</p>

<p class="docText">Once you are running a <span class="docEmphasis">kdb</span>-enabled kernel, there
are a couple of ways to enter the debugger. Pressing the Pause (or
Break) key on the console starts up the debugger.
<span class="docEmphasis">kdb</span> also starts up when a kernel oops happens or
when a breakpoint is hit. In any case, you see a message that looks
something like this:</p>

<pre>Entering kdb (0xc0347b80) on processor 0 due to Keyboard Entry
[0]kdb&gt;</pre><BR>


<p class="docText">Note that just about everything the kernel does stops when
<span class="docEmphasis">kdb</span> is running. Nothing else should be running
on a system where you invoke <span class="docEmphasis">kdb</span>; in particular,
you should not have networking turned on—unless, of course, you
are debugging a network driver. It is generally a good idea to boot
the system in single-user mode if you will be using
<span class="docEmphasis">kdb</span>.</p>

<p class="docText">As an example, consider a quick <span class="docEmphasis">scull</span> debugging
session. Assuming that the driver is already loaded, we can tell
<span class="docEmphasis">kdb</span> to set a breakpoint in
<span class="docEmphasis">scull_read</span> as follows:</p>

<pre>[0]kdb&gt; <B>bp scull_read</b>
Instruction(i) BP #0 at 0xcd087c5dc (scull_read)
    is enabled globally adjust 1
[0]kdb&gt; <b>go</b></pre><br>


<p class="docText">The <span class="docEmphasis">bp</span> command tells <span class="docEmphasis">kdb</span> to
stop the next time the kernel enters <span class="docEmphasis">scull_read</span>.
You then type <tt><B>go</b></tt> to continue execution. After
putting something into one of the <span class="docEmphasis">scull</span> devices,
we can attempt to read it by running <span class="docEmphasis">cat</span> under a
shell on another terminal, yielding the following:</p>

<pre>Instruction(i) breakpoint #0 at 0xd087c5dc (adjusted)
0xd087c5dc scull_read:          int3

Entering kdb (current=0xcf09f890, pid 1575) on processor 0 due to
Breakpoint @ 0xd087c5dc
[0]kdb&gt;</pre><BR>


<p class="docText">We are now positioned at the beginning of
<span class="docEmphasis">scull_read</span>. To see how we got there, we can get
a stack trace:</p>

<pre>[0]kdb&gt; <b>bt</b>
    ESP    EIP        Function (args)
0xcdbddf74 0xd087c5dc [scull]scull_read
0xcdbddf78 0xc0150718 vfs_read+0xb8
0xcdbddfa4 0xc01509c2 sys_read+0x42
0xcdbddfc4 0xc0103fcf syscall_call+0x7
[0]kdb&gt;</pre><br>


<p class="docText"><span class="docEmphasis">kdb</span> attempts to print out the arguments to every
function in the call trace. It gets confused, however, by
optimization tricks used by the compiler. Therefore, it fails to
print the arguments to <span class="docEmphasis">scull_read</span>.</p>

<p class="docText">Time to look at some data. The <span class="docEmphasis">mds</span> command
manipulates data; we can query the value of the
<tt>scull_devices</tt> pointer with a command such as:</p>

<pre>[0]kdb&gt; <b>mds scull_devices 1</b>
0xd0880de8 cf36ac00    ....</pre><br>


<p class="docText">Here we asked for one (4-byte) word of data starting at the location
of <tt>scull_devices</tt>; the answer tells us that our
device array is at the address <tt>0xd0880de8</tt>; the
first device structure itself is at <tt>0xcf36ac00</tt>. To
look at that device structure, we need to use that address:</p>

<pre>[0]kdb&gt; <b>mds cf36ac00</b>
0xcf36ac00 ce137dbc ....
0xcf36ac04 00000fa0 ....
0xcf36ac08 000003e8 ....
0xcf36ac0c 0000009b ....
0xcf36ac10 00000000 ....
0xcf36ac14 00000001 ....
0xcf36ac18 00000000 ....
0xcf36ac1c 00000001 ....</pre><br>


<p class="docText">The eight lines here correspond to the beginning part of the
<tt>scull_dev</tt> structure. Therefore, we see that the
memory for the first device is allocated at
<tt>0xce137dbc</tt>, the quantum is 4000 (hex
<tt>fa0</tt>), the quantum set size is 1000 (hex
<tt>3e8</tt>), and there are currently 155 (hex
<tt>9b</tt>) bytes stored in the device.</p>

<p class="docText"><span class="docEmphasis">kdb</span> can change data as well. Suppose we wanted
to trim some of the data from the device:</p>

<pre>[0]kdb&gt;<b> mm cf26ac0c 0x50</b>
0xcf26ac0c = 0x50</pre><BR>


<p class="docText">A subsequent <span class="docEmphasis">cat</span> on the device will now return
less data than before.</p>

<p class="docText"><span class="docEmphasis">kdb</span> has a number of other capabilities,
including single-stepping (by instructions, not lines of C source
code), setting breakpoints on data access, disassembling code,
stepping through linked lists, accessing register data, and more.
After you have applied the <span class="docEmphasis">kdb</span> patch, a full set
of manual pages can be found in the
<I>Documentation/kdb</I> directory in your kernel
source tree.</p>


<a name="chp-4-sect-6.3"></a>
<h4 class="docSection2Title">4.6.3. The kgdb Patches</h4>

<p class="docText"><a name="chp-4-ITERM-4925"></a><a name="chp-4-ITERM-4926"></a><a name="chp-4-ITERM-4927"></a><a name="chp-4-ITERM-4928"></a>The two interactive debugging
approaches we have looked at so far (using <span class="docEmphasis">gdb</span>
on <I>/proc/kcore</i> and <span class="docEmphasis">kdb</span>)
both fall short of the sort of environment that user-space
application developers have become used to. Wouldn't
it be nice if there were a true debugger for the kernel that
supported features like changing variables, breakpoints, etc.?</P>

<p class="docText">As it turns out, such a solution does exist. There are, as of this
writing, two separate patches in circulation that allow
<span class="docEmphasis">gdb</span>, with full capabilities, to be run against
the kernel. Confusingly, both of these patches are called
<span class="docEmphasis">kgdb</span>. They work by separating the system running
the test kernel from the system running the debugger; the two are
typically connected via a serial cable. Therefore, the developer can
run <span class="docEmphasis">gdb</span> on his or her stable desktop system,
while operating on a kernel running on a sacrificial test box.
Setting up <span class="docEmphasis">gdb</span> in this mode takes a little time
at the outset, but that investment can pay off quickly when a
difficult bug shows up.</P>

<p class="docText">These patches are in a strong state of flux, and may even be merged
at some point, so we avoid saying much about them beyond where they
are and their basic features. Interested readers are encouraged to
look and see the current state of affairs.</P>

<p class="docText">The first <span class="docEmphasis">kgdb</span> patch is currently found in the
<tt>-mm</tt> kernel tree—the staging area for patches
on their way into the 2.6 mainline. This version of the patch
supports the x86, SuperH, ia64, x86_64, SPARC, and 32-bit PPC
architectures. In addition to the usual mode of operation over a
serial port, this version of <span class="docEmphasis">kgdb</span> can also
communicate over a local-area network. It is simply a matter of
enabling the Ethernet mode and booting with the
<tt>kgdboe</tt> parameter set to indicate the IP address
from which debugging commands can originate. The documentation under
<i>Documentation/i386/kgdb</i> describes how to set
things up.<sup class="docFootnote"><a class="docLink" href="chp-4-sect-6.shtml#chp-4-FNOTE-4">[4]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="chp-4-FNOTE-4">[4]</a></sup> It does neglect to point out that you
should have your network adapter driver built into the kernel,
however, or the debugger fails to find it at boot time and will shut
itself down.</p></blockquote>

<p class="docText">As an alternative, you can use the <span class="docEmphasis">kgdb</span> patch
found on <a class="docLink" target="_blank" href="http://kgdb.sf.net/">http://kgdb.sf.net/</a>.
This version of the debugger does not support the network
communication mode (though that is said to be under development), but
it does have some built-in support for working with loadable modules.
It supports the x86, x86_64, PowerPC, and S/390 architectures.</P>


<a name="chp-4-sect-6.4"></a>
<H4 class="docSection2Title">4.6.4. The User-Mode Linux Port</H4>

<p class="docText"><a name="chp-4-ITERM-4929"></a><a name="chp-4-ITERM-4930"></a>User-Mode Linux (UML) is an interesting
concept. It is structured as a separate port of the Linux kernel with
its own <i>arch/um</I> subdirectory. It does not run on
a new type of hardware, however; instead, it runs on a virtual
machine implemented on the Linux system call interface. Thus, UML
allows the Linux kernel to run as a separate, user-mode process on a
Linux system.</P>

<p class="docText">Having a copy of the kernel running as a user-mode process brings a
number of advantages. Because it is running on a constrained, virtual
processor, a buggy kernel cannot damage the
"real" system. Different hardware
and software configurations can be tried easily on the same box. And,
perhaps most significantly for kernel developers, the user-mode
kernel can be easily manipulated with <span class="docEmphasis">gdb</span> or
another debugger. After all, it is just another process. UML clearly
has the potential to accelerate kernel development.</p>

<p class="docText">However, UML has a big shortcoming from the point of view of driver
writers: the user-mode kernel has no access to the host
system's hardware. Thus, while it can be useful for
debugging most of the sample drivers in this book, UML is not yet
useful for debugging drivers that have to deal with real hardware.</p>

<p class="docText">See <a class="docLink" target="_blank" href="http://user-mode-linux.sf.net/">http://user-mode-linux.sf.net/</a> for more
information on UML.</p>


<a name="chp-4-sect-6.5"></a>
<h4 class="docSection2Title">4.6.5. The Linux Trace Toolkit</H4>

<p class="docText"><a name="chp-4-ITERM-4931"></a><a name="chp-4-ITERM-4932"></a><a name="chp-4-ITERM-4933"></a><a name="chp-4-ITERM-4934"></a>
<a name="chp-4-ITERM-4935"></a>The
Linux Trace Toolkit (LTT) is a kernel patch and a set of related
utilities that allow the tracing of events in the kernel. The trace
includes timing information and can create a reasonably complete
picture of what happened over a given period of time. Thus, it can be
used not only for debugging but also for tracking down performance
problems.</p>

<p class="docText">LTT, along with extensive documentation, can be found at
<span class="docEmphasis">http</span>://<span class="docEmphasis">www.opersys.com/LTT</span>.</p>


<a name="chp-4-sect-6.6"></a>
<H4 class="docSection2Title">4.6.6. Dynamic Probes</h4>

<p class="docText"><a name="chp-4-ITERM-4936"></a><a name="chp-4-ITERM-4937"></a><a name="chp-4-ITERM-4938"></a>Dynamic Probes (or DProbes) is a
debugging tool released (under the GPL) by IBM for Linux on the IA-32
architecture. It allows the placement of a
"probe" at almost any place in the
system, in both user and kernel space. The probe consists of some
code (written in a specialized, stack-oriented language) that is
executed when control hits the given point. This code can report
information back to user space, change registers, or do a number of
other things. The useful feature of DProbes is that once the
capability has been built into the kernel, probes can be inserted
anywhere within a running system without kernel builds or reboots.
DProbes can also work with the LTT to insert new tracing events at
arbitrary locations.</p>

<p class="docText">The DProbes <a name="chp-4-ITERM-4939"></a> <a name="chp-4-ITERM-4940"></a>tool can be downloaded from
IBM's open source site:
<span class="docEmphasis">http</span>://<span class="docEmphasis">oss.software.ibm.com</span>.</P>



<ul></UL></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-4-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
