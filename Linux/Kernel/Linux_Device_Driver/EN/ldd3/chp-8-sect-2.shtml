<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>8.2. Lookaside Caches</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-8-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-8-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-8-sect-2"></a>
<h3 class="docSection1Title" >8.2. Lookaside Caches</h3>

<p class="docText">A device driver often ends up <a name="chp-8-ITERM-5703"></a> <a name="chp-8-ITERM-5704"></a> <a name="chp-8-ITERM-5705"></a> <a name="chp-8-ITERM-5706"></a>allocating
many objects of the same size, over and over. Given that the kernel
already maintains a set of memory pools of objects that are all the
same size, why not add some special pools for these high-volume
objects? In fact, the kernel does implement a facility to create this
sort of pool, which is often called a <span class="docEmphasis">lookaside
cache</span>. Device drivers normally do not exhibit the sort of
memory behavior that justifies using a lookaside cache, but there can
be exceptions; the USB and SCSI drivers in Linux 2.6 use caches.</p>

<p class="docText"><a name="chp-8-ITERM-5707"></a>
<a name="chp-8-ITERM-5708"></a><a name="chp-8-ITERM-5709"></a>
<a name="chp-8-ITERM-5710"></a>The
cache manager in the Linux kernel is sometimes called the
"slab allocator." For that reason,
its functions and types are declared in
<I>&lt;linux/slab.h&gt;</i>. The slab allocator
implements caches that have a type of
<tt>kmem_cache_t</tt>; they are created with a call to
<span class="docEmphasis">kmem_cache_create</span>:</P>

<pre>kmem_cache_t *kmem_cache_create(const char *name, size_t size,
                                size_t offset, 
                                unsigned long flags,
                                void (*constructor)(void *, kmem_cache_t *,
                                                    unsigned long flags),
                                void (*destructor)(void *, kmem_cache_t *,
                                                   unsigned long flags));</pre><BR>


<p class="docText">The function creates a new cache object that can host any number of
memory areas all of the same size, specified by the
<tt>size</tt> argument. The <tt>name</tt>
argument is associated with this cache and functions as housekeeping
information usable in tracking problems; usually, it is set to the
name of the type of structure that is cached. The cache keeps a
pointer to the name, rather than copying it, so the driver should
pass in a pointer to a name in static storage (usually the name is
just a literal string). The name cannot contain blanks.</P>

<p class="docText">The <tt>offset</tt> is the offset of the first object in
the page; it can be used to ensure a particular alignment for the
allocated objects, but you most likely will use <tt>0</tt>
to request the default value. <tt>flags</tt> controls how
allocation is done and is a bit mask of the following flags:</p>

<a name="chp-8-ITERM-5711"></a><a name="chp-8-ITERM-5712"></a><a name="chp-8-ITERM-5713"></a><a name="chp-8-ITERM-5714"></a><a name="chp-8-ITERM-5715"></a><a name="chp-8-ITERM-5716"></a><a name="chp-8-ITERM-5717"></a><a name="chp-8-ITERM-5718"></a><a name="chp-8-ITERM-5719"></a><a name="chp-8-ITERM-5720"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SLAB_NO_REAP</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-8-ITERM-5711"></a>
<a name="chp-8-ITERM-5712"></a>Setting
this flag protects the cache from being reduced when the system is
looking for memory. Setting this flag is normally a bad idea; it is
important to avoid restricting the memory
allocator's freedom of action unnecessarily.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SLAB_HWCACHE_ALIGN</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-8-ITERM-5713"></a>
<a name="chp-8-ITERM-5714"></a>This
flag requires each data object to
be<a name="chp-8-ITERM-5715"></a>
<a name="chp-8-ITERM-5716"></a>
<a name="chp-8-ITERM-5717"></a>
aligned to a cache line; actual alignment depends on the cache layout
of the host platform. This option can be a good choice if your cache
contains items that are frequently accessed on SMP machines. The
padding required to achieve cache line alignment can end up wasting
significant amounts of memory, however.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SLAB_CACHE_DMA</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-8-ITERM-5718"></a>
<a name="chp-8-ITERM-5719"></a><a name="chp-8-ITERM-5720"></a>This flag requires each data object to be
allocated in the DMA memory zone.</p>
</dd>
</dl>

<p class="docText">There is also a set of flags that can be used during the debugging of
cache allocations; see <i>mm/slab.c</I> for the
details. Usually, however, these flags are set globally via a kernel
configuration option on systems used for development.</p>

<p class="docText"><a name="chp-8-ITERM-5721"></a>
<a name="chp-8-ITERM-5722"></a><a name="chp-8-ITERM-5723"></a>The
<tt>constructor</tt> and <tt>destructor</tt>
arguments to the function are optional functions (but there can be no
destructor without a constructor); the former can be used to
initialize newly allocated objects, and the latter can be used to
"clean up" objects prior to their
memory being released back to the system as a whole.</p>

<p class="docText"><a name="chp-8-ITERM-5724"></a>Constructors and destructors can be useful,
but there are a few constraints that you should keep in mind. A
constructor is called when the memory for a set of objects is
allocated; because that memory may hold several objects, the
constructor may be called multiple times. You cannot assume that the
constructor will be called as an immediate effect of allocating an
object. Similarly, destructors can be called at some unknown future
time, not immediately after an object has been freed. Constructors
and destructors may or may not be allowed to sleep, according to
whether they are passed the <tt>SLAB_CTOR_ATOMIC</tt> flag
(where <tt>CTOR</tt> is short for
<span class="docEmphasis">constructor</span>).</P>

<p class="docText"><a name="chp-8-ITERM-5725"></a>
<a name="chp-8-ITERM-5726"></a>For
convenience, a programmer can use the same function for both the
constructor and destructor; the slab allocator always passes the
<tt>SLAB_CTOR_CONSTRUCTOR</tt> flag when the callee is a
constructor.</p>

<p class="docText"><a name="chp-8-ITERM-5727"></a>
<a name="chp-8-ITERM-5728"></a>Once
a cache of objects is created, you can allocate objects from it by
calling <span class="docEmphasis">kmem_cache_alloc</span>:</p>

<pre>void *kmem_cache_alloc(kmem_cache_t *cache, int flags);</pre><BR>


<p class="docText">Here, the
<tt>cache</tt><a name="chp-8-ITERM-5729"></a>
<a name="chp-8-ITERM-5730"></a>
argument is the cache you have created previously; the flags are the
same as you would pass to <span class="docEmphasis">kmalloc</span> and are
consulted if <span class="docEmphasis">kmem_cache_alloc</span> needs to go out
and allocate more memory itself.</p>

<p class="docText">To free an object, use <span class="docEmphasis">kmem_cache_free</span>:</P>

<pre> void kmem_cache_free(kmem_cache_t *cache, const void *obj);</pre><br>


<p class="docText">When driver code is finished with the cache, typically when the
module is unloaded, it should free its cache as follows:</p>

<pre> int kmem_cache_destroy(kmem_cache_t *cache);</pre><br>


<p class="docText">The destroy operation succeeds only if all objects allocated from the
cache have been returned to it. Therefore, a module should check the
return status from <span class="docEmphasis">kmem_cache_destroy</span>; a failure
indicates some sort of memory leak within the module (since some of
the objects have been dropped).</p>

<p class="docText"><a name="chp-8-ITERM-5731"></a><a name="chp-8-ITERM-5732"></a>One
side benefit to using lookaside caches is that the kernel maintains
statistics on cache usage. These statistics may be obtained from
<i>/proc/slabinfo</i>.</p>

<a name="chp-8-sect-2.1"></a>
<h4 class="docSection2Title">8.2.1. A scull Based on the Slab Caches: scullc</h4>

<p class="docText"><a name="chp-8-ITERM-5733"></a>
<a name="chp-8-ITERM-5734"></a>Time for an example.
<span class="docEmphasis">scullc</span> is a cut-down version of the
<span class="docEmphasis">scull</span> module that implements only the bare
device—the persistent memory region. Unlike
<span class="docEmphasis">scull</span>, which uses <span class="docEmphasis">kmalloc</span>,
<span class="docEmphasis">scullc</span> uses memory caches. The size of the
quantum can be modified at compile time and at load time, but not at
runtime—that would require creating a new memory cache, and we
didn't want to deal with these unneeded details.</p>

<p class="docText"><span class="docEmphasis">scullc</span> is a complete example that can be used to
try out the slab allocator. It differs from
<span class="docEmphasis">scull</span> only in a few lines of code. First, we
must declare our own slab cache:</p>

<pre>/* declare one cache pointer: use it for all devices */
kmem_cache_t *scullc_cache;</pre><br>


<p class="docText">The creation of the slab cache is handled (at module load time) in
this way:</p>

<pre>/* scullc_init: create a cache for our quanta */
scullc_cache = kmem_cache_create("scullc", scullc_quantum,
        0, SLAB_HWCACHE_ALIGN, NULL, NULL); /* no ctor/dtor */
if (!scullc_cache) {
    scullc_cleanup(  );
    return -ENOMEM;
}</pre><BR>


<p class="docText">This is how it allocates memory quanta:</p>

<pre>/* Allocate a quantum using the memory cache */
if (!dptr-&gt;data[s_pos]) {
    dptr-&gt;data[s_pos] = kmem_cache_alloc(scullc_cache, GFP_KERNEL);
    if (!dptr-&gt;data[s_pos])
        goto nomem;
    memset(dptr-&gt;data[s_pos], 0, scullc_quantum);
}</pre><BR>


<p class="docText">And these lines release memory:</P>

<pre>for (i = 0; i &lt; qset; i++)
if (dptr-&gt;data[i])
        kmem_cache_free(scullc_cache, dptr-&gt;data[i]);</pre><br>


<p class="docText">Finally, at module unload time, we have to return the cache to the
system:</p>

<pre>/* scullc_cleanup: release the cache of our quanta */
if (scullc_cache)
    kmem_cache_destroy(scullc_cache);</pre><br>


<p class="docText">The main differences in passing from <span class="docEmphasis">scull</span> to
<span class="docEmphasis">scullc</span> are a slight speed improvement and better
memory use. Since quanta are allocated from a pool of memory
fragments of exactly the right size, their placement in memory is as
dense as possible, as opposed to <span class="docEmphasis">scull</span> quanta,
which bring in an unpredictable memory fragmentation.</P>


<a name="chp-8-sect-2.2"></a>
<h4 class="docSection2Title">8.2.2. Memory Pools</H4>

<p class="docText">There are places in
the<a name="chp-8-ITERM-5735"></a>
<a name="chp-8-ITERM-5736"></a>
kernel where memory allocations cannot be allowed to fail. As a way
of guaranteeing allocations in those situations, the kernel
developers created an abstraction known as a <I>memory
pool</I> (or "mempool"). A
memory pool is really just a form of a lookaside cache that tries to
always keep a list of free memory around for use in emergencies.</p>

<p class="docText">A memory pool has a type of <tt>mempool_t</tt> (defined in
<i>&lt;linux/mempool.h&gt;</i>); you can create one
with <span class="docEmphasis">mempool_create</span>:</p>

<pre>mempool_t *mempool_create(int min_nr, 
                          mempool_alloc_t *alloc_fn,
                          mempool_free_t *free_fn, 
                          void *pool_data);</pre><BR>


<p class="docText">The <tt>min_nr</tt> argument is the minimum number of
allocated objects that the pool should always keep around. The actual
allocation and freeing of objects is handled by
<tt>alloc_fn</tt> and <tt>free_fn</tt>, which
have these prototypes:</P>

<pre>typedef void *(mempool_alloc_t)(int gfp_mask, void *pool_data);
typedef void (mempool_free_t)(void *element, void *pool_data);</pre><BR>


<p class="docText">The final parameter to <span class="docEmphasis">mempool_create</span>
(<tt>pool_data</tt>) is passed to
<tt>alloc_fn</tt> and <tt>free_fn</tt>.</p>

<p class="docText">If need be, you can write special-purpose functions to handle memory
allocations for mempools. Usually, however, you just want to let the
kernel slab allocator handle that task for you. There are two
functions (<span class="docEmphasis">mempool_alloc_slab</span> and
<span class="docEmphasis">mempool_free_slab</span>) that perform the impedance
matching between the memory pool allocation prototypes and
<span class="docEmphasis">kmem_cache_alloc</span> and
<span class="docEmphasis">kmem_cache_free</span>. Thus, code that sets up memory
pools often looks like the following:</P>

<pre>cache = kmem_cache_create(. . .);
pool = mempool_create(MY_POOL_MINIMUM,
                      mempool_alloc_slab, mempool_free_slab,
                      cache);</pre><BR>


<p class="docText">Once the pool has been created, objects can be allocated and freed
with:</p>

<pre>void *mempool_alloc(mempool_t *pool, int gfp_mask);
void mempool_free(void *element, mempool_t *pool);</pre><br>


<p class="docText">When the mempool is created, the allocation function will be called
enough times to create a pool of preallocated objects. Thereafter,
calls to <span class="docEmphasis">mempool_alloc</span> attempt to acquire
additional objects from the allocation function; should that
allocation fail, one of the preallocated objects (if any remain) is
returned. When an object is freed with
<span class="docEmphasis">mempool_free</span>, it is kept in the pool if the
number of preallocated objects is currently below the minimum;
otherwise, it is to be returned to the system.</p>

<p class="docText">A mempool can be resized with:</p>

<pre>int mempool_resize(mempool_t *pool, int new_min_nr, int gfp_mask);</pre><BR>


<p class="docText">This call, if successful, resizes the pool to have at least
<tt>new_min_nr</tt> objects.</p>

<p class="docText">If you no longer need a memory pool, return it to the system with:</p>

<pre>void mempool_destroy(mempool_t *pool);</pre><BR>


<p class="docText">You must return all allocated objects before destroying the mempool,
or a kernel oops results.</p>

<p class="docText">If you are considering using a mempool in your driver, please keep
one thing in mind: mempools allocate a chunk of memory that sits in a
list, idle and unavailable for any real use. It is easy to consume a
great deal of memory with mempools. In almost every case, the
preferred alternative is to do without the mempool and simply deal
with the possibility of allocation failures instead. If there is any
way for your driver to respond to an allocation failure in a way that
does not endanger the integrity of the system, do things that way.
Use of mempools in driver code should be rare.</p>



<UL></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-8-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-8-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
