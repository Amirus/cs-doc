<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>15.4. Direct Memory Access</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-15-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-15-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-15-sect-4"></a>
<a name="chp-15-ITERM-7134"></a><h3 class="docSection1Title">15.4. Direct Memory Access</h3>

<p class="docText"><a name="chp-15-ITERM-7135"></a>Direct memory access, or DMA<a name="chp-15-ITERM-7136"></a>
<a name="chp-15-ITERM-7137"></a>
<a name="chp-15-ITERM-7138"></a> <a name="chp-15-ITERM-7139"></a> <a name="chp-15-ITERM-7140"></a>
<a name="chp-15-ITERM-7141"></a>, is the advanced topic that completes our
overview of memory issues. DMA is the
<a name="chp-15-ITERM-7142"></a>hardware
mechanism that allows peripheral components to transfer their I/O
data directly to and from main memory without the need to involve the
system processor. Use of this mechanism can greatly increase
throughput to and from a device, because a great deal of
computational overhead is eliminated.</p>

<a name="chp-15-sect-4.1"></a>
<h4 class="docSection2Title">15.4.1. Overview of a DMA Data Transfer</h4>

<p class="docText">Before introducing the programming details, let's
review how a DMA transfer takes place, considering only input
transfers to simplify the discussion.</p>

<p class="docText">Data transfer can be triggered in two ways: either the software asks
for data (via a function such as <span class="docEmphasis">read</span>) or the
hardware asynchronously pushes data to the system.</p>

<p class="docText">In the first case, the steps involved can be summarized as follows:</p>

<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">When a process calls <span class="docEmphasis">read</span>, the driver method
allocates a DMA buffer and instructs the hardware to transfer its
data into that buffer. The process is put to sleep.</p></div></li><li><div style="font-weight:normal"><p class="docList">The hardware writes data to the DMA buffer and raises an interrupt
when it's done.</P></div></li><LI><div style="font-weight:normal"><p class="docList">The interrupt handler gets the input data, acknowledges the
interrupt, and awakens the process, which is now able to read data.</P></div></li></ol></div>
<p class="docText"><a name="chp-15-ITERM-7143"></a>The second
case comes about when DMA is used asynchronously. This happens, for
example, with data acquisition devices that go on pushing data even
if nobody is reading them. In this case, the driver should maintain a
buffer so that a subsequent <span class="docEmphasis">read</span> call will
return all the accumulated data to user space. The steps involved in
this kind of transfer are slightly different:</p>

<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">The hardware raises an interrupt to announce that new data has
arrived.</P></div></li><LI><div style="font-weight:normal"><p class="docList">The interrupt handler allocates a buffer and tells the hardware where
to transfer its data.</P></div></LI><li><div style="font-weight:normal"><p class="docList">The peripheral device writes the data to the buffer and raises
another interrupt when it's done.</p></div></li><li><div style="font-weight:normal"><p class="docList">The handler dispatches the new data, wakes any relevant process, and
takes care of housekeeping.</P></div></LI></ol></div>
<p class="docText"><a name="chp-15-ITERM-7144"></a>
<a name="chp-15-ITERM-7145"></a>
<a name="chp-15-ITERM-7146"></a>A variant of the asynchronous approach
is often seen with network cards. These cards often expect to see a
<a name="chp-15-ITERM-7147"></a>circular buffer (often called a
<I>DMA ring buffer</i>) established in memory shared
with the processor; each incoming packet is placed in the next
available buffer in the ring, and an interrupt is signaled. The
driver then passes the network packets to the rest of the kernel and
places a new DMA buffer in the ring.</P>

<p class="docText">The processing steps in all of these cases emphasize that efficient
DMA handling relies on interrupt reporting. While it is possible to
implement DMA with a polling driver, it wouldn't
make sense, because a polling driver would waste the performance
benefits that DMA offers over the easier processor-driven
I/O.<sup class="docFootnote"><a class="docLink" href="chp-15-sect-4.shtml#chp-15-FNOTE-4">[4]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="chp-15-FNOTE-4">[4]</a></sup> There are, of course, exceptions to everything;
see <a class="docLink" href="chp-15-sect-2.shtml#chp-15-sect-2.6">Section 15.2.6</a> 
for a demonstration of how
high-performance network drivers are best implemented using
polling.</p></blockquote>

<p class="docText">Another relevant item introduced here is the DMA buffer. DMA requires
device drivers to allocate one or more special buffers suited to DMA.
Note that many drivers allocate their buffers at initialization time
and use them until shutdown—the word
<span class="docEmphasis">allocate</span> in the previous lists, therefore, means
"get hold of a previously allocated
buffer."</p>


<a name="chp-15-sect-4.2"></a>
<h4 class="docSection2Title">15.4.2. Allocating the DMA Buffer</h4>

<p class="docText">This section covers the allocation
<a name="chp-15-ITERM-7148"></a>of DMA buffers at a
low level; we introduce a higher-level interface shortly, but it is
still a good idea to understand the material presented here.</P>

<p class="docText">The main issue that arrises with DMA buffers is that, when they are
bigger than one page, they must occupy contiguous pages in physical
memory because the device transfers data using the ISA or PCI system
bus, both of which carry physical addresses. It's
interesting to note that this constraint doesn't
apply to the SBus (see <a class="docLink" href="chp-12-sect-5.shtml#chp-12-sect-5">Section 12.5</a>),
which uses
virtual addresses on the peripheral bus. Some architectures
<span class="docEmphasis">can</span> also use virtual addresses on the PCI bus,
but a portable driver cannot count on that capability.</p>

<p class="docText">Although DMA buffers can be allocated either at system boot or at
runtime, modules can allocate their buffers only at runtime. 
Driver
writers must take care to allocate the right kind of memory when it
is used for DMA operations; not all memory zones are suitable. In
particular, high memory may not work for DMA on some systems and with
some devices—the peripherals simply cannot work with addresses
that high.</p>

<p class="docText">Most devices on modern buses can handle 32-bit addresses, meaning
that normal memory allocations work just fine for them. Some PCI
devices, however, fail to implement the full PCI standard and cannot
work with 32-bit addresses. And ISA devices, of course, are limited
to 24-bit addresses only.</P>

<p class="docText">For devices with this kind of limitation, memory should be allocated
from the DMA zone by adding the <tt>GFP_DMA</tt> flag to
the <span class="docEmphasis">kmalloc</span> or
<span class="docEmphasis">get_free_pages</span> call. When this flag is present,
only memory that can be addressed with 24 bits is allocated.
Alternatively, you can use the generic DMA layer (which we discuss
shortly) to allocate buffers that work around your
device's limitations.</p>

<a name="chp-15-sect-4.2.1"></a>
<h5 class="docSection3Title">15.4.2.1 Do-it-yourself allocation</H5>

<p class="docText"><a name="chp-15-ITERM-7149"></a>
<a name="chp-15-ITERM-7150"></a><a name="chp-15-ITERM-7151"></a>
<a name="chp-15-ITERM-7152"></a>
<a name="chp-15-ITERM-7153"></a>We
have seen how <span class="docEmphasis">get_free_pages</span> can allocate up to
a few megabytes (as order can range up to
<tt>MAX_ORDER</tt>, currently 11), but high-order requests
are prone to fail even when the requested buffer is far less than 128
KB, because system memory becomes fragmented over time.<sup class="docFootnote"><a class="docLink" href="chp-15-sect-4.shtml#chp-15-FNOTE-5">[5]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="chp-15-FNOTE-5">[5]</a></sup> The word <I>fragmentation</i> is usually
applied to disks to express the idea that files are not stored
consecutively on the magnetic medium. The same concept applies to
memory, where each virtual address space gets scattered throughout
physical RAM, and it becomes difficult to retrieve consecutive free
pages when a DMA buffer is requested.</p></blockquote>

<p class="docText">When the kernel cannot return the requested amount of memory or when
you need more than 128 KB (a common requirement for PCI frame
grabbers, for example), an alternative to returning
<tt>-ENOMEM</tt> is to allocate memory at boot time or
reserve the top of physical RAM for your buffer. We described
allocation at boot time in <a class="docLink" href="chp-8-sect-6.shtml#chp-8-sect-6">Section 8.6</a>,
but it is not available to
modules. Reserving the top of RAM is accomplished by passing a
<tt>mem=</tt> argument to the kernel at boot time. For
example, if you have 256 MB, the argument <tt>mem=255M</tt>
keeps the kernel from using the top megabyte. Your module could later
use the following code to gain access to such memory:</p>

<pre>dmabuf = ioremap (0xFF00000 /* 255M */, 0x100000 /* 1M */);</pre><br>


<p class="docText">The <span class="docEmphasis">allocator</span>, part of the sample code
accompanying the book, offers a simple API to probe and manage such
reserved RAM and has been used successfully on several architectures.
However, this trick doesn't work when you have an
high-memory system (i.e., one with more physical memory than could
fit in the CPU address space).</p>

<p class="docText">Another option, of course, is to allocate your buffer with the
<tt>GFP_NOFAIL</tt> allocation flag. This approach does,
however, severely stress the memory management subsystem, and it runs
the risk of locking up the system altogether; it is best avoided
unless there is truly no other way.</p>

<p class="docText">If you are going to such lengths to allocate a large DMA buffer,
however, it is worth putting some thought into alternatives. If your
device can do scatter/gather I/O, you can allocate your buffer in
smaller pieces and let the device do the rest. Scatter/gather I/O can
also be used when performing direct I/O into user space, which may
well be the best solution when a truly huge buffer is required.</p>



<a name="chp-15-sect-4.3"></a>
<h4 class="docSection2Title">15.4.3. Bus Addresses</h4>

<p class="docText"><a name="chp-15-ITERM-7154"></a>
<a name="chp-15-ITERM-7155"></a>A
device driver using DMA has to talk to hardware connected to the
interface bus, which uses physical addresses, whereas program code
uses virtual addresses.</p>

<p class="docText">As a matter of fact, the situation is slightly more complicated than
that. DMA-based hardware uses <span class="docEmphasis">bus</span>, rather than
<span class="docEmphasis">physical</span>, addresses. Although ISA and PCI bus
addresses are simply physical addresses on the PC, this is not true
for every platform. Sometimes the interface bus is connected through
bridge circuitry that maps I/O addresses to different physical
addresses. Some systems even have a page-mapping scheme that can make
arbitrary pages appear contiguous to the peripheral bus.</p>

<p class="docText">At the lowest level (again, we'll look at a
higher-level solution shortly), the Linux kernel provides a portable
solution by exporting the following functions, defined in
<i>&lt;asm/io.h&gt;</i>. The use of these functions is
strongly discouraged, because they work properly only on systems with
a very simple I/O architecture; nonetheless, you may encounter them
when working with kernel code.</P>

<pre>unsigned long virt_to_bus(volatile void *address);
void *bus_to_virt(unsigned long address);</pre><br>


<p class="docText"><a name="chp-15-ITERM-7156"></a> <a name="chp-15-ITERM-7157"></a>
<a name="chp-15-ITERM-7158"></a>These functions perform a simple
conversion between kernel logical addresses and bus addresses. They
do not work in any situation where an I/O memory management unit must
be programmed or where bounce buffers must be used. The right way of
performing this conversion is with the generic DMA layer, so we now
move on to that topic.</P>


<a name="chp-15-sect-4.4"></a>
<H4 class="docSection2Title">15.4.4. The Generic DMA Layer</h4>

<p class="docText">DMA operations, in the<a name="chp-15-ITERM-7159"></a>
<a name="chp-15-ITERM-7160"></a> end, come down to allocating a buffer and
passing bus addresses to your device. However, the task of writing
portable drivers that perform DMA safely and correctly on all
architectures is harder than one might think. Different systems have
different ideas of how cache coherency should work; if you do not
handle this issue correctly, your driver may corrupt memory. Some
systems have complicated bus hardware that can make the DMA task
easier—or harder. And not all systems can perform DMA out of
all parts of memory. Fortunately, the kernel provides a bus- and
architecture-independent DMA layer that hides most of these issues
from the driver author. We strongly encourage you to use this layer
for DMA operations in any driver you write.</p>

<p class="docText">Many of the functions below require a pointer to a <tt>struct
device</tt>. This structure is the low-level representation of a
device within the Linux device model. It is not something that
drivers often have to work with directly, but you do need it when
using the generic DMA layer. Usually, you can find this structure
buried inside the bus specific that describes your device. For
example, it can be found as the <tt>dev</tt> field in
<tt>struct pci_device</tt> or <tt>struct
usb_device</tt>. The <tt>device</tt> structure is
covered in detail in <a class="docLink" href="chp-14.shtml#chp-14">Chapter 14</a>.</p>

<p class="docText">Drivers that use the following functions should include
<I>&lt;linux/dma-mapping.h&gt;</i>.</P>

<a name="chp-15-sect-4.4.1"></a>
<H5 class="docSection3Title">15.4.4.1 Dealing with difficult hardware</H5>

<p class="docText">The first question
that<a name="chp-15-ITERM-7161"></a>
<a name="chp-15-ITERM-7162"></a> must be answered before attempting
DMA is whether the given device is capable of such an operation on
the current host. Many devices are limited in the range of memory
they can address, for a number of reasons. By default, the kernel
assumes that your device can perform DMA to any 32-bit address. If
this is not the case, you should inform the kernel of that fact with
a call to:</p>

<pre>    int dma_set_mask(struct device *dev, u64 mask);</pre><br>


<p class="docText">The <tt>mask</tt> should show the bits that your device can
address; if it is limited to 24 bits, for example, you would pass
<tt>mask</tt> as <tt>0x0FFFFFF</tt>. The return
value is nonzero if DMA is possible with the given
<tt>mask</tt>; if <span class="docEmphasis">dma_set_mask</span> returns
<tt>0</tt>, you are not able to use DMA operations with
this device. Thus, the initialization code in a driver for a device
limited to 24-bit DMA operations might look like:</p>

<pre>if (dma_set_mask (dev, 0xffffff))
    card-&gt;use_dma = 1;
else {
    card-&gt;use_dma = 0;   /* We'll have to live without DMA */
    printk (KERN_WARN, "mydev: DMA not supported\n");
}</pre><br>


<p class="docText">Again, if your device supports normal, 32-bit DMA operations, there
is no need to call <span class="docEmphasis">dma_set_mask</span>.</P>



<a name="chp-15-sect-4.4.2"></a>
<H5 class="docSection3Title">15.4.4.2 DMA mappings</H5>

<p class="docText">A <i>DMA mapping</I> is a
<a name="chp-15-ITERM-7163"></a>combination
of allocating a DMA buffer and generating an address for that buffer
that is accessible by the device. It is tempting to get that address
with a simple call to <span class="docEmphasis">virt_to_bus</span>, but there are
strong reasons for avoiding that approach. The first of those is that
reasonable hardware comes with an <a name="chp-15-ITERM-7164"></a>IOMMU that provides a
set of <I>mapping
registers</i><a name="chp-15-ITERM-7165"></a>
<a name="chp-15-ITERM-7166"></a>
<a name="chp-15-ITERM-7167"></a>
for the bus. The IOMMU can arrange for any physical memory to appear
within the address range accessible by the device, and it can cause
physically scattered buffers to look contiguous to the device. Making
use of the IOMMU requires using the generic DMA layer;
<span class="docEmphasis">virt_to_bus</span> is not up to the task.</p>

<p class="docText">Note that not all architectures have an IOMMU; in particular, the
popular x86 platform has no IOMMU support. A properly written driver
need not be aware of the I/O support hardware it is running over,
however.</p>

<p class="docText"><a name="chp-15-ITERM-7168"></a>
<a name="chp-15-ITERM-7169"></a>Setting
up a useful address for the
device<a name="chp-15-ITERM-7170"></a> may also, in some cases, require the
establishment of a <i>bounce buffer</I>. Bounce
buffers are created when a driver attempts to perform DMA on an
address that is not reachable by the peripheral device—a
high-memory address, for example. Data is then copied to and from the
bounce buffer as needed. Needless to say, use of bounce buffers can
slow things down, but sometimes there is no alternative.</p>

<p class="docText">DMA mappings must also address the issue of cache coherency. Remember
that modern processors keep copies of recently accessed memory areas
in a fast, local cache; without this cache, reasonable performance is
not possible. If your device changes an area of main memory, it is
imperative that any processor caches covering that area be
invalidated; otherwise the processor may work with an incorrect image
of main memory, and data corruption results. Similarly, when your
device uses DMA to read data from main memory, any changes to that
memory residing in processor caches must be flushed out first. These
<i>cache
coherency</I><a name="chp-15-ITERM-7171"></a>
<a name="chp-15-ITERM-7172"></a>
<a name="chp-15-ITERM-7173"></a>
issues can create no end of obscure and difficult-to-find bugs if the
programmer is not careful. Some architectures manage cache coherency
in the hardware, but others require software support. The generic DMA
layer goes to great lengths to ensure that things work correctly on
all architectures, but, as we will see, proper behavior requires
adherence to a small set of rules.</p>

<p class="docText">The DMA mapping sets up a new type, <tt>dma_addr_t</tt>, to
represent bus addresses. Variables of type
<tt>dma_addr_t</tt> should be treated as opaque by the
driver; the only allowable operations are to pass them to the DMA
support routines and to the device itself. As a bus address,
<tt>dma_addr_t</tt> may lead to unexpected problems if used
directly by the CPU.</p>

<p class="docText">The PCI code distinguishes between two types of DMA mappings,
depending on how long the DMA buffer is expected to stay around:</P>

<a name="chp-15-ITERM-7174"></a><dl class="docList"><dt><i><span class="docPubcolor">Coherent DMA mappings</span></i></dt></p>
<dd>
<p class="docList">These mappings usually exist for the life of the driver. A coherent
buffer must be simultaneously available to both the CPU and the
peripheral (other types of mappings, as we will see later, can be
available only to one or the other at any given time). As a result,
coherent mappings must live in cache-coherent memory. Coherent
mappings can be expensive to set up and use.</p>
</dd>
<dt><i><span class="docPubcolor">Streaming DMA mappings</span></i></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7174"></a>Streaming mappings are usually set up
for a single operation. Some architectures allow for significant
optimizations when streaming mappings are used, as we see, but these
mappings also are subject to a stricter set of rules in how they may
be accessed. The kernel developers recommend the use of streaming
mappings over coherent mappings whenever possible. There are two
reasons for this recommendation. The first is that, on systems that
support mapping registers, each DMA mapping uses one or more of them
on the bus. Coherent mappings, which have a long lifetime, can
monopolize these registers for a long time, even when they are not
being used. The other reason is that, on some hardware, streaming
mappings can be optimized in ways that are not available to coherent
mappings.</p>
</dd>
</dl>

<p class="docText">The two mapping types must be manipulated in different ways;
it's time to look at the details.</p>



<a name="chp-15-sect-4.4.3"></a>
<h5 class="docSection3Title">15.4.4.3 Setting up coherent DMA mappings</h5>

<p class="docText">A driver can set up a
<a name="chp-15-ITERM-7175"></a>
<a name="chp-15-ITERM-7176"></a>coherent
mapping with a call to <span class="docEmphasis">dma_alloc_coherent</span>:</P>

<pre>void *dma_alloc_coherent(struct device *dev, size_t size,
                         dma_addr_t *dma_handle, int flag);</pre><br>


<p class="docText">This function handles both the allocation and the mapping of the
buffer. The first two arguments are the device structure and the size
of the buffer needed. The function returns the result of the DMA
mapping in two places. The return value from the function is a kernel
virtual address for the buffer, which may be used by the driver; the
associated bus address, meanwhile, is returned in
<tt>dma_handle</tt>. Allocation is handled in this function
so that the buffer is placed in a location that works with DMA;
usually the memory is just allocated with
<span class="docEmphasis">get_free_pages</span> (but note that the size is in
bytes, rather than an order value). The <tt>flag</tt>
argument is the usual <tt>GFP_</tt> value describing how
the memory is to be allocated; it should usually be
<tt>GFP_KERNEL</tt> (usually) or
<tt>GFP_ATOMIC</tt> (when running in atomic context).</P>

<p class="docText"><a name="chp-15-ITERM-7177"></a>
<a name="chp-15-ITERM-7178"></a>When
the buffer is no longer needed (usually at module unload time), it
should be returned to the system with
<span class="docEmphasis">dma_free_coherent</span>:</P>

<pre>void dma_free_coherent(struct device *dev, size_t size,
                        void *vaddr, dma_addr_t dma_handle);</pre><br>


<p class="docText">Note that this function, like many of the generic DMA functions,
requires that all of the size, CPU address, and bus address arguments
be provided.</p>



<a name="chp-15-sect-4.4.4"></a>
<h5 class="docSection3Title">15.4.4.4 DMA pools</H5>

<p class="docText">A <i>DMA pool</I> is an allocation
<a name="chp-15-ITERM-7179"></a>mechanism
for small, coherent DMA mappings. Mappings obtained from
<span class="docEmphasis">dma_alloc_coherent</span> may have a minimum size of
one page. If your device needs smaller DMA areas than that, you
should probably be using a DMA pool. DMA pools are also useful in
situations where you may be tempted to perform DMA to small areas
embedded within a larger structure. Some very obscure driver bugs
have been traced down to cache coherency problems with structure
fields adjacent to small DMA areas. To avoid this problem, you should
always allocate areas for DMA operations explicitly, away from other,
non-DMA data structures.</P>

<p class="docText">The DMA pool functions are defined in
<I>&lt;linux/dmapool.h&gt;</i>.</p>

<p class="docText">A DMA pool must be created before use with a call to:</p>

<pre>struct dma_pool *dma_pool_create(const char *name, struct device *dev, 
                                 size_t size, size_t align, 
                                 size_t allocation);</pre><br>


<p class="docText">Here, <tt>name</tt> is a name for the pool,
<tt>dev</tt> is your device structure,
<tt>size</tt> is the size of the buffers to be allocated
from this pool, <tt>align</tt> is the required hardware
alignment for allocations from the pool (expressed in bytes), and
<tt>allocation</tt> is, if nonzero, a memory boundary that
allocations should not exceed. If <tt>allocation</tt> is
passed as 4096, for example, the buffers allocated from this pool do
not cross 4-KB boundaries.</P>

<p class="docText">When you are done with a pool, it
can<a name="chp-15-ITERM-7180"></a> be freed with:</P>

<pre>void dma_pool_destroy(struct dma_pool *pool);</pre><BR>


<p class="docText">You should return all allocations to the pool before destroying it.</p>

<p class="docText">Allocations are handled with <span class="docEmphasis">dma_pool_alloc</span>:</P>

<pre>void *dma_pool_alloc(struct dma_pool *pool, int mem_flags, 
                     dma_addr_t *handle);</pre><BR>


<p class="docText">For this call, <tt>mem_flags</tt> is the usual set of
<tt>GFP_</tt> allocation flags. If all goes well, a region
of memory (of the size specified when the pool was created) is
allocated and returned. As with
<span class="docEmphasis">dma_alloc_coherent</span>, the address of the resulting
DMA buffer is returned as a kernel virtual address and stored in
<tt>handle</tt> as a bus address.</p>

<p class="docText">Unneeded buffers should be returned to the pool with:</p>

<pre>void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t addr);</pre><br>




<a name="chp-15-sect-4.4.5"></a>
<h5 class="docSection3Title">15.4.4.5 Setting up streaming DMA mappings</H5>

<p class="docText">Streaming mappings have a
more<a name="chp-15-ITERM-7181"></a>
<a name="chp-15-ITERM-7182"></a>
<a name="chp-15-ITERM-7183"></a> complicated interface than the
coherent variety, for a number of reasons. These mappings expect to
work with a buffer that has already been allocated by the driver and,
therefore, have to deal with addresses that they did not choose. On
some architectures, streaming mappings can also have multiple,
discontiguous pages and multipart
"scatter/gather" buffers. For all
of these reasons, streaming mappings have their own set of mapping
functions.</p>

<p class="docText">When setting up a streaming mapping, you must tell the kernel in
which direction the data is moving. Some symbols (of type
<tt>enum</tt> <tt>dma_data_direction</tt>) have
been defined for this purpose:</p>

<a name="chp-15-ITERM-7184"></a><a name="chp-15-ITERM-7185"></a><a name="chp-15-ITERM-7186"></a><a name="chp-15-ITERM-7187"></a><a name="chp-15-ITERM-7188"></a><a name="chp-15-ITERM-7189"></a><a name="chp-15-ITERM-7190"></a><a name="chp-15-ITERM-7191"></a><a name="chp-15-ITERM-7192"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DMA_TO_DEVICE</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DMA_FROM_DEVICE</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-15-ITERM-7184"></a>
<a name="chp-15-ITERM-7185"></a>
<a name="chp-15-ITERM-7186"></a>
<a name="chp-15-ITERM-7187"></a><a name="chp-15-ITERM-7188"></a>These two symbols should be reasonably
self-explanatory. If data is being sent to the device (in response,
perhaps, to a <span class="docEmphasis">write</span> system call),
<tt>DMA_TO_DEVICE</tt> should be used; data going to the
CPU, instead, is marked with <tt>DMA_FROM_DEVICE</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DMA_BIDIRECTIONAL</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7189"></a>
<a name="chp-15-ITERM-7190"></a>If
data can move in either direction, use
<tt>DMA_BIDIRECTIONAL</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DMA_NONE</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7191"></a>
<a name="chp-15-ITERM-7192"></a>This
symbol is provided only as a debugging aid. Attempts to use buffers
with this "direction" cause a
kernel panic.</p>
</dd>
</dl>

<p class="docText">It may be tempting to just pick <tt>DMA_BIDIRECTIONAL</tt>
at all times, but driver authors should resist that temptation. On
some architectures, there is a performance penalty to pay for that
choice.</p>

<p class="docText">When you have a single buffer
to<a name="chp-15-ITERM-7193"></a>
<a name="chp-15-ITERM-7194"></a>
transfer, map it with <span class="docEmphasis">dma_map_single</span>:</p>

<pre>dma_addr_t dma_map_single(struct device *dev, void *buffer, size_t size, 
                          enum dma_data_direction direction);</pre><br>


<p class="docText">The return value is the bus address that you can pass to the device
or <tt>NULL</tt> if something goes wrong.</p>

<p class="docText">Once the transfer is
<a name="chp-15-ITERM-7195"></a>
<a name="chp-15-ITERM-7196"></a>complete,
the mapping should be deleted with
<span class="docEmphasis">dma_unmap_single</span>:</P>

<pre>void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size, 
                      enum dma_data_direction direction);</pre><br>


<p class="docText">Here, the <tt>size</tt> and <tt>direction</tt>
arguments must match those used to map the buffer.</P>

<p class="docText">Some important rules apply to streaming DMA mappings:</P>

<ul><li><p class="docList">The buffer must be used only for a transfer that matches the
direction value given when it was mapped.</p></LI><li><p class="docList">Once a buffer has been mapped, it belongs to the device, not the
processor. Until the buffer has been unmapped, the driver should not
touch its contents in any way. Only after
<span class="docEmphasis">dma_unmap_single</span> has been called is it safe for
the driver to access the contents of the buffer (with one exception
that we see shortly). Among other things, this rule implies that a
buffer being written to a device cannot be mapped until it contains
all the data to write.</P></LI><LI><p class="docList">The buffer must not be unmapped while DMA is still active, or serious
system instability is guaranteed.</p></li></ul>
<p class="docText">You may be wondering why the driver can no longer work with a buffer
once it has been mapped. There are actually two reasons why this rule
makes sense. First, when a buffer is mapped for DMA, the kernel must
ensure that all of the data in that buffer has actually been written
to memory. It is likely that some data is in the
processor's cache when
<span class="docEmphasis">dma_unmap_single</span> is issued, and must be
explicitly flushed. Data written to the buffer by the processor after
the flush may not be visible to the device.</p>

<p class="docText"><a name="chp-15-ITERM-7197"></a>
<a name="chp-15-ITERM-7198"></a><a name="chp-15-ITERM-7199"></a>
<a name="chp-15-ITERM-7200"></a><a name="chp-15-ITERM-7201"></a>
<a name="chp-15-ITERM-7202"></a>Second,
consider what happens if the buffer to be mapped is in a region of
memory that is not accessible to the device. Some architectures
simply fail in this case, but others create a bounce buffer. The
bounce buffer is just a separate region of memory that
<span class="docEmphasis">is</span> accessible to the device. If a buffer is
mapped with a direction of <tt>DMA_TO_DEVICE</tt>, and a
bounce buffer is required, the contents of the original buffer are
copied as part of the mapping operation. Clearly, changes to the
original buffer after the copy are not seen by the device. Similarly,
<tt>DMA_FROM_DEVICE</tt> bounce buffers are copied back to
the original buffer by <span class="docEmphasis">dma_unmap_single</span>; the
data from the device is not present until that copy has been done.</P>

<p class="docText">Incidentally, bounce buffers are one reason why it is important to
get the direction right. <tt>DMA_BIDIRECTIONAL</tt> bounce
buffers are copied both before and after the operation, which is
often an unnecessary waste of CPU cycles.</P>

<p class="docText">Occasionally a driver needs to access the contents of
a<a name="chp-15-ITERM-7203"></a> streaming DMA
buffer without unmapping it. A call has
been<a name="chp-15-ITERM-7204"></a>
<a name="chp-15-ITERM-7205"></a> provided to make this possible:</P>

<pre>void dma_sync_single_for_cpu(struct device *dev, dma_handle_t bus_addr, 
                             size_t size, enum dma_data_direction direction);</pre><br>


<p class="docText">This function should be called before the processor accesses a
streaming DMA buffer. Once the call has been made, the CPU
"owns" the DMA buffer and can work
with it as needed. Before the device accesses the buffer, however,
ownership should be transferred back to it with:</P>

<pre>void dma_sync_single_for_device(struct device *dev, dma_handle_t bus_addr, 
                                size_t size, enum dma_data_direction direction);</pre><BR>


<p class="docText">The processor, once again, should not access the DMA buffer after
this call has been made.</p>



<a name="chp-15-sect-4.4.6"></a>
<h5 class="docSection3Title">15.4.4.6 Single-page streaming mappings</h5>

<p class="docText">Occasionally, you may want<a name="chp-15-ITERM-7206"></a>
<a name="chp-15-ITERM-7207"></a>
<a name="chp-15-ITERM-7208"></a>
<a name="chp-15-ITERM-7209"></a>
<a name="chp-15-ITERM-7210"></a> to set up a mapping on a buffer for
which you have a <tt>struct page</tt> pointer; this can
happen, for example, with user-space buffers mapped with
<span class="docEmphasis">get_user_pages</span>. To set up and tear down
streaming mappings using <tt>struct</tt>
<tt>page</tt> pointers, use the following:</p>

<pre>dma_addr_t dma_map_page(struct device *dev, struct page *page,
                        unsigned long offset, size_t size,
                        enum dma_data_direction direction);

void dma_unmap_page(struct device *dev, dma_addr_t dma_address, 
                    size_t size, enum dma_data_direction direction);</pre><BR>


<p class="docText">The <tt>offset</tt> and <tt>size</tt> arguments
can be used to map part of a page. It is recommended, however, that
partial-page mappings be avoided unless you are really sure of what
you are doing. Mapping part of a page can lead to cache coherency
problems if the allocation covers only part of a cache line; that, in
turn, can lead to memory corruption and extremely difficult-to-debug
bugs.</p>



<a name="chp-15-sect-4.4.7"></a>
<h5 class="docSection3Title">15.4.4.7 Scatter/gather mappings</H5>

<p class="docText"><a name="chp-15-ITERM-7211"></a>
<a name="chp-15-ITERM-7212"></a><a name="chp-15-ITERM-7213"></a>Scatter/gather mappings are a
special type of streaming DMA mapping. Suppose you have several
buffers, all of which need to be transferred to or from the device.
This situation can come about in several ways, including from a
<span class="docEmphasis">readv</span> or <span class="docEmphasis">writev</span> system
call, a clustered disk I/O request, or a list of pages in a mapped
kernel I/O buffer. You could simply map each buffer, in turn, and
perform the required operation, but there are advantages to mapping
the whole list at once.</p>

<p class="docText"><a name="chp-15-ITERM-7214"></a>
<a name="chp-15-ITERM-7215"></a>
<a name="chp-15-ITERM-7216"></a><a name="chp-15-ITERM-7217"></a>
<a name="chp-15-ITERM-7218"></a><a name="chp-15-ITERM-7219"></a>Many
devices can accept a <i>scatterlist</I> of array
pointers and lengths, and transfer them all in one DMA operation; for
example, "zero-copy" networking is
easier if packets can be built in multiple pieces. Another reason to
map scatterlists as a whole is to take advantage of systems that have
mapping registers in the bus hardware. On such systems, physically
discontiguous pages can be assembled into a single, contiguous array
from the device's point of view. This technique
works only when the entries in the scatterlist are equal to the page
size in length (except the first and last), but when it does work, it
can turn multiple operations into a single DMA, and speed things up
accordingly.</p>

<p class="docText">Finally, if a bounce buffer must be used, it makes sense to coalesce
the entire list into a single buffer (since it is being copied
anyway).</P>

<p class="docText">So now you're convinced that mapping of scatterlists
is worthwhile in some situations. The first step in mapping a
scatterlist is to create and fill in an array of
<tt>struct</tt> <tt>scatterlist</tt> describing
the buffers to be transferred. This structure is architecture
dependent, and is described in
<i>&lt;asm/scatterlist.h&gt;</i>. However, it always
contains three fields:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page *page;</span></span></span></dt></p>
<dd>
<p class="docList">The <tt>struct</tt> <tt>page</tt> pointer
corresponding to the buffer to be used in the scatter/gather
operation.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int length;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int offset;</span></span></span></dt></p>
<dd>
<p class="docList">The length of that buffer and its offset within the page</P>
</dd>
</dl>

<p class="docText"><a name="chp-15-ITERM-7220"></a>
<a name="chp-15-ITERM-7221"></a>To
map a scatter/gather DMA operation, your driver should set the
<tt>page</tt>, <tt>offset</tt>, and
<tt>length</tt> fields in a <tt>struct</tt>
<tt>scatterlist</tt> entry for each buffer to be
transferred. Then call:</P>

<pre>int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
               enum dma_data_direction direction)</pre><BR>


<p class="docText">where <tt>nents</tt> is the number of scatterlist entries
passed in. The return value is the number of DMA buffers to transfer;
it may be less than <tt>nents</tt>.</p>

<p class="docText">For each buffer in the input scatterlist,
<span class="docEmphasis">dma_map_sg</span> determines the proper bus address to
give to the device. As part of that task, it also coalesces buffers
that are adjacent to each other in memory. If the system your driver
is running on has an I/O memory management unit,
<span class="docEmphasis">dma_map_sg</span> also programs that
unit's mapping registers, with the possible result
that, from your device's point of view, you are able
to transfer a single, contiguous buffer. You will never know what the
resulting transfer will look like, however, until after the call.</p>

<p class="docText">Your driver should transfer each buffer returned by
<span class="docEmphasis">pci_map_sg</span>. The bus address and length of each
buffer are stored in the <tt>struct scatterlist</tt>
entries, but their location in the structure varies from one
architecture to the next. Two macros have been defined to make it
possible to write portable code:</P>

<a name="chp-15-ITERM-7222"></a><a name="chp-15-ITERM-7223"></a><a name="chp-15-ITERM-7224"></a><a name="chp-15-ITERM-7225"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">dma_addr_t sg_dma_address(struct scatterlist *sg);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-15-ITERM-7222"></a>
<a name="chp-15-ITERM-7223"></a>Returns
the bus (DMA) address from this scatterlist entry.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int sg_dma_len(struct scatterlist *sg);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7224"></a>
<a name="chp-15-ITERM-7225"></a>Returns
the length of this buffer.</p>
</dd>
</dl>

<p class="docText">Again, remember that the address and length of the buffers to
transfer may be different from what was passed in to
<span class="docEmphasis">dma_map_sg</span>.</P>

<p class="docText">Once the transfer is complete, a scatter/gather mapping is unmapped
with a call to <span class="docEmphasis">dma_unmap_sg</span>:</P>

<pre>void dma_unmap_sg(struct device *dev, struct scatterlist *list,
                  int nents, enum dma_data_direction direction);</pre><BR>


<p class="docText">Note that <tt>nents</tt> must be the number of entries that
you originally passed to <span class="docEmphasis">dma_map_sg</span> and not the
number of DMA buffers the function returned to you.</p>

<p class="docText">Scatter/gather mappings are streaming DMA mappings, and the same
access rules apply to them as to the single variety. If you must
access a mapped scatter/gather list, you must synchronize it first:</P>

<pre>void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
                         int nents, enum dma_data_direction direction);
void dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
                         int nents, enum dma_data_direction direction);</pre><BR>




<a name="chp-15-sect-4.4.8"></a>
<h5 class="docSection3Title">15.4.4.8 PCI double-address cycle mappings</h5>

<p class="docText">Normally, the DMA support<a name="chp-15-ITERM-7226"></a> <a name="chp-15-ITERM-7227"></a>
<a name="chp-15-ITERM-7228"></a>
<a name="chp-15-ITERM-7229"></a> layer works with 32-bit bus addresses,
possibly restricted by a specific device's DMA mask.
The PCI bus, however, also supports a 64-bit addressing mode, the
<i>double-address cycle</i> (DAC). The generic DMA
layer does not support this mode for a couple of reasons, the first
of which being that it is a PCI-specific feature. Also, many
implementations of DAC are buggy at best, and, because DAC is slower
than a regular, 32-bit DMA, there can be a performance cost. Even so,
there are applications where using DAC can be the right thing to do;
if you have a device that is likely to be working with very large
buffers placed in high memory, you may want to consider implementing
DAC support. This support is available only for the PCI bus, so
PCI-specific routines must be used.</P>

<p class="docText">To use DAC, your driver must include
<i>&lt;linux/pci.h&gt;</i>. You must set a separate DMA
mask:</P>

<pre>int pci_dac_set_dma_mask(struct pci_dev *pdev, u64 mask);</pre><br>


<p class="docText">You can use DAC addressing only if this call returns
<tt>0</tt>.</p>

<p class="docText">A special type (<tt>dma64_addr_t</tt>) is used for DAC
mappings. To establish one of these mappings, call
<span class="docEmphasis">pci_dac_page_to_dma</span>:</P>

<pre>dma64_addr_t pci_dac_page_to_dma(struct pci_dev *pdev, struct page *page, 
                                 unsigned long offset, int direction);</pre><br>


<p class="docText">DAC mappings, you will notice, can be made only from
<tt>struct</tt> <tt>page</tt> pointers (they
should live in high memory, after all, or there is no point in using
them); they must be created a single page at a time. The
<tt>direction</tt> argument is the PCI equivalent of the
<tt>enum dma_data_direction</tt> used in the generic DMA
layer; it should be <tt>PCI_DMA_TODEVICE</tt>,
<tt>PCI_DMA_FROMDEVICE</tt>, or
<tt>PCI_DMA_BIDIRECTIONAL</tt>.</P>

<p class="docText">DAC mappings require no external resources, so there is no need to
explicitly release them after use. It is necessary, however, to treat
DAC mappings like other streaming mappings, and observe the rules
regarding buffer ownership. There is a set of functions for
synchronizing
<a name="chp-15-ITERM-7230"></a>
<a name="chp-15-ITERM-7231"></a>DMA
buffers that is analogous to the generic variety:</p>

<pre>void pci_dac_dma_sync_single_for_cpu(struct pci_dev *pdev,
                                     dma64_addr_t dma_addr,
                                     size_t len,
                                     int direction);

void pci_dac_dma_sync_single_for_device(struct pci_dev *pdev,
                                        dma64_addr_t dma_addr,
                                        size_t len,
                                        int direction);</pre><br>




<a name="chp-15-sect-4.4.9"></a>
<h5 class="docSection3Title">15.4.4.9 A simple PCI DMA example</h5>

<p class="docText"><a name="chp-15-ITERM-7232"></a><a name="chp-15-ITERM-7233"></a>As an example of how the DMA mappings
might be used, we present a simple example of DMA coding for a PCI
device. The actual form of DMA operations on the PCI bus is very
dependent on the device being driven. Thus, this example does not
apply to any real device; instead, it is part of a hypothetical
driver called <span class="docEmphasis">dad</span> (DMA Acquisition Device). A
driver for this device might define a transfer function like this:</p>

<pre>int dad_transfer(struct dad_dev *dev, int write, void *buffer, 
                 size_t count)
{
    dma_addr_t bus_addr;

    /* Map the buffer for DMA */
    dev-&gt;dma_dir = (write ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
    dev-&gt;dma_size = count;
    bus_addr = dma_map_single(&amp;dev-&gt;pci_dev-&gt;dev, buffer, count, 
                              dev-&gt;dma_dir);
    dev-&gt;dma_addr = bus_addr;

    /* Set up the device */

    writeb(dev-&gt;registers.command, DAD_CMD_DISABLEDMA);
    writeb(dev-&gt;registers.command, write ? DAD_CMD_WR : DAD_CMD_RD);
    writel(dev-&gt;registers.addr, cpu_to_le32(bus_addr));
    writel(dev-&gt;registers.len, cpu_to_le32(count));

    /* Start the operation */
    writeb(dev-&gt;registers.command, DAD_CMD_ENABLEDMA);
    return 0;
}</pre><br>


<p class="docText">This function maps the buffer to be transferred and starts the device
operation. The other half of the job must be done in the interrupt
service routine, which looks something like this:</p>

<pre>void dad_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
    struct dad_dev *dev = (struct dad_dev *) dev_id;

    /* Make sure it's really our device interrupting */

    /* Unmap the DMA buffer */
    dma_unmap_single(dev-&gt;pci_dev-&gt;dev, dev-&gt;dma_addr, 
                     dev-&gt;dma_size, dev-&gt;dma_dir);

    /* Only now is it safe to access the buffer, copy to user, etc. */
    ...
}</pre><br>


<p class="docText">Obviously, a great deal of detail has been left out of this example,
including whatever steps may be required to prevent attempts to start
multiple, simultaneous DMA operations.</p>



<a name="chp-15-sect-4.5"></a>
<a name="chp-15-ITERM-7234"></a><h4 class="docSection2Title">15.4.5. DMA for ISA Devices</h4>

<p class="docText"><a name="chp-15-ITERM-7235"></a>The ISA bus allows for two kinds of DMA
transfers: native DMA and ISA bus master DMA. Native DMA uses
standard DMA-controller circuitry on the motherboard to drive the
signal lines on the ISA bus. ISA bus master DMA, on the other hand,
is handled entirely by the peripheral device. The latter type of DMA
is rarely used and doesn't require discussion here,
because it is similar to DMA for PCI devices, at least from the
driver's point of view. An example of an ISA bus
master is the 1542 SCSI controller, whose driver is
<i>drivers/scsi/aha1542.c</i> in the kernel sources.</P>

<p class="docText">As far as native DMA is concerned, there are three entities involved
in a DMA data transfer on the ISA bus:</p>

<a name="chp-15-ITERM-7236"></a><a name="chp-15-ITERM-7237"></a><dl class="docList"><dt><i><span class="docPubcolor">The 8237 DMA controller (DMAC)</span></i></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7236"></a>The
controller holds information about the DMA transfer, such as the
direction, the memory address, and the size of the transfer. It also
contains a counter that tracks the status of ongoing transfers. When
the controller receives a DMA request signal, it gains control of the
bus and drives the signal lines so that the device can read or write
its data.</P>
</dd>
<dt><I><span class="docPubcolor">The peripheral device</span></I></dt></p>
<dd>
<p class="docList">The device must activate the DMA request signal when
it's ready to transfer data. The actual transfer is
managed by the DMAC; the hardware device sequentially reads or writes
data onto the bus when the controller strobes the device. The device
usually raises an interrupt when the transfer is over.</p>
</dd>
<dt><span class="docPubcolor"><a name="chp-15-ITERM-7237"></a>The device driver</span></dt></P>
<dd>
<p class="docList">The driver has little to do; it provides the DMA controller with the
direction, bus address, and size of the transfer. It also talks to
its peripheral to prepare it for transferring the data and responds
to the interrupt when the DMA is over.</P>
</dd>
</dl>

<p class="docText">The original DMA controller used in the PC could manage four
"channels," each associated with
one set of DMA registers. Four devices could store their DMA
information in the controller at the same time. Newer PCs contain the
equivalent of two DMAC devices:<sup class="docFootnote"><a class="docLink" href="chp-15-sect-4.shtml#chp-15-FNOTE-6">[6]</a></sup> the
second controller (master) is connected to the system processor, and
the first (slave) is connected to channel <tt>0</tt> of the
second controller.<sup class="docFootnote"><a class="docLink" href="chp-15-sect-4.shtml#chp-15-FNOTE-7">[7]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="chp-15-FNOTE-6">[6]</a></sup> These circuits are
now part of the motherboard's chipset, but a few
years ago they were two separate 8237 chips.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="chp-15-FNOTE-7">[7]</a></sup> The original PCs had only one
controller; the second was added in 286-based platforms. However, the
second controller is connected as the master because it handles
16-bit transfers; the first transfers only eight bits at a time and
is there for backward compatibility.</P></blockquote>

<p class="docText">The channels are numbered from 0-7: channel 4 is not available to ISA
peripherals, because it is used internally to cascade the slave
controller onto the master. The available channels are, thus, 0-3 on
the slave (the 8-bit channels) and 5-7 on the master (the 16-bit
channels). The size of any DMA transfer, as stored in the controller,
is a 16-bit number representing the number of bus cycles. The maximum
transfer size is, therefore, 64 KB for the slave controller (because
it transfers eight bits in one cycle) and 128 KB for the master
(which does 16-bit transfers).</P>

<p class="docText">Because the DMA controller is a system-wide resource, the kernel
helps deal with it. It uses a DMA registry to provide a
request-and-free mechanism for the DMA channels and a set of
functions to configure channel information in the DMA controller.</p>

<a name="chp-15-sect-4.5.1"></a>
<h5 class="docSection3Title">15.4.5.1 Registering DMA usage</h5>

<p class="docText"><a name="chp-15-ITERM-7238"></a><a name="chp-15-ITERM-7239"></a><a name="chp-15-ITERM-7240"></a><a name="chp-15-ITERM-7241"></a>
<a name="chp-15-ITERM-7242"></a><a name="chp-15-ITERM-7243"></a>
<a name="chp-15-ITERM-7244"></a>You
should be used to kernel registries—we've
already seen them for I/O ports and interrupt lines. The DMA channel
registry is similar to the others. After
<i>&lt;asm/dma.h&gt;</I> has been included, the
following functions can be used to obtain and release ownership of a
DMA channel:</p>

<pre>int request_dma(unsigned int channel, const char *name); 
void free_dma(unsigned int channel);</pre><br>


<p class="docText">The <tt>channel</tt> argument is a number between 0 and 7
or, more precisely, a positive number less than
<tt>MAX_DMA_CHANNELS</tt>. On the PC,
<tt>MAX_DMA_CHANNELS</tt> is defined as
<tt>8</tt> to match the hardware. The
<tt>name</tt> argument is a string identifying the device.
The specified name appears in the file
<I>/proc/dma</i>, which can be read by user programs.</p>

<p class="docText">The return value from <span class="docEmphasis">request_dma</span> is
<tt>0</tt> for success and <tt>-EINVAL</tt> or
<tt>-EBUSY</tt> if there was an error. The former means
that the requested channel is out of range, and the latter means that
another device is holding the channel.</P>

<p class="docText"><a name="chp-15-ITERM-7245"></a>
<a name="chp-15-ITERM-7246"></a>We recommend that you take the
same care with DMA channels as with I/O ports and interrupt lines;
requesting the channel at <span class="docEmphasis">open</span> time is much
better than requesting it from the module initialization function.
Delaying the request allows some sharing between drivers; for
example, your sound card and your analog I/O interface can share the
DMA channel as long as they are not used at the same time.</p>

<p class="docText">We also suggest that you request the DMA channel
<span class="docEmphasis">after</span> you've requested the
interrupt line and that you release it <span class="docEmphasis">before</span>
the interrupt. This is the conventional order for requesting the two
resources; following the convention avoids possible deadlocks. Note
that every device using DMA needs an IRQ line as well; otherwise, it
couldn't signal the completion of data transfer.</P>

<p class="docText">In a typical case, the code for <span class="docEmphasis">open</span> looks like
the following, which refers to our hypothetical
<span class="docEmphasis">dad</span> module. The <span class="docEmphasis">dad</span> device
as shown uses a fast interrupt handler without support for shared IRQ
lines.</p>

<pre>int dad_open (struct inode *inode, struct file *filp)
{
    struct dad_device *my_device; 

    /* ... */
    if ( (error = request_irq(my_device.irq, dad_interrupt,
                              SA_INTERRUPT, "dad", NULL)) )
        return error; /* or implement blocking open */

    if ( (error = request_dma(my_device.dma, "dad")) ) {
        free_irq(my_device.irq, NULL);
        return error; /* or implement blocking open */
    }
    /* ... */
    return 0;
}</pre><br>


<p class="docText">The <span class="docEmphasis">close</span> implementation that matches the
<span class="docEmphasis">open</span> just shown looks like this:</p>

<pre>void dad_close (struct inode *inode, struct file *filp)
{
    struct dad_device *my_device;

    /* ... */
    free_dma(my_device.dma);
    free_irq(my_device.irq, NULL);
    /* ... */
}</pre><br>


<p class="docText">Here's how the <i>/proc/dma</i> file
looks on a system with the sound card installed:</p>

<pre>merlino% <b>cat /proc/dma</b>
 1: Sound Blaster8
 4: cascade</pre><br>


<p class="docText">It's interesting to note that the default sound
driver gets the DMA channel at system boot and never releases it. The
<tt>cascade</tt> entry is a placeholder, indicating that
channel 4 is not available to drivers, as explained earlier.</p>



<a name="chp-15-sect-4.5.2"></a>
<h5 class="docSection3Title">15.4.5.2 Talking to the DMA controller</h5>

<p class="docText">After registration, the main part of the driver's
job consists of configuring the DMA controller for proper operation.
This task is not trivial, but fortunately, the kernel exports all the
functions needed by the typical driver.</P>

<p class="docText"><a name="chp-15-ITERM-7247"></a>
<a name="chp-15-ITERM-7248"></a><a name="chp-15-ITERM-7249"></a>The driver needs to configure the
DMA controller either when <span class="docEmphasis">read</span> or
<span class="docEmphasis">write</span> is called, or when preparing for
asynchronous transfers. This latter task is performed either at
<span class="docEmphasis">open</span> time or in response to an
<span class="docEmphasis">ioctl</span> command, depending on the driver and the
policy it implements. The code shown here is the code that is
typically called by the <span class="docEmphasis">read</span> or
<span class="docEmphasis">write</span> device methods.</p>

<p class="docText">This subsection provides a quick overview of the internals of the DMA
controller so you understand the code introduced here. If you want to
learn more, we'd urge you to read
<I>&lt;asm/dma.h&gt;</I> and some hardware manuals
describing the PC architecture. In particular, we
don't deal with the issue of 8-bit versus 16-bit
data transfers. If you are writing device drivers for ISA device
boards, you should find the relevant information in the hardware
manuals for the devices.</p>

<p class="docText"><a name="chp-15-ITERM-7250"></a><a name="chp-15-ITERM-7251"></a>The
DMA controller is a shared resource, and confusion could arise if
more than one processor attempts to program it simultaneously. For
that reason, the controller is protected by a spinlock, called
<tt>dma_spin_lock</tt>. Drivers should not manipulate the
lock directly; however, two functions have been provided to do that
for you:</p>

<a name="chp-15-ITERM-7252"></a><a name="chp-15-ITERM-7253"></a><a name="chp-15-ITERM-7254"></a><a name="chp-15-ITERM-7255"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long claim_dma_lock(  );</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7252"></a>
<a name="chp-15-ITERM-7253"></a>Acquires
the DMA spinlock. This function also blocks interrupts on the local
processor; therefore, the return value is a set of flags describing
the previous interrupt state; it must be passed to the following
function to restore the interrupt state when you are done with the
lock.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void release_dma_lock(unsigned long flags);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7254"></a>
<a name="chp-15-ITERM-7255"></a>Returns
the DMA spinlock and restores the previous interrupt status.</p>
</dd>
</dl>

<p class="docText">The spinlock should be held when using the functions described next.
It should <span class="docEmphasis">not</span> be held during the actual I/O,
however. A driver should never sleep when holding a spinlock.</p>

<p class="docText">The information that must be loaded into the controller consists of
three items: the RAM address, the number of atomic items that must be
transferred (in bytes or words), and the direction of the transfer.
To this end, the following functions are exported by
<i>&lt;asm/dma.h&gt;</I>:</P>

<a name="chp-15-ITERM-7256"></a><a name="chp-15-ITERM-7257"></a><a name="chp-15-ITERM-7258"></a><a name="chp-15-ITERM-7259"></a><a name="chp-15-ITERM-7260"></a><a name="chp-15-ITERM-7261"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void set_dma_mode(unsigned int channel, char mode);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-15-ITERM-7256"></a>
<a name="chp-15-ITERM-7257"></a>Indicates
whether the channel must read from the device
(<tt>DMA_MODE_READ</tt>) or write to it
(<tt>DMA_MODE_WRITE</tt>). A third mode exists,
<tt>DMA_MODE_CASCADE</tt>, which is used to release control
of the bus. Cascading is the way the first controller is connected to
the top of the second, but it can also be used by true ISA bus-master
devices. We won't discuss bus mastering here.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void set_dma_addr(unsigned int channel, unsigned int addr);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7258"></a>
<a name="chp-15-ITERM-7259"></a>Assigns
the address of the DMA buffer. The function stores the 24 least
significant bits of <tt>addr</tt> in the controller. The
<tt>addr</tt> argument must be a <span class="docEmphasis">bus</span>
address (see the <a class="docLink" href="chp-15-sect-4.shtml#chp-15-sect-4.3">Section 15.4.3</a> earlier in this chapter).</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void set_dma_count(unsigned int channel, unsigned int count);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7260"></a>
<a name="chp-15-ITERM-7261"></a>Assigns
the number of bytes to transfer. The <tt>count</tt>
argument represents bytes for 16-bit channels as well; in this case,
the number <span class="docEmphasis">must</span> be even.</P>
</dd>
</dl>

<p class="docText">In addition to these functions, there are a number of housekeeping
facilities that must be used when dealing with DMA devices:</p>

<a name="chp-15-ITERM-7262"></a><a name="chp-15-ITERM-7263"></a><a name="chp-15-ITERM-7264"></a><a name="chp-15-ITERM-7265"></a><a name="chp-15-ITERM-7266"></a><a name="chp-15-ITERM-7267"></a><a name="chp-15-ITERM-7268"></a><a name="chp-15-ITERM-7269"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void disable_dma(unsigned int channel);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7262"></a>
<a name="chp-15-ITERM-7263"></a>A
DMA channel can be disabled within the controller. The channel should
be disabled before the controller is configured to prevent improper
operation. (Otherwise, corruption can occur because the controller is
programmed via 8-bit data transfers and, therefore, none of the
previous functions is executed atomically).</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void enable_dma(unsigned int channel);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7264"></a>
<a name="chp-15-ITERM-7265"></a>This
function tells the controller that the DMA channel contains valid
data.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int get_dma_residue(unsigned int channel);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7266"></a>
<a name="chp-15-ITERM-7267"></a>The
driver sometimes needs to know whether a DMA transfer has been
completed. This function returns the number of bytes that are still
to be transferred. The return value is <tt>0</tt> after a
successful transfer and is unpredictable (but not
<tt>0</tt>) while the controller is working. The
unpredictability springs from the need to obtain the 16-bit residue
through two 8-bit input operations.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void clear_dma_ff(unsigned int channel)</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7268"></a>
<a name="chp-15-ITERM-7269"></a>This
function clears the DMA flip-flop. The flip-flop is used to control
access to 16-bit registers. The registers are accessed by two
consecutive 8-bit operations, and the flip-flop is used to select the
least significant byte (when it is clear) or the most significant
byte (when it is set). The flip-flop automatically toggles when eight
bits have been transferred; the programmer must clear the flip-flop
(to set it to a known state) before accessing the DMA registers.</p>
</dd>
</dl>

<p class="docText">Using these functions, a driver can implement a function like the
following to prepare for a DMA transfer:</p>

<pre>int dad_dma_prepare(int channel, int mode, unsigned int buf,
                    unsigned int count)
{
    unsigned long flags;

    flags = claim_dma_lock(  );
    disable_dma(channel);
    clear_dma_ff(channel);
    set_dma_mode(channel, mode);
    set_dma_addr(channel, virt_to_bus(buf));
    set_dma_count(channel, count);
    enable_dma(channel);
    release_dma_lock(flags);

    return 0;
}</pre><BR>


<p class="docText">Then, a function like the next one is used to check for
successful<a name="chp-15-ITERM-7270"></a> completion of DMA:</p>

<pre>int dad_dma_isdone(int channel)
{
    int residue;
    unsigned long flags = claim_dma_lock (  );
    residue = get_dma_residue(channel);
    release_dma_lock(flags);
    return (residue =  = 0);
}</pre><BR>


<p class="docText">The only thing that remains to be done is to configure the device
board. This device-specific task usually consists of reading or
writing a few I/O ports. Devices differ in significant ways. For
example, some devices expect the programmer to tell the hardware how
big the DMA buffer is, and sometimes the driver has to read a value
that is hardwired into the device. For configuring the<a name="chp-15-ITERM-7271"></a> <a name="chp-15-ITERM-7272"></a> <a name="chp-15-ITERM-7273"></a> <a name="chp-15-ITERM-7274"></a> <a name="chp-15-ITERM-7275"></a> board, the
hardware manual is your <a name="chp-15-ITERM-7276"></a>only <a name="chp-15-ITERM-7277"></a>friend. <a name="chp-15-ITERM-7278"></a></P>




<ul></ul></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-15-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-15-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
