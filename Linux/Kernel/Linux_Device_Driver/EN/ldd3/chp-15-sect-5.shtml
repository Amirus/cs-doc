<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>15.5. Quick Reference</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-15-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-16.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-15-sect-5"></a>
<h3 class="docSection1Title">15.5. Quick Reference</h3>

<p class="docText">This chapter introduced the following symbols related to memory
handling.</p>

<a name="chp-15-sect-5.1"></a>
<h4 class="docSection2Title">15.5.1. Introductory Material</h4>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/mm.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/page.h&gt;</span></span></span></dt></p>
<dd>
<p class="docList">Most of the functions and structures related to memory management are
prototyped and defined in these header files.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *_ _va(unsigned long physaddr);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long _ _pa(void *kaddr);</span></span></span></dt></p>
<dd>
<p class="docList">Macros that convert between kernel logical addresses and physical
addresses.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PAGE_SIZE</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PAGE_SHIFT</span></span></span></dt></p>
<dd>
<p class="docList">Constants that give the size (in bytes) of a page on the underlying
hardware and the number of bits that a page frame number must be
shifted to turn it into a physical address.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page</span></span></span></dt></P>
<dd>
<p class="docList">Structure that represents a hardware page in the system memory map.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page *virt_to_page(void *kaddr);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *page_address(struct page *page);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page *pfn_to_page(int pfn);</span></span></span></dt></P>
<dd>
<p class="docList">Macros that convert between kernel logical addresses and their
associated memory map entries. <span class="docEmphasis">page_address</span>
works only for low-memory pages or high-memory pages that have been
explicitly mapped. <span class="docEmphasis">pfn_to_page</span> converts a page
frame number to its associated <tt>struct</tt>
<tt>page</tt> pointer.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long kmap(struct page *page);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void kunmap(struct page *page);</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">kmap</span> returns a kernel virtual address that is
mapped to the given page, creating the mapping if need be.
<span class="docEmphasis">kunmap</span> deletes the mapping for the given page.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/highmem.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/kmap_types.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *kmap_atomic(struct page *page, enum km_type type);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void kunmap_atomic(void *addr, enum km_type type);</span></span></span></dt></p>
<dd>
<p class="docList">The high-performance version of <span class="docEmphasis">kmap</span>; the
resulting mappings can be held only by atomic code. For drivers,
<tt>type</tt> should be <tt>KM_USER0</tt>,
<tt>KM_USER1</tt>, <tt>KM_IRQ0</tt>, or
<tt>KM_IRQ1</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct vm_area_struct;</span></span></span></dt></P>
<dd>
<p class="docList">Structure describing a VMA.</P>
</dd>
</dl>


<a name="chp-15-sect-5.2"></a>
<h4 class="docSection2Title">15.5.2. Implementing mmap</h4>

<a name="chp-15-ITERM-7279"></a><a name="chp-15-ITERM-7280"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int remap_pfn_range(struct vm_area_struct *vma, unsigned long virt_add</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">unsigned long pfn, unsigned long size, pgprot_t prot);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int io_remap_page_range(struct vm_area_struct *vma, unsigned long virt_add</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">unsigned long phys_add, unsigned long size, pgprot_t prot);</span></span></span></dt></P>
<dd>
<p class="docList">Functions<a name="chp-15-ITERM-7279"></a>
<a name="chp-15-ITERM-7280"></a>
that sit at the heart of <span class="docEmphasis">mmap</span>. They map
<tt>size</tt> bytes of physical addresses, starting at the
page number indicated by <tt>pfn</tt> to the virtual
address <tt>virt_add</tt>. The protection bits associated
with the virtual space are specified in <tt>prot</tt>.
<span class="docEmphasis">io_remap_page_range</span> should be used when the
target address is in I/O memory space.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page *vmalloc_to_page(void *vmaddr);</span></span></span></dt></P>
<dd>
<p class="docList">Converts a kernel virtual address obtained from
<span class="docEmphasis">vmalloc</span> to its corresponding <tt>struct
page</tt> pointer.</p>
</dd>
</dl>


<a name="chp-15-sect-5.3"></a>
<h4 class="docSection2Title">15.5.3. Implementing Direct I/O</h4>

<a name="chp-15-ITERM-7281"></a><a name="chp-15-ITERM-7282"></a><a name="chp-15-ITERM-7283"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int get_user_pages(struct task_struct *tsk, struct mm_struct *mm, unsigned</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">long start, int len, int write, int force, struct page **pages, struct</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">vm_area_struct **vmas);</span></span></span></dt></p>
<dd>
<p class="docList">Function that locks a user-space buffer into memory and returns the
corresponding <tt>struct page</tt> pointers. The caller
must hold <tt>mm-&gt;mmap_sem</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SetPageDirty(struct page *page);</span></span></span></dt></p>
<dd>
<p class="docList">Macro that
<a name="chp-15-ITERM-7281"></a> <a name="chp-15-ITERM-7282"></a>
<a name="chp-15-ITERM-7283"></a>marks
the given page as "dirty"
(modified) and in need of writing to its backing store before it can
be freed.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void page_cache_release(struct page *page);</span></span></span></dt></p>
<dd>
<p class="docList">Frees the given page from the page cache.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int is_sync_kiocb(struct kiocb *iocb);</span></span></span></dt></p>
<dd>
<p class="docList">Macro that returns nonzero if the given IOCB requires synchronous
execution.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int aio_complete(struct kiocb *iocb, long res, long res2);</span></span></span></dt></p>
<dd>
<p class="docList">Function that indicates completion of an asynchronous I/O operation.</P>
</dd>
</dl>


<a name="chp-15-sect-5.4"></a>
<H4 class="docSection2Title">15.5.4. Direct Memory Access</h4>

<a name="chp-15-ITERM-7284"></a><a name="chp-15-ITERM-7285"></a><a name="chp-15-ITERM-7286"></a><a name="chp-15-ITERM-7287"></a><a name="chp-15-ITERM-7288"></a><a name="chp-15-ITERM-7289"></a><a name="chp-15-ITERM-7290"></a><a name="chp-15-ITERM-7291"></a><a name="chp-15-ITERM-7292"></a><a name="chp-15-ITERM-7293"></a><a name="chp-15-ITERM-7294"></a><a name="chp-15-ITERM-7295"></a><a name="chp-15-ITERM-7296"></a><a name="chp-15-ITERM-7297"></a><a name="chp-15-ITERM-7298"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/io.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long virt_to_bus(volatile void * address);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void * bus_to_virt(unsigned long address);</span></span></span></dt></p>
<dd>
<p class="docList">Obsolete and deprecated functions that convert between kernel,
virtual, and bus addresses. Bus addresses must be used to talk to
peripheral devices.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/dma-mapping.h&gt;</span></span></span></dt></P>
<dd>
<p class="docList">Header file required to define the generic DMA functions.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int dma_set_mask(struct device *dev, u64 mask);</span></span></span></dt></P>
<dd>
<p class="docList">For
<a name="chp-15-ITERM-7284"></a>
<a name="chp-15-ITERM-7285"></a>
<a name="chp-15-ITERM-7286"></a>
<a name="chp-15-ITERM-7287"></a>peripherals
that cannot address the full 32-bit range, this function informs the
kernel of the addressable range and returns nonzero if DMA is
possible.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">*bus_addr, int flag)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dma_free_coherent(struct device *dev, size_t size, void *cpuaddr</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">dma_handle_t bus_addr);</span></span></span></dt></P>
<dd>
<p class="docList">Allocate and free coherent DMA mappings for a buffer that will last
the lifetime of the driver.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/dmapool.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct dma_pool *dma_pool_create(const char *name, struct device *dev</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">size_t</span></span> <span class="docPubcolor"><span class="docMonofont">size, size_t align, size_t allocation);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dma_pool_destroy(struct dma_pool *pool);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *dma_pool_alloc(struct dma_pool *pool, int mem_flags, dma_addr_t</span></span></span></dt></P>
<dt><span class="docPubcolor">   <span class="docPubcolor"><span class="docMonofont">*handle);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t handle);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that create, destroy, and use DMA pools to manage small DMA
areas.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">enum dma_data_direction;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DMA_TO_DEVICE</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DMA_FROM_DEVICE</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DMA_BIDIRECTIONAL</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DMA_NONE</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7288"></a>
<a name="chp-15-ITERM-7289"></a><a name="chp-15-ITERM-7290"></a><a name="chp-15-ITERM-7291"></a><a name="chp-15-ITERM-7292"></a>Symbols used to tell the streaming
mapping functions the direction in which data is moving to or from
the buffer.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">dma_addr_t dma_map_single(struct device *dev, void *buffer, size_t size, enum</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">dma_data_direction direction);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dma_unmap_single(struct device *dev, dma_addr_t bus_addr, size_t size</span></span>, </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">enum dma_data_direction direction);</span></span></span></dt></p>
<dd>
<p class="docList">Create and destroy a single-use, streaming DMA mapping.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dma_sync_single_for_cpu(struct device *dev, dma_handle_t bus_addr, size_t</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">size, enum dma_data_direction direction);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dma_sync_single_for_device(struct device *dev, dma_handle_t bus_addr</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">size_t size, enum dma_data_direction direction);</span></span></span></dt></P>
<dd>
<p class="docList">Synchronizes a buffer that has a streaming mapping. These functions
must be used if the processor must access a buffer while the
streaming mapping is in place (i.e., while the device owns the
buffer).</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/scatterlist.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct scatterlist { /* ... */ };</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">dma_addr_t sg_dma_address(struct scatterlist *sg);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int sg_dma_len(struct scatterlist *sg);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-15-ITERM-7293"></a>
<a name="chp-15-ITERM-7294"></a><a name="chp-15-ITERM-7295"></a>
<a name="chp-15-ITERM-7296"></a><a name="chp-15-ITERM-7297"></a>
<a name="chp-15-ITERM-7298"></a>The
<tt>scatterlist</tt> structure describes an I/O operation
that involves more than one buffer. The macros
<span class="docEmphasis">sg_dma_address</span> and
<span class="docEmphasis">sg_dma_len</span> may be used to extract bus addresses
and buffer lengths to pass to the device when implementing
scatter/gather operations.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">dma_map_sg(struct device *dev, struct scatterlist *list, int nents</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">enum dma_data_direction direction);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">dma_unmap_sg(struct device *dev, struct scatterlist *list, int nents, enum</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">dma_data_direction direction);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int</span></span></span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">nents, enum dma_data_direction direction);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg, int</span></span></span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">nents, enum dma_data_direction direction);</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">dma_map_sg</span> maps a scatter/gather operation, and
<span class="docEmphasis">dma_unmap_sg</span> undoes that mapping. If the buffers
must be accessed while the mapping is active,
<span class="docEmphasis">dma_sync_sg_*</span> may be used to synchronize things.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">/proc/dma</span></span></span></dt></p>
<dd>
<p class="docList">File that contains a textual snapshot of the allocated channels in
the DMA controllers. PCI-based DMA is not shown because each board
works independently, without the need to allocate a channel in the
DMA controller.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/dma.h&gt;</span></span></span></dt></P>
<dd>
<p class="docList">Header that defines or prototypes all the functions and macros
related to DMA. It must be included to use any of the following
symbols.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int request_dma(unsigned int channel, const char *name);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void free_dma(unsigned int channel);</span></span></span></dt></P>
<dd>
<p class="docList">Access the DMA registry. Registration must be performed before using
ISA DMA channels.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long claim_dma_lock(  );</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void release_dma_lock(unsigned long flags);</span></span></span></dt></p>
<dd>
<p class="docList">Acquire and release the DMA spinlock, which must be held prior to
calling the other ISA DMA functions described later in this list.
They also disable and reenable interrupts on the local processor.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void set_dma_mode(unsigned int channel, char mode);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void set_dma_addr(unsigned int channel, unsigned int addr);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void set_dma_count(unsigned int channel, unsigned int count);</span></span></span></dt></p>
<dd>
<p class="docList">Program DMA information in the DMA controller.
<tt>addr</tt> is a bus address.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void disable_dma(unsigned int channel);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void enable_dma(unsigned int channel);</span></span></span></dt></p>
<dd>
<p class="docList">A DMA channel must be disabled during configuration. These functions
change the status of the DMA channel.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int get_dma_residue(unsigned int channel);</span></span></span></dt></p>
<dd>
<p class="docList">If the driver needs to know how a DMA transfer is proceeding, it can
call this function, which returns the number of data transfers that
are yet to be completed. After successful completion of DMA, the
function returns <tt>0</tt>; the value is unpredictable
while data is being transferred.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void clear_dma_ff(unsigned int channel)</span></span></span></dt></p>
<dd>
<p class="docList">The DMA flip-flop is used by the controller to transfer 16-bit values
by means of two 8-bit operations. It must be cleared before sending
any data to the controller.</p>
</dd>
</dl>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-15-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-16.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
