<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>14.7. Hotplug</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-14-sect-7"></a>
<H3 class="docSection1Title">14.7. Hotplug</H3>

<p class="docText">There are two different ways to<a name="chp-14-ITERM-6837"></a>
<a name="chp-14-ITERM-6838"></a>
<a name="chp-14-ITERM-6839"></a>
<a name="chp-14-ITERM-6840"></a>
<a name="chp-14-ITERM-6841"></a> view hotplugging. The kernel
views hotplugging as an interaction between the hardware, the kernel,
and the kernel driver. Users view hotplugging as the interaction
between the kernel and user space through the program called
<span class="docEmphasis">/sbin/hotplug</span>. This program is called by the
kernel when it wants to notify user space that some type of hotplug
event has just happened within the kernel.</p>

<a name="chp-14-sect-7.1"></a>
<h4 class="docSection2Title">14.7.1. Dynamic Devices</h4>

<p class="docText">The most commonly used meaning <a name="chp-14-ITERM-6842"></a>
<a name="chp-14-ITERM-6843"></a>of
the term "hotplug" happens when
discussing the fact that most all computer systems can now handle
devices appearing or disappearing while the system is powered on.
This is very different from the computer systems of only a few years
ago, where the programmers knew that they needed to scan for all
devices only at boot time, and they never had to worry about their
devices disappearing until the power was turned off to the whole
machine. Now, with the advent of USB, CardBus, PCMCIA, IEEE1394, and
PCI Hotplug controllers, the Linux kernel needs to be able to
reliably run no matter what hardware is added or removed from the
system. This places an added burden on the device driver author, as
they must now always handle a device being suddenly ripped out from
underneath them without any notice.</p>

<p class="docText">Each different bus type handles the loss of a device in a different
way. For example, when a PCI, CardBus, or PCMCIA device is removed
from the system, it is usually a while before the driver is notified
of this action through its <span class="docEmphasis">remove</span> function.
Before that happens, all reads from the PCI bus return all bits set.
This means that drivers need to always check the value of the data
they read from the PCI bus and properly be able to handle a
<tt>0xff</tt> value.</P>

<p class="docText">An example of this can be seen in the
<span class="docEmphasis">drivers/usb/host/ehci-hcd.c</span> driver, which is a
PCI driver for a USB 2.0 (high-speed) controller card. It has the
following code in its main handshake loop to detect if the controller
card has been removed from the system:</p>

<pre>result = readl(ptr);
if (result =  = ~(u32)0)    /* card removed */
    return -ENODEV;</pre><br>


<p class="docText">For USB drivers, when the device that a USB driver is bound to is
removed from the system, any pending urbs that were submitted to the
device start failing with the error <tt>-ENODEV</tt>. The
driver needs to recognize this error and properly clean up any
pending I/O if it occurs.</P>

<p class="docText">Hotpluggable devices are not limited only to traditional devices such
as mice, keyboards, and network cards. There are numerous systems
that now support removal and addition of entire CPUs and memory
sticks. Fortunately the Linux kernel properly handles the addition
and removal of such core "system"
devices so that individual device drivers do not need to pay
attention to these things.</p>


<a name="chp-14-sect-7.2"></a>
<h4 class="docSection2Title">14.7.2. The /sbin/hotplug Utility</H4>

<p class="docText">As alluded to earlier in this chapter, whenever a device is added or
removed from the system, a "hotplug
event" is generated. This means that the kernel
calls the user-space program <a name="chp-14-ITERM-6844"></a>
<a name="chp-14-ITERM-6845"></a>
<a name="chp-14-ITERM-6846"></a><span class="docEmphasis">/sbin/hotplug</span>.
This program is typically a very small bash script that merely passes
execution on to a list of other programs that are placed in the
<span class="docEmphasis">/etc/hotplug.d/</span> directory tree. For most Linux
distributions, this script looks like the following:</p>

<pre>DIR="/etc/hotplug.d"
for I in "${DIR}/$1/"*.hotplug "${DIR}/"default/*.hotplug ; do
    if [ -f $I ]; then
        test -x $I &amp;&amp; $I $1 ;
    fi
done
exit 1</pre><BR>


<p class="docText">In other words, the script searches for all programs bearing a
<i>.hotplug</i> suffix that might be interested in this
event and invokes them, passing to them a number of different
environment variables that have been set by the kernel. More details
about how the <span class="docEmphasis">/sbin/hotplug</span> script works can be
found in the comments in the program and in the
<span class="docEmphasis">hotplug(8)</span> manpage.</p>

<p class="docText">As mentioned previously, <span class="docEmphasis">/sbin/hotplug</span> is called
whenever a kobject is created or destroyed. The hotplug program is
called with a single command-line argument providing a name for the
event. The core kernel and specific subsystem involved also set a
series of environment variables (described below) with information on
what has just occurred. These variables are used by the hotplug
programs to determine what has just happened in the kernel, and if
there is any specific action that should take place.</p>

<p class="docText">The command-line argument passed to
<span class="docEmphasis">/sbin/hotplug</span> is the name associated with this
hotplug event, as determined by the kset assigned to the kobject.
This name can be set by a call to the <span class="docEmphasis">name</span>
function that is part of the kset's
<tt>hotplug_ops</tt> structure described earlier in this
chapter; if that function is not present or never called, the name is
that of the kset itself.</p>

<p class="docText">The default environment variables that are always set for the
<span class="docEmphasis">/sbin/hotplug</span> program are:</p>

<a name="chp-14-ITERM-6847"></a><a name="chp-14-ITERM-6848"></a><a name="chp-14-ITERM-6849"></a><a name="chp-14-ITERM-6850"></a><a name="chp-14-ITERM-6851"></a><a name="chp-14-ITERM-6852"></a><a name="chp-14-ITERM-6853"></a><a name="chp-14-ITERM-6854"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ACTION</span></span><a name="chp-14-ITERM-6847"></a>
<a name="chp-14-ITERM-6848"></a> </span></dt></p>
<dd>
<p class="docList">The string <tt>add</tt> or <tt>remove</tt>,
depending on whether the object in question was just created or
destroyed.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DEVPATH</span></span><a name="chp-14-ITERM-6849"></a>
<a name="chp-14-ITERM-6850"></a> </span></dt></p>
<dd>
<p class="docList">A directory path, within the sysfs filesystem, that points to the
kobject that is being either created or destroyed. Note that the
mount point of the sysfs filesystem is not added to this path, so it
is up to the user-space program to determine that.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SEQNUM</span></span><a name="chp-14-ITERM-6851"></a>
<a name="chp-14-ITERM-6852"></a> </span></dt></P>
<dd>
<p class="docList">The sequence number for this hotplug event. The sequence number is a
64-bit number that is incremented for every hotplug event that is
generated. This allows user space to sort the hotplug events in the
order in which the kernel generates them, as it is possible for a
user-space program to be run out of order.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SUBSYSTEM</span></span> <a name="chp-14-ITERM-6853"></a>
<a name="chp-14-ITERM-6854"></a></span></dt></P>
<dd>
<p class="docList">The same string passed as the command-line argument as described
above.</p>
</dd>
</dl>

<p class="docText">A number of the different bus subsystems all add their own
environment variables to the <span class="docEmphasis">/sbin/hotplug</span> call,
when devices associated with the bus are added or removed from the
system. They do this in their <span class="docEmphasis">hotplug</span> callback
that is specified in the <tt>struct</tt>
<tt>kset_hotplug_ops</tt> assigned to their bus (as
described in <a class="docLink" href="chp-14-sect-3.shtml#chp-14-sect-3.1">Section 14.3.1</a>). This allows user space to be able
to automatically load any necessary module that might be needed to
control the device that has been found by the bus. Here is a list of
the different bus types and what environment variables they add to
the <span class="docEmphasis">/sbin/hotplug</span> call.</P>

<a name="chp-14-sect-7.2.1"></a>
<H5 class="docSection3Title">14.7.2.1 IEEE1394 (FireWire)</H5>

<p class="docText">Any devices on the <a name="chp-14-ITERM-6855"></a>
<a name="chp-14-ITERM-6856"></a>
<a name="chp-14-ITERM-6857"></a>
<a name="chp-14-ITERM-6858"></a>IEEE1394 bus, also known as
Firewire, have the <span class="docEmphasis">/sbin/hotplug</span> parameter name
and the <tt>SUBSYSTEM</tt> environment variable set to the
value <tt>ieee1394</tt>. The <tt>ieee1394</tt>
subsystem also always adds the following four environment variables:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">VENDOR_ID</span></span> </span></dt></p>
<dd>
<p class="docList">The 24-bit vendor ID for the IEEE1394 device</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">MODEL_ID</span></span> </span></dt></p>
<dd>
<p class="docList">The 24-bit model ID for the IEEE1394 device</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">GUID</span></span> </span></dt></p>
<dd>
<p class="docList">The 64-bit GUID for the device</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SPECIFIER_ID</span></span> </span></dt></p>
<dd>
<p class="docList">The 24-bit value specifying the owner of the protocol spec for this
device</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">VERSION</span></span> </span></dt></p>
<dd>
<p class="docList">The value that specifies the version of the protocol spec for this
device</P>
</dd>
</dl>



<a name="chp-14-sect-7.2.2"></a>
<h5 class="docSection3Title">14.7.2.2 Networking</H5>

<p class="docText">All <a name="chp-14-ITERM-6859"></a>
<a name="chp-14-ITERM-6860"></a>network
devices create a hotplug event when the device is registered or
unregistered in the kernel. The <span class="docEmphasis">/sbin/hotplug</span>
call has the parameter name and the <tt>SUBSYSTEM</tt>
environment variable set to the value <tt>net</tt>, and
just adds the following environment variable:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">INTERFACE</span></span> </span></dt></p>
<dd>
<p class="docList">The name of the interface that has been registered or unregistered
from the kernel. Examples of this are <tt>lo</tt> and
<tt>eth0</tt>.</p>
</dd>
</dl>



<a name="chp-14-sect-7.2.3"></a>
<h5 class="docSection3Title">14.7.2.3 PCI</h5>

<p class="docText">Any devices on the PCI bus have the parameter name and the
<tt>SUBSYSTEM</tt> environment variable set to the value
<tt>pci</tt>. The PCI subsystem also always adds the
following four environment variables:</p>

<a name="chp-14-ITERM-6861"></a><a name="chp-14-ITERM-6862"></a><a name="chp-14-ITERM-6863"></a><a name="chp-14-ITERM-6864"></a><a name="chp-14-ITERM-6865"></a><a name="chp-14-ITERM-6866"></a><a name="chp-14-ITERM-6867"></a><a name="chp-14-ITERM-6868"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PCI_CLASS</span></span><a name="chp-14-ITERM-6861"></a>
<a name="chp-14-ITERM-6862"></a> </span></dt></p>
<dd>
<p class="docList">The PCI class number for the device, in hex.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PCI_ID</span></span><a name="chp-14-ITERM-6863"></a>
<a name="chp-14-ITERM-6864"></a> </span></dt></p>
<dd>
<p class="docList">The PCI vendor and device IDs for the device, in hex, combined in the
format <tt>vendor</tt>:<tt>device</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PCI_SUBSYS_ID</span></span><a name="chp-14-ITERM-6865"></a>
<a name="chp-14-ITERM-6866"></a> </span></dt></p>
<dd>
<p class="docList">The PCI subsystem vendor and subsystem device IDs, combined in the
format
<tt>subsys_vendor</tt>:<tt>subsys_device</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PCI_SLOT_NAME</span></span><a name="chp-14-ITERM-6867"></a>
<a name="chp-14-ITERM-6868"></a> </span></dt></P>
<dd>
<p class="docList">The PCI slot "name" that is given
to the device by the kernel. It is in the format
<tt>domain</tt>:<tt>bus</tt>:<tt>slot</tt>:<tt>function</tt>.
An example might be <tt>0000:00:0d.0</tt>.</P>
</dd>
</dl>



<a name="chp-14-sect-7.2.4"></a>
<H5 class="docSection3Title">14.7.2.4 Input</h5>

<p class="docText">For all <a name="chp-14-ITERM-6869"></a>
<a name="chp-14-ITERM-6870"></a>
<a name="chp-14-ITERM-6871"></a>
<a name="chp-14-ITERM-6872"></a>
<a name="chp-14-ITERM-6873"></a>input devices (mice, keyboards,
joysticks, etc.), a hotplug event is generated when the device is
added and removed from the kernel. The
<span class="docEmphasis">/sbin/hotplug</span> parameter and the
<tt>SUBSYSTEM</tt> environment variable are set to the
value <tt>input</tt>. The input subsystem also always adds
the following environment variable:</p>

<a name="chp-14-ITERM-6874"></a><a name="chp-14-ITERM-6875"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PRODUCT</span></span><a name="chp-14-ITERM-6874"></a>
<a name="chp-14-ITERM-6875"></a> </span></dt></P>
<dd>
<p class="docList">A multivalue string listing values in hex with no leading zeros. It
is in the format
<tt>bustype</tt>:<tt>vendor</tt>:<tt>product</tt>:<tt>version</tt>.</P>
</dd>
</dl>

<p class="docText">The following environment variables may be present, if the device
supports it:</P>

<a name="chp-14-ITERM-6876"></a><a name="chp-14-ITERM-6877"></a><a name="chp-14-ITERM-6878"></a><a name="chp-14-ITERM-6879"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">NAME</span></span><a name="chp-14-ITERM-6876"></a>
<a name="chp-14-ITERM-6877"></a> </span></dt></P>
<dd>
<p class="docList">The name of the input device as given by the device.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PHYS</span></span><a name="chp-14-ITERM-6878"></a>
<a name="chp-14-ITERM-6879"></a> </span></dt></p>
<dd>
<p class="docList">The device's physical address that the input
subsystem gave to this device. It is supposed to be stable, depending
on the bus position into which the device was plugged.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">EV</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KEY</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">REL</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ABS</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">MSC</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">LED</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SND</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">FF</span></span></span></dt></P>
<dd>
<p class="docList">These all come from the input device descriptor and are set to the
appropriate values if the specific input device supports it.</P>
</dd>
</dl>



<a name="chp-14-sect-7.2.5"></a>
<h5 class="docSection3Title">14.7.2.5 USB</h5>

<p class="docText">Any devices on the <a name="chp-14-ITERM-6880"></a>USB bus
have <a name="chp-14-ITERM-6881"></a>the parameter name and the
<tt>SUBSYSTEM</tt> environment variable set to the value
<tt>usb</tt>. The USB subsystem also always adds the
following environment variables:</p>

<a name="chp-14-ITERM-6882"></a><a name="chp-14-ITERM-6883"></a><a name="chp-14-ITERM-6884"></a><a name="chp-14-ITERM-6885"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PRODUCT</span></span><a name="chp-14-ITERM-6882"></a>
<a name="chp-14-ITERM-6883"></a> </span></dt></P>
<dd>
<p class="docList">A string in the format
<tt>idVendor</tt>/<tt>idProduct</tt>/<tt>bcdDevice</tt>
that specifies those USB device-specific fields</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">TYPE</span></span><a name="chp-14-ITERM-6884"></a>
<a name="chp-14-ITERM-6885"></a> </span></dt></p>
<dd>
<p class="docList">A string in the format
<tt>bDeviceClass</tt>/<tt>bDeviceSubClass</tt>/<tt>bDeviceProtocol</tt>
that specifies those USB device-specific fields</p>
</dd>
</dl>

<p class="docText">If the <tt>bDeviceClass</tt> field is set to
<tt>0</tt>, the following environment variable is also set:</p>

<a name="chp-14-ITERM-6886"></a><a name="chp-14-ITERM-6887"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">INTERFACE</span></span><a name="chp-14-ITERM-6886"></a>
<a name="chp-14-ITERM-6887"></a> </span></dt></P>
<dd>
<p class="docList">A string in the format
<tt>bInterfaceClass</tt>/<tt>bInterfaceSubClass</tt>/<tt>bInterfaceProtocol</tt>
that specifies those USB device-specific fields.</p>
</dd>
</dl>

<p class="docText">If the kernel build option, <tt>CONFIG_USB_DEVICEFS</tt>,
which selects the <tt>usbfs</tt> filesystem to be built in
the kernel, is selected, the following environment variable is also
set:</P>

<a name="chp-14-ITERM-6888"></a><a name="chp-14-ITERM-6889"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DEVICE</span></span><a name="chp-14-ITERM-6888"></a>
<a name="chp-14-ITERM-6889"></a> </span></dt></p>
<dd>
<p class="docList">A string that shows where in the <tt>usbfs</tt> filesystem
the device is located. This string is in the format
<tt>/proc/bus/usb/USB_BUS_NUMBER/USB_DEVICE_NUMBER</tt>, in
which <tt>USB_BUS_NUMBER</tt> is the three-digit number of
the USB bus that the device is on, and
<tt>USB_DEVICE_NUMBER</tt> is the three-digit number that
has been assigned by the kernel to that USB device.</p>
</dd>
</dl>



<a name="chp-14-sect-7.2.6"></a>
<h5 class="docSection3Title">14.7.2.6 SCSI</H5>

<p class="docText">All SCSI devices create a hotplug event when the
<a name="chp-14-ITERM-6890"></a>
<a name="chp-14-ITERM-6891"></a>SCSI
device is created or removed from the kernel. The
<span class="docEmphasis">/sbin/hotplug</span> call has the parameter name and
the <tt>SUBSYSTEM</tt> environment variable set to the
value <tt>scsi</tt> for every SCSI device that is added or
removed from the system. There are no additional environment
variables added by the SCSI system, but it is mentioned here because
there is a SCSI-specific user-space script that can determine what
SCSI drivers (disk, tape, generic, etc.) should be loaded for the
specified SCSI device.</p>



<a name="chp-14-sect-7.2.7"></a>
<h5 class="docSection3Title">14.7.2.7 Laptop docking stations</H5>

<p class="docText">If a Plug-and-Play-supported <a name="chp-14-ITERM-6892"></a>laptop docking station is added or
removed from the running Linux system (by inserting the laptop into
the station, or removing it), a hotplug event is created. The
<span class="docEmphasis">/sbin/hotplug</span> call has the parameter name and
the <tt>SUBSYSTEM</tt> environment variable set to the
value <tt>dock</tt>. No other environment variables are
set.</p>



<a name="chp-14-sect-7.2.8"></a>
<h5 class="docSection3Title">14.7.2.8 S/390 and zSeries</H5>

<p class="docText">On the <a name="chp-14-ITERM-6893"></a>
<a name="chp-14-ITERM-6894"></a>
<a name="chp-14-ITERM-6895"></a>
<a name="chp-14-ITERM-6896"></a>S/390
architecture, the channel bus architecture supports a wide range of
hardware, all of which generate <span class="docEmphasis">/sbin/hotplug</span>
events when they are added or removed from the Linux virtual system.
These devices all have the <span class="docEmphasis">/sbin/hotplug</span>
parameter name and the <tt>SUBSYSTEM</tt> environment
variable set to the value <tt>dasd</tt>. No other
environment variables are set.</p>



<a name="chp-14-sect-7.3"></a>
<H4 class="docSection2Title">14.7.3. Using /sbin/hotplug</h4>

<p class="docText">Now that the Linux kernel is calling
<span class="docEmphasis">/sbin/hotplug</span> for every device added and removed
from the kernel, a number of very useful tools have been created in
user space that take advantage of this. Two of the most popular tools
are the Linux Hotplug scripts and <span class="docEmphasis">udev</span>.</p>

<a name="chp-14-sect-7.3.1"></a>
<h5 class="docSection3Title">14.7.3.1 Linux hotplug scripts</h5>

<p class="docText">The Linux hotplug<a name="chp-14-ITERM-6897"></a>
<a name="chp-14-ITERM-6898"></a>
scripts started out as the very first user of the
<span class="docEmphasis">/sbin/hotplug</span> call. These scripts look at the
different environment variables that the kernel sets to describe the
device that was just discovered and then tries to find a kernel
module that matches up with that device.</p>

<p class="docText">As has been described before, when a driver uses the
<tt>MODULE_DEVICE_TABLE</tt> macro, the program,
<tt>depmod</tt>, takes that information and creates the
files located in
<span class="docEmphasis">/lib/module/KERNEL_VERSION/modules.*map</span>. The
<tt>*</tt> is different, depending on the bus type that the
driver supports. Currently, the module map files are generated for
drivers that work for devices that support the PCI, USB, IEEE1394,
INPUT, ISAPNP, and CCW subsystems.</p>

<p class="docText">The hotplug scripts use these module map text files to determine what
module to try to load to support the device that was recently
discovered by the kernel. They load all modules and do not stop at
the first match, in order to let the kernel work out what module
works best. These scripts do not unload any modules when devices are
removed. If they were to try to do that, they could accidentally shut
down devices that were also controlled by the same driver of the
device that was removed.</p>

<p class="docText">Note, now that the <tt>modprobe</tt> program can read the
<tt>MODULE_DEVICE_TABLE</tt> information directly from the
modules without the need of the module map files, the hotplug scripts
might be reduced to a small wrapper around the
<tt>modprobe</tt> program.</p>



<a name="chp-14-sect-7.3.2"></a>
<h5 class="docSection3Title">14.7.3.2 udev</h5>

<p class="docText">One of the main reasons for creating the unified driver model in the
kernel was to allow user space to manage the
<span class="docEmphasis">/dev</span> tree in a dynamic fashion. This had
previously been done in user space with the implementation of devfs,
but that code base has slowly rotted away, due to a lack of an active
maintainer and some unfixable core bugs. A number of kernel
developers realized that if all device information was exported to
user space, it could perform all the necessary management of the
<span class="docEmphasis">/dev</span> tree.</p>

<p class="docText">devfs has some very fundamental flaws in its design. It requires
every device driver to be modified to support it, and it requires
that device driver to specify the name and location within
the<a name="chp-14-ITERM-6899"></a>
<a name="chp-14-ITERM-6900"></a> <span class="docEmphasis">/dev</span>
tree where it is placed. It also does not properly handle dynamic
major and minor numbers, and it does not allow user space to override
the naming of a device in a simple manner, forcing the device naming
policy to reside within the kernel and not in user space. Linux
kernel developers really hate having policy within the kernel, and
since the devfs naming policy does not follow the Linux Standard Base
specification, it really bothers them.</p>

<p class="docText">As the Linux kernel started to be installed on huge servers, a lot of
users ran into the problem of how to manage very large numbers of
devices. Disk drive arrays of over 10,000 unique devices presented
the very difficult task of ensuring that a specific disk was always
named with the same exact name, no matter where it was placed in the
disk array or when it was discovered by the kernel. This same problem
also plagued desktop users who tried to plug two USB printers into
their system and then realized that they had no way of ensuring that
the printer known as <span class="docEmphasis">/dev/lpt0</span> would not change
and be assigned to the other printer if the system was rebooted.</p>

<p class="docText">So, <span class="docEmphasis">udev</span> was created. It relies on all device
information being exported to user space through sysfs and on being
notified by <span class="docEmphasis">/sbin/hotplug</span> that a device was
added or removed. Policy decisions, such as what name to give a
device, can be specified in user space, outside of the kernel. This
ensures that the naming policy is removed from the kernel and allows
a large amount of flexibility about the name of each device.</P>

<p class="docText">For more information on how to use <span class="docEmphasis">udev</span> and how
to configure it, please see the documentation that comes included
with the <span class="docEmphasis">udev</span> package in your distribution.</p>

<p class="docText">All that a device driver needs to do, for <span class="docEmphasis">udev</span>
to work properly with it, is ensure that any major and minor numbers
assigned to a device controlled by the driver are exported to user
space through sysfs. For any driver that uses a subsystem to assign
it a major and minor number, this is already done by the subsystem,
and the driver doesn't have to do any work. Examples
of subsystems that do this are the tty, misc, usb, input, scsi,
block, i2c, network, and frame buffer subsystems. If your driver
handles getting a major and minor number on its own, through a call
to the <span class="docEmphasis">cdev_init</span> function or the older
<a name="chp-14-ITERM-6901"></a>
<a name="chp-14-ITERM-6902"></a><span class="docEmphasis">register_chrdev</span>
function, the driver needs to be modified in order for
<span class="docEmphasis">udev</span> to work properly with it.</P>

<p class="docText"><span class="docEmphasis">udev</span> looks for a file called
<tt>dev</tt> in the <span class="docEmphasis">/class/</span> tree of
sysfs, in order to determine what major and minor number is assigned
to a specific device when it is called by the kernel through the
<span class="docEmphasis">/sbin/hotplug</span> interface. A device driver merely
needs to create that file for every device it controls. The
<tt>class_simple</tt> interface is usually the easiest way
to do this.</P>

<p class="docText">As mentioned in <a class="docLink" href="chp-14-sect-5.shtml#chp-14-sect-5.1">Section 14.5.1</a> the first step in using the
<tt>class_simple</tt> interface is to create a
<tt>struct</tt> <tt>class_simple</tt> with a call
to the <a name="chp-14-ITERM-6903"></a>
<a name="chp-14-ITERM-6904"></a><span class="docEmphasis">class_simple_create</span>
function:</p>

<pre>static struct class_simple *foo_class;
...
foo_class = class_simple_create(THIS_MODULE, "foo");
if (IS_ERR(foo_class)) {
    printk(KERN_ERR "Error creating foo class.\n");
    goto error;
}</pre><br>


<p class="docText">This code creates a directory in sysfs in
<span class="docEmphasis">/sys/class/foo</span>.</p>

<p class="docText">Whenever a new device is found by your driver, and you assign it a
minor number as described in <a class="docLink" href="chp-3.shtml#chp-3">Chapter 3</a>, the driver should call the
<span class="docEmphasis">class_simple_device_add</span><a name="chp-14-ITERM-6905"></a>
<a name="chp-14-ITERM-6906"></a>
function:</P>

<pre>class_simple_device_add(foo_class, MKDEV(FOO_MAJOR, minor), NULL, "foo%d", minor);</pre><br>


<p class="docText">This code causes a subdirectory under
<span class="docEmphasis">/sys/class/foo</span> to be created called
<span class="docEmphasis">fooN</span>, where <span class="docEmphasis">N</span> is the minor
number for this device. There is one file created in this directory,
<span class="docEmphasis">dev</span>, which is exactly what
<span class="docEmphasis">udev</span> needs in order to create a device node for
your device.</P>

<p class="docText">When your driver is unbound from a device, and you give up the minor
number that it was attached to, a call to
<a name="chp-14-ITERM-6907"></a>
<a name="chp-14-ITERM-6908"></a><span class="docEmphasis">class_simple_device_remove</span>
is needed to remove the sysfs entries for this device:</P>

<pre>class_simple_device_remove(MKDEV(FOO_MAJOR, minor));</pre><BR>


<p class="docText">Later, when your entire driver is being shut down, a call to
<span class="docEmphasis">class_simple_destroy</span> is needed to remove the
class that you created originally with the call to
<span class="docEmphasis">class_simple_create</span>:</p>

<pre>class_simple_destroy(foo_class);</pre><br>


<p class="docText">The <span class="docEmphasis">dev</span> file that is created by the call to
<span class="docEmphasis">class_simple_device_add</span> consists of the major
and minor numbers, separated by a : character. If
your driver does not want to use the <tt>class_simple</tt>
interface because you want to provide other files within the class
directory for the subsystem, use the <span class="docEmphasis">print_dev_t</span>
function to properly format the major and minor number for
the<a name="chp-14-ITERM-6909"></a>
<a name="chp-14-ITERM-6910"></a>
<a name="chp-14-ITERM-6911"></a>
<a name="chp-14-ITERM-6912"></a>
<a name="chp-14-ITERM-6913"></a>
specific device.</p>




<ul></UL></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
