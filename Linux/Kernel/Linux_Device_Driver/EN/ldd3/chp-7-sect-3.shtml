<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>7.3. Delaying Execution</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-7-sect-3"></a>
<h3 class="docSection1Title">7.3. Delaying Execution</h3>

<p class="docText">Device drivers often <a name="chp-7-ITERM-5522"></a>
<a name="chp-7-ITERM-5523"></a>
<a name="chp-7-ITERM-5524"></a> <a name="chp-7-ITERM-5525"></a>need to delay the execution
of a particular piece of code for a period of time, usually to allow
the hardware to accomplish some task. In this section we cover a
number of different techniques for achieving delays. The
circumstances of each situation determine which technique is best to
use; we go over them all, and point out the advantages and
disadvantages of each.</p>

<p class="docText">One important thing to consider is how the delay you need compares
with the clock tick, considering the range of <tt>HZ</tt>
across the various platforms. Delays that are reliably longer than
the clock tick, and don't suffer from its coarse
granularity, can make use of the system clock. Very short delays
typically must be implemented with software loops. In between these
two cases lies a gray area. In this chapter, we use the phrase
"long" delay to refer to a
multiple-jiffy delay, which can be as low as a few milliseconds on
some platforms, but is still long as seen by the CPU and the kernel.</P>

<p class="docText">The following sections talk about the different delays by taking a
somewhat long path from various intuitive but inappropriate solutions
to the right solution. We chose this path because it allows a more
in-depth discussion of kernel issues related to timing. If you are
eager to find the right code, just skim through the section.</p>

<a name="chp-7-sect-3.1"></a>
<H4 class="docSection2Title">7.3.1. Long Delays</H4>

<p class="docText">Occasionally a driver needs to<a name="chp-7-ITERM-5526"></a> delay execution for relatively
long periodsâ€”more than one clock tick. There are a few ways of
accomplishing this sort of delay; we start with the simplest
technique, then proceed to the more advanced techniques.</P>

<a name="chp-7-sect-3.1.1"></a>
<h5 class="docSection3Title">7.3.1.1 Busy waiting</h5>

<p class="docText">If you want to delay execution by a multiple of the clock tick,
allowing some slack in the value, the easiest (though not
recommended) implementation is a loop that monitors the jiffy
counter. The
<span class="docEmphasis">busy-waiting</span><a name="chp-7-ITERM-5527"></a>
<a name="chp-7-ITERM-5528"></a>
implementation usually looks like the following code, where
<tt>j1</tt> is the value of <tt>jiffies</tt> at
the expiration of the delay:</p>

<pre>while (time_before(jiffies, j1))
    cpu_relax(  );</pre><br>


<p class="docText">The call to <span class="docEmphasis">cpu_relax</span> invokes an
architecture-specific way of saying that you're not
doing much with the processor at the moment. On many systems it does
nothing at all; on symmetric multithreaded
("hyperthreaded") systems, it may
yield the core to the other thread. In any case, this approach should
definitely be avoided whenever possible. We show it here because on
occasion you might want to run this code to better understand the
internals of other code.</P>

<p class="docText"><a name="chp-7-ITERM-5529"></a><a name="chp-7-ITERM-5530"></a><a name="chp-7-ITERM-5531"></a>So
let's look at how this code works. The loop is
guaranteed to work because <tt>jiffies</tt> is declared as
<tt>volatile</tt> by the kernel headers and, therefore, is
fetched from memory any time some C code accesses it. Although
technically correct (in that it works as designed), this busy loop
severely degrades system performance. If you didn't
configure your kernel for preemptive operation, the loop completely
locks the processor for the duration of the delay; the scheduler
never preempts a process that is running in kernel space, and the
computer looks completely dead until time <tt>j1</tt> is
reached. The problem is less serious if you are running a preemptive
kernel, because, unless the code is holding a lock, some of the
processor's time can be recovered for other uses.
Busy waits are still expensive on preemptive systems, however.</P>

<p class="docText">Still worse, if interrupts happen to be disabled when you enter the
loop, <tt>jiffies</tt> won't be updated,
and the <tt>while</tt> condition remains true forever.
Running a preemptive kernel won't help either, and
you'll be forced to hit the big red button.</P>

<p class="docText"><a name="chp-7-ITERM-5532"></a>
<a name="chp-7-ITERM-5533"></a>This
implementation of delaying code is available, like the following
ones, in the <span class="docEmphasis">jit</span> module. The
<i>/proc/jit*</I> files created by the module delay a
whole second each time you read a line of text, and lines are
guaranteed to be 20 bytes each. If you want to test the busy-wait
code, you can read <I>/proc/jitbusy</i>, which
busy-loops for one second for each line it returns.</p>
<p><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><TD><table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr><td width="60" valign="top"><img src="images/warning_yellow.gif" width="51" height="36" alt=""></TD><td valign="top">


<p class="docText">Be sure to read, at most, one line (or a few lines) at a time from
<i>/proc/jitbusy</I>. The simplified kernel mechanism
to register <i>/proc</I> files invokes the
<span class="docEmphasis">read</span> method over and over to fill the data
buffer the user requested. Therefore, a command such as <i>cat
/proc/jitbusy</i>, if it reads 4 KB at a time, freezes the
computer for 205 seconds.</p>
</td></tr></table></td></tr></table></p><br>

<p class="docText"><a name="chp-7-ITERM-5534"></a>The suggested command to read
<i>/proc/jitbusy</i> is <i>dd bs=20 &lt;
/proc/jitbusy</i>, optionally specifying the number of blocks
as well. Each 20-byte line returned by the file represents the value
the jiffy counter had before and after the delay. This is a sample
run on an otherwise unloaded computer:</P>

<pre>phon% <b>dd bs=20 count=5 &lt; /proc/jitbusy</b>
  1686518   1687518
  1687519   1688519
  1688520   1689520
  1689520   1690520
  1690521   1691521</pre><BR>


<p class="docText">All looks good: delays are exactly one second (1000 jiffies), and the
next <span class="docEmphasis">read</span> system call starts immediately after
the previous one is over. But let's see what happens
on a system with a large number of CPU-intensive processes running
(and nonpreemptive kernel):</P>

<pre>phon% <b>dd bs=20 count=5 &lt; /proc/jitbusy</b>
  1911226   1912226
  1913323   1914323
  1919529   1920529
  1925632   1926632
  1931835   1932835</pre><br>


<p class="docText">Here, each <span class="docEmphasis">read</span> system call delays exactly one
second, but the kernel can take more than 5 seconds before scheduling
the <span class="docEmphasis">dd</span> process so it can issue the next system
call. That's expected in a multitasking system; CPU
time is shared between all running processes, and a CPU-intensive
process has its dynamic priority reduced. (A discussion of scheduling
policies is outside the scope of this book.)</p>

<p class="docText">The test under load shown above has been performed while running the
<span class="docEmphasis">load50</span> sample program. This program forks a
number of processes that do nothing, but do it in a CPU-intensive
way. The program is part of the sample files accompanying this book,
and forks 50 processes by default, although the number can be
specified on the command line. In this chapter, and elsewhere in the
book, the tests with a loaded system have been performed with
<span class="docEmphasis">load50</span> running in an otherwise idle computer.</P>

<p class="docText">If you repeat the command while running a preemptible kernel,
you'll find no noticeable difference on an otherwise
idle CPU and the following behavior under load:</p>

<pre>phon% <B>dd bs=20 count=5 &lt; /proc/jitbusy</b>
 14940680  14942777
 14942778  14945430
 14945431  14948491
 14948492  14951960
 14951961  14955840</pre><BR>


<p class="docText">Here, there is no significant delay between the end of a system call
and the beginning of the next one, but the individual delays are far
longer than one second: up to 3.8 seconds in the example shown and
increasing over time. These values demonstrate that the process has
been interrupted during its delay, scheduling other processes. The
gap between system calls is not the only scheduling option for this
process, so no special delay can be seen there.</P>



<a name="chp-7-sect-3.1.2"></a>
<h5 class="docSection3Title">7.3.1.2 Yielding the processor</h5>

<p class="docText">As we have seen, busy waiting imposes a heavy load on the system as a
whole; we would like to find a better technique. The first change
that comes to mind is to explicitly release the CPU when
we're not interested in it. This is accomplished by
calling the <span class="docEmphasis">schedule</span> function, declared in
<i>&lt;linux/sched.h&gt;</i>:</P>

<pre>while (time_before(jiffies, j1)) {
    schedule(  );
}</pre><BR>


<p class="docText"><a name="chp-7-ITERM-5535"></a>
<a name="chp-7-ITERM-5536"></a>This loop can be tested by
reading <I>/proc/jitsched</i> as we read
<I>/proc/jitbusy</I> above. However, is still
isn't optimal. The current process does nothing but
release the CPU, but it remains in the run queue. If it is the only
runnable process, it actually runs (it calls the scheduler, which
selects the same process, which calls the scheduler, which . . . ).
In other words, the load of the machine (the average number of
running processes) is at least one, and the idle task (process number
<tt>0</tt>, also called
<span class="docEmphasis">swapper</span><a name="chp-7-ITERM-5537"></a>
for historical reasons) never runs. Though this issue may seem
irrelevant, running the idle task when the computer is idle relieves
the processor's workload, decreasing its temperature
and increasing its lifetime, as well as the duration of the batteries
if the computer happens to be your laptop. Moreover, since the
process is actually executing during the delay, it is accountable for
all the time it consumes.</p>

<p class="docText">The behavior of <i>/proc/jitsched</i> is actually
similar to running <i>/proc/jitbusy</I> under a
preemptive kernel. This is a sample run, on an unloaded system:</p>

<pre>phon% <b>dd bs=20 count=5 &lt; /proc/jitsched</b>
  1760205   1761207
  1761209   1762211
  1762212   1763212
  1763213   1764213
  1764214   1765217</pre><BR>


<p class="docText">It's interesting to note that each
<span class="docEmphasis">read</span> sometimes ends up waiting a few clock ticks
more than requested. This problem gets worse and worse as the system
gets busy, and the driver could end up waiting longer than expected.
Once a process releases the processor with
<span class="docEmphasis">schedule</span>, there are no guarantees that the
process will get the processor back anytime soon. Therefore, calling
<span class="docEmphasis">schedule</span> in this manner is not a safe solution
to the driver's needs, in addition to being bad for
the computing system as a whole. If you test
<i>jitsched</i> while running
<span class="docEmphasis">load50</span>, you can see that the delay associated to
each line is extended by a few seconds, because other processes are
using the CPU when the timeout expires.</P>



<a name="chp-7-sect-3.1.3"></a>
<h5 class="docSection3Title">7.3.1.3 Timeouts</H5>

<p class="docText"><a name="chp-7-ITERM-5538"></a>
<a name="chp-7-ITERM-5539"></a>The
suboptimal delay loops shown up to now work by watching the jiffy
counter without telling anyone. But the best way to implement a
delay, as you may imagine, is usually to ask the kernel to do it for
you. There are two ways of setting up jiffy-based timeouts, depending
on whether your driver is waiting for other events or not.</p>

<p class="docText"><a name="chp-7-ITERM-5540"></a>
<a name="chp-7-ITERM-5541"></a><a name="chp-7-ITERM-5542"></a>If your driver uses a wait queue to
wait for some other event, but you also want to be sure that it runs
within a certain period of time, it can use
<span class="docEmphasis">wait_event_timeout</span> or
<span class="docEmphasis">wait_event_interruptible_timeout</span>:</p>

<pre>#include &lt;linux/wait.h&gt;
long wait_event_timeout(wait_queue_head_t q, condition, long timeout);
long wait_event_interruptible_timeout(wait_queue_head_t q,
                      condition, long timeout);</pre><br>


<p class="docText">These functions sleep on the given wait queue, but they return after
the timeout (expressed in jiffies) expires. Thus, they implement a
bounded sleep that does not go on forever. Note that the timeout
value represents the number of jiffies to wait, not an absolute time
value. The value is represented by a signed number, because it
sometimes is the result of a subtraction, although the functions
complain through a <span class="docEmphasis">printk</span> statement if the
provided timeout is negative. If the timeout expires, the functions
return <tt>0</tt>; if the process is awakened by another
event, it returns the remaining delay expressed in jiffies. The
return value is never negative, even if the delay is greater than
expected because of system load.</p>

<p class="docText">The <i>/proc/jitqueue</i> file shows a delay based on
<span class="docEmphasis">wait_event_interruptible_timeout</span>, although the
module has no event to wait for, and uses <tt>0</tt> as a
condition:</p>

<pre>wait_queue_head_t wait;
init_waitqueue_head (&amp;wait);
wait_event_interruptible_timeout(wait, 0, delay);</pre><br>


<p class="docText">The observed behaviour, when reading
<i>/proc/jitqueue</i>, is nearly optimal, even under
load:</p>

<pre>phon% <b>dd bs=20 count=5 &lt; /proc/jitqueue</b>
  2027024   2028024
  2028025   2029025
  2029026   2030026
  2030027   2031027
  2031028   2032028</pre><br>


<p class="docText">Since the reading process (<span class="docEmphasis">dd</span> above) is not in
the run queue while waiting for the timeout, you see no difference in
behavior whether the code is run in a preemptive kernel or not.</P>

<p class="docText"><a name="chp-7-ITERM-5543"></a>
<a name="chp-7-ITERM-5544"></a><a name="chp-7-ITERM-5545"></a><span class="docEmphasis">wait_event_timeout</span>
and <span class="docEmphasis">wait_event_interruptible_timeout</span> were
designed with a hardware driver in mind, where execution could be
resumed in either of two ways: either somebody calls
<span class="docEmphasis">wake_up</span> on the wait queue, or the timeout
expires. This doesn't apply to
<i>jitqueue</I>, as nobody ever calls
<span class="docEmphasis">wake_up</span> on the wait queue (after all, no other
code even knows about it), so the process always wakes up when the
timeout expires. To accommodate for this very situation, where you
want to delay execution waiting for no specific event, the kernel
offers the <span class="docEmphasis">schedule_timeout</span> function so you can
avoid declaring and using a superfluous wait queue head:</P>

<pre>#include &lt;linux/sched.h&gt;
signed long schedule_timeout(signed long timeout);</pre><br>


<p class="docText">Here, <tt>timeout</tt> is the number of jiffies to delay.
The return value is <tt>0</tt> unless the function returns
before the given timeout has elapsed (in response to a signal).
<span class="docEmphasis">schedule_timeout</span> requires that the caller first
set the current process state, so a typical call looks like:</p>

<pre>set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout (delay);</pre><br>


<p class="docText">The previous lines (from <I>/proc/jitschedto</i> )
cause the process to sleep until the given time has passed. Since
<span class="docEmphasis">wait_event_interruptible_timeout</span> relies on
<span class="docEmphasis">schedule_timeout</span> internally, we
won't bother showing the numbers
<span class="docEmphasis">jitschedto</span> returns, because they are the same as
those of <span class="docEmphasis">jitqueue</span>. Once again, it is worth
noting that an extra time interval could pass between the expiration
of the timeout and when your process is actually scheduled to
execute.</P>

<p class="docText">In the example just shown, the first line calls
<span class="docEmphasis">set_current_state</span> to set things up so that the
scheduler won't run the current process again until
the timeout places it back in <tt>TASK_RUNNING</tt> state.
To achieve an uninterruptible delay, use
<tt>TASK_UNINTERRUPTIBLE</tt> instead. If you forget to
change the state of the current process, a call to
<span class="docEmphasis">schedule_timeout</span> behaves like a call to
<span class="docEmphasis">schedule</span> (i.e., the
<I>jitsched</I> behavior), setting up a timer that is
not used.</p>

<p class="docText">If you want to play with the four <span class="docEmphasis">jit</span> files
under different system situations or different kernels, or try other
ways to delay execution, you may want to configure the amount of the
delay when loading the module by setting the
<span class="docEmphasis">delay</span> module parameter.</p>



<a name="chp-7-sect-3.2"></a>
<h4 class="docSection2Title">7.3.2. Short Delays</h4>

<p class="docText"><a name="chp-7-ITERM-5546"></a>When a device driver needs to deal with
latencies<a name="chp-7-ITERM-5547"></a> in its hardware, the delays involved are
usually a few dozen microseconds at most. In this case, relying on
the clock tick is definitely not the way to go.</P>

<p class="docText">The kernel functions <span class="docEmphasis">ndelay</span>,
<span class="docEmphasis">udelay</span>, and <span class="docEmphasis">mdelay</span> serve
well for short delays, delaying execution for the specified number of
nanoseconds, microseconds, or milliseconds respectively.<sup class="docFootnote"><a class="docLink" href="chp-7-sect-3.shtml#chp-7-FNOTE-2">[2]</a></sup> Their prototypes are:</P><blockquote><p class="docFootnote"><sup><a name="chp-7-FNOTE-2">[2]</a></sup> The <tt>u</tt> in <span class="docEmphasis">udelay</span>
represents the Greek letter mu and stands for
<span class="docEmphasis">micro</span>.</P></blockquote>

<pre>#include &lt;linux/delay.h&gt;
void ndelay(unsigned long nsecs);
void udelay(unsigned long usecs);
void mdelay(unsigned long msecs);</pre><br>


<p class="docText"><a name="chp-7-ITERM-5548"></a>
<a name="chp-7-ITERM-5549"></a><a name="chp-7-ITERM-5550"></a><a name="chp-7-ITERM-5551"></a>The
actual implementations of the functions are in
<I>&lt;asm/delay.h&gt;</I>, being
architecture-specific, and sometimes build on an external function.
Every architecture implements <span class="docEmphasis">udelay</span>, but the
other functions may or may not be defined; if they are not,
<i>&lt;linux/delay.h&gt;</i> offers a default version
based on <span class="docEmphasis">udelay</span>. In all cases, the delay
achieved is at least the requested value but could be more; actually,
no platform currently achieves nanosecond precision, although several
ones offer submicrosecond precision. Delaying more than the requested
value is usually not a problem, as short delays in a driver are
usually needed to wait for the hardware, and the requirements are to
wait for <span class="docEmphasis">at least</span> a given time lapse.</p>

<p class="docText"><a name="chp-7-ITERM-5552"></a>
<a name="chp-7-ITERM-5553"></a>The
implementation of
<span class="docEmphasis">udelay</span><a name="chp-7-ITERM-5554"></a>
(and possibly <span class="docEmphasis">ndelay</span> too) uses a software loop
based on the processor speed calculated at boot time, using the
integer variable <tt>loops_per_jiffy</tt>. If you want to
look at the actual code, however, be aware that the
<span class="docEmphasis">x86</span> implementation is quite a complex one
because of the different timing sources it uses, based on what CPU
type is running the code.</p>

<p class="docText">To avoid integer overflows in loop calculations,
<span class="docEmphasis">udelay</span> and <span class="docEmphasis">ndelay</span> impose an
upper bound in the value passed to them. If your module fails to load
and displays an unresolved symbol, <span class="docEmphasis">_
_bad_udelay</span>, it means you called
<span class="docEmphasis">udelay</span> with too large an argument. Note,
however, that the compile-time check can be performed only on
constant values and that not all platforms implement it. As a general
rule, if you are trying to delay for thousands of nanoseconds, you
should be using <span class="docEmphasis">udelay</span> rather than
<span class="docEmphasis">ndelay</span>; similarly, millisecond-scale delays
should be done with
<span class="docEmphasis">mdelay</span><a name="chp-7-ITERM-5555"></a>
and not one of the finer-grained functions.</P>

<p class="docText">It's important to remember that the three delay
functions are busy-waiting; other tasks can't be run
during the time lapse. Thus, they replicate, though on a different
scale, the behavior of <span class="docEmphasis">jitbusy</span>. Thus, these
functions should only be used when there is no practical alternative.</p>

<p class="docText">There is another way of achieving millisecond (and longer) delays
that does not involve busy waiting. The file
<i>&lt;linux/delay.h&gt;</I> declares these functions:</p>

<pre>void msleep(unsigned int millisecs);
unsigned long msleep_interruptible(unsigned int millisecs);
void ssleep(unsigned int seconds)</pre><br>


<p class="docText">The first two functions puts the calling process to sleep for the
given number of <tt>millisecs</tt>. A call to
<span class="docEmphasis">msleep</span> is uninterruptible; you can be sure that
the process sleeps for at least the given number of milliseconds. If
your driver is sitting on a wait queue and you want a wakeup to break
the<a name="chp-7-ITERM-5556"></a> <a name="chp-7-ITERM-5557"></a> sleep, use
<span class="docEmphasis">msleep_interruptible</span>. The return value from
<span class="docEmphasis">msleep_interruptible</span> is normally
<tt>0</tt>; if, however, the process is awakened early, the
return value is the number of milliseconds remaining in the
originally requested sleep period. A call to
<span class="docEmphasis">ssleep</span> puts the process into an uninterruptible
sleep for the given number of seconds.</P>

<p class="docText">In general, if you <a name="chp-7-ITERM-5558"></a> <a name="chp-7-ITERM-5559"></a> <a name="chp-7-ITERM-5560"></a> <a name="chp-7-ITERM-5561"></a>can tolerate longer delays than
requested, you should use <span class="docEmphasis">schedule_timeout</span>,
<span class="docEmphasis">msleep</span>, or
<span class="docEmphasis">ssleep</span>.<a name="chp-7-ITERM-5562"></a></p>



<UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
