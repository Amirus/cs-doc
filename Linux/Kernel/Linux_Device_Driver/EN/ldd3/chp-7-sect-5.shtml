<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>7.5. Tasklets</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7-sect-6.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-7-sect-5"></a>
<h3 class="docSection1Title" >7.5. Tasklets</h3>

<p class="docText">Another kernel facility related to<a name="chp-7-ITERM-5595"></a>
<a name="chp-7-ITERM-5596"></a>
<a name="chp-7-ITERM-5597"></a>
<a name="chp-7-ITERM-5598"></a> <a name="chp-7-ITERM-5599"></a>
<a name="chp-7-ITERM-5600"></a>
timing issues is the <span class="docEmphasis">tasklet</span> mechanism. It is
mostly used in interrupt management (we'll see it
again in <a class="docLink" href="chp-10.shtml#chp-10">Chapter 10</a>.)</p>

<p class="docText">Tasklets resemble kernel timers in some ways. They are always run at
interrupt time, they always run on the same CPU that schedules them,
and they receive an <tt>unsigned</tt>
<tt>long</tt> argument. Unlike kernel timers, however, you
can't ask to execute the function at a specific
time. By scheduling a tasklet, you simply ask for it to be executed
at a later time chosen by the kernel. This behavior is especially
useful with interrupt handlers, where the hardware interrupt must be
managed as quickly as possible, but most of the data management can
be safely delayed to a later time. Actually, a tasklet, just like a
kernel timer, is executed (in atomic mode) in the context of a
"soft interrupt," a kernel
mechanism that executes asynchronous tasks with hardware interrupts
enabled.</P>

<p class="docText">A tasklet exists as a data structure that must be initialized before
use. Initialization can be performed by calling a specific function
or by declaring the structure using certain macros:</p>

<pre>#include &lt;linux/interrupt.h&gt;

struct tasklet_struct {
      /* ... */
      void (*func)(unsigned long);
      unsigned long data;
};

void tasklet_init(struct tasklet_struct *t,
      void (*func)(unsigned long), unsigned long data);
DECLARE_TASKLET(name, func, data);
DECLARE_TASKLET_DISABLED(name, func, data);</pre><BR>


<p class="docText">Tasklets offer a number of interesting features:</P>

<UL><li><p class="docList">A tasklet can be disabled and re-enabled later; it
won't be executed until it is enabled as many times
as it has been disabled.</p></li><li><p class="docList">Just like timers, a tasklet can reregister itself.</P></LI><LI><p class="docList">A tasklet can be scheduled to execute at normal priority or high
priority. The latter group is always executed first.</p></LI><LI><p class="docList">Tasklets may be run immediately if the system is not under heavy load
but never later than the next timer tick.</p></li><li><p class="docList">A tasklets can be concurrent with other tasklets but is strictly
serialized with respect to itselfâ€”the same tasklet never runs
simultaneously on more than one processor. Also, as already noted, a
tasklet always runs on the same CPU that schedules it.</p></LI></ul>
<p class="docText">The <span class="docEmphasis">jit</span> module includes two files,
<i>/proc/jitasklet</I> and
<i>/proc/jitasklethi</i>, that return the same data as
<I>/proc/jitimer</i>, introduced in <a class="docLink" href="chp-7-sect-4.shtml#chp-7-sect-4">Section 7.4</a> When you read one of the files, you get
back a header and six data lines. The first data line describes the
context of the calling process, and the other lines describe the
context of successive runs of a tasklet procedure. This is a sample
run while compiling a kernel:</P>

<pre>phon% <b>cat /proc/jitasklet</b>
   time   delta  inirq    pid   cpu command
  6076139    0     0      4370   0   cat
  6076140    1     1      4368   0   cc1
  6076141    1     1      4368   0   cc1
  6076141    0     1         2   0   ksoftirqd/0
  6076141    0     1         2   0   ksoftirqd/0
  6076141    0     1         2   0   ksoftirqd/0</pre><br>


<p class="docText">As confirmed by the above data, the tasklet is run at the next timer
tick as long as the CPU is busy running a process, but it is run
immediately when the CPU is otherwise idle. The kernel provides a set
of <span class="docEmphasis">ksoftirqd</span> kernel threads, one per CPU, just
to run "soft interrupt" handlers,
such as the <span class="docEmphasis">tasklet_action</span> function. Thus, the
final three runs of the tasklet take place in the context of the
<span class="docEmphasis">ksoftirqd</span> kernel thread associated to CPU
<tt>0</tt>. The <i>jitasklethi</i>
implementation uses a high-priority tasklet, explained in an upcoming
list of functions.</p>

<p class="docText">The actual code in <span class="docEmphasis">jit</span> that implements
<i>/proc/jitasklet</i> and
<i>/proc/jitasklethi</i> is almost identical to the
code that implements <i>/proc/jitimer</i>, but it uses
the tasklet calls instead of the timer ones. The following list lays
out in detail the kernel interface to tasklets after the tasklet
structure has been initialized:</p>

<a name="chp-7-ITERM-5601"></a><a name="chp-7-ITERM-5602"></a><a name="chp-7-ITERM-5603"></a><a name="chp-7-ITERM-5604"></a><a name="chp-7-ITERM-5605"></a><a name="chp-7-ITERM-5606"></a><a name="chp-7-ITERM-5607"></a><a name="chp-7-ITERM-5608"></a><a name="chp-7-ITERM-5609"></a><a name="chp-7-ITERM-5610"></a><a name="chp-7-ITERM-5611"></a><a name="chp-7-ITERM-5612"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_disable(struct tasklet_struct *t);</span></span><a name="chp-7-ITERM-5601"></a>
<a name="chp-7-ITERM-5602"></a></span></dt></p>
<dd>
<p class="docList">This function disables the given tasklet. The tasklet may still be
scheduled with <span class="docEmphasis">tasklet_schedule</span>, but its
execution is deferred until the tasklet has been enabled again. If
the tasklet is currently running, this function busy-waits until the
tasklet exits; thus, after calling
<span class="docEmphasis">tasklet_disable</span>, you can be sure that the
tasklet is not running anywhere in the system.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_disable_nosync(struct tasklet_struct *t);</span></span><a name="chp-7-ITERM-5603"></a>
<a name="chp-7-ITERM-5604"></a></span></dt></p>
<dd>
<p class="docList">Disable the tasklet, but without waiting for any currently-running
function to exit. When it returns, the tasklet is disabled and
won't be scheduled in the future until re-enabled,
but it may be still running on another CPU when the function returns.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_enable(struct tasklet_struct *t);</span></span><a name="chp-7-ITERM-5605"></a>
<a name="chp-7-ITERM-5606"></a></span></dt></P>
<dd>
<p class="docList">Enables a tasklet that had been previously disabled. If the tasklet
has already been scheduled, it will run soon. A call to
<span class="docEmphasis">tasklet_enable</span> must match each call to
<span class="docEmphasis">tasklet_disable</span>, as the kernel keeps track of
the "disable count" for each
tasklet.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_schedule(struct tasklet_struct *t);</span></span><a name="chp-7-ITERM-5607"></a>
<a name="chp-7-ITERM-5608"></a></span></dt></p>
<dd>
<p class="docList">Schedule the tasklet for execution. If a tasklet is scheduled again
before it has a chance to run, it runs only once. However, if it is
scheduled <span class="docEmphasis">while</span> it runs, it runs again after it
completes; this ensures that events occurring while other events are
being processed receive due attention. This behavior also allows a
tasklet to reschedule itself.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_hi_schedule(struct tasklet_struct *t);</span></span><a name="chp-7-ITERM-5609"></a>
<a name="chp-7-ITERM-5610"></a></span></dt></P>
<dd>
<p class="docList">Schedule the tasklet for execution with higher priority. When the
soft interrupt handler runs, it deals with high-priority tasklets
before other soft interrupt tasks, including
"normal" tasklets. Ideally, only
tasks with low-latency requirements (such as filling the audio
buffer) should use this function, to avoid the additional latencies
introduced by other soft interrupt handlers. Actually,
<I>/proc/jitasklethi</i> shows no human-visible
difference from <I>/proc/jitasklet</I>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_kill(struct tasklet_struct *t);</span></span><a name="chp-7-ITERM-5611"></a>
<a name="chp-7-ITERM-5612"></a></span></dt></p>
<dd>
<p class="docList">This function ensures that the tasklet is not scheduled to run again;
it is usually called when a device is being closed or the module
removed. If the tasklet is scheduled to run, the function waits until
it has executed. If the tasklet reschedules itself, you must prevent
it from rescheduling itself before calling
<span class="docEmphasis">tasklet_kill</span>, as with
<span class="docEmphasis">del_timer_sync</span>.</P>
</dd>
</dl>

<p class="docText">Tasklets <a name="chp-7-ITERM-5613"></a> <a name="chp-7-ITERM-5614"></a> <a name="chp-7-ITERM-5615"></a> <a name="chp-7-ITERM-5616"></a> <a name="chp-7-ITERM-5617"></a> <a name="chp-7-ITERM-5618"></a>are implemented in
<i>kernel/softirq.c</i>. The two tasklet lists (normal
and high-priority) are declared as per-CPU data structures, using the
same CPU-affinity mechanism used by kernel timers. The data structure
used in tasklet management is a simple linked list, because tasklets
have none of the sorting requirements of kernel timers.</P>


<ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7-sect-6.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
