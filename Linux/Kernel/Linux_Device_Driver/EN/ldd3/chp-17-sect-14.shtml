<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>17.14. Multicast</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-13.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17-sect-15.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-17-sect-14"></a>
<h3 class="docSection1Title">17.14. Multicast</H3>

<p class="docText">A <span class="docEmphasis">multicast</span> packet is a <a name="chp-17-ITERM-7853"></a> <a name="chp-17-ITERM-7854"></a>
<a name="chp-17-ITERM-7855"></a>network
packet meant to be received by more than one host, but not by all
hosts. This functionality is obtained by assigning special hardware
addresses to groups of hosts. Packets directed to one of the special
addresses should be received by all the hosts in that group. In the
case of Ethernet, a multicast address has the least significant bit
of the first address octet set in the destination address, while
every device board has that bit clear in its own hardware address.</p>

<p class="docText">The tricky part of dealing with host groups and hardware addresses is
performed by applications and the kernel, and the interface driver
doesn't need to deal with these problems.</p>

<p class="docText">Transmission of multicast packets is a simple problem because they
look exactly like any other packets. The interface transmits them
over the communication medium without looking at the destination
address. It's the kernel that has to assign a
correct hardware destination address; the
<span class="docEmphasis">hard_header</span> device method, if defined,
doesn't need to look in the data it arranges.</P>

<p class="docText">The kernel handles the job of tracking which multicast addresses are
of interest at any given time. The list can change frequently, since
it is a function of the applications that are running at any given
time and the users' interest. It is the
driver's job to accept the list of interesting
multicast addresses and deliver to the kernel any packets sent to
those addresses. How the driver implements the multicast list is
somewhat dependent on how the underlying hardware works. Typically,
hardware belongs to one of three classes, as far as multicast is
concerned:</p>

<UL><li><p class="docList">Interfaces that cannot deal with multicast. These interfaces either
receive packets directed specifically to their hardware address (plus
broadcast packets) or receive every packet. They can receive
multicast packets only by receiving every packet, thus, potentially
overwhelming the operating system with a huge number of
"uninteresting" packets. You
don't usually count these interfaces as multicast
capable, and the driver won't set
<tt>IFF_MULTICAST</tt> in <tt>dev-&gt;flags</tt>.</p></li><li><p class="docList">Point-to-point interfaces are a special case because they always
receive every packet without performing any hardware filtering.</p></li><li><p class="docList">Interfaces that can tell multicast packets from other packets
(host-to-host or broadcast). These interfaces can be instructed to
receive every multicast packet and let the software determine if the
address is interesting for this host. The overhead introduced in this
case is acceptable, because the number of multicast packets on a
typical network is low.</p></li><li><p class="docList">Interfaces that can perform hardware detection of multicast
addresses. These interfaces can be passed a list of multicast
addresses for which packets are to be received, and ignore other
multicast packets. This is the optimal case for the kernel, because
it doesn't waste processor time dropping
"uninteresting" packets received by
the interface.</p></li></ul>
<p class="docText">The kernel tries to exploit the capabilities of high-level interfaces
by supporting the third device class, which is the most versatile, at
its best. Therefore, the kernel notifies the driver whenever the list
of valid multicast addresses is changed, and it passes the new list
to the driver so it can update the hardware filter according to the
new information.</P>

<a name="chp-17-sect-14.1"></a>
<h4 class="docSection2Title">17.14.1. Kernel Support for Multicasting</H4>

<p class="docText"><a name="chp-17-ITERM-7856"></a>
<a name="chp-17-ITERM-7857"></a>Support
for multicast
<a name="chp-17-ITERM-7858"></a>packets
is made up of several items: a device method, a data structure, and
device flags:</P>

<a name="chp-17-ITERM-7859"></a><a name="chp-17-ITERM-7860"></a><a name="chp-17-ITERM-7861"></a><a name="chp-17-ITERM-7862"></a><a name="chp-17-ITERM-7863"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void (*dev-&gt;set_multicast_list)(struct net_device *dev);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-17-ITERM-7859"></a>Device
method called whenever the list of machine addresses associated with
the device changes. It is also called when
<tt>dev-&gt;flags</tt> is modified, because some flags
(e.g., <tt>IFF_PROMISC</tt>) may also require you to
reprogram the hardware filter. The method receives a pointer to
<tt>struct net_device</tt> as an argument and returns
<tt>void</tt>. A driver not interested in implementing this
method can leave the field set to <tt>NULL</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct dev_mc_list *dev-&gt;mc_list;</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-17-ITERM-7860"></a>
<a name="chp-17-ITERM-7861"></a>A
linked list of all the multicast addresses associated with the
device. The actual definition of the structure is introduced at the
end of this section.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int dev-&gt;mc_count;</span></span></span></dt></p>
<dd>
<p class="docList">The number of items in the linked list. This information is somewhat
redundant, but checking <tt>mc_count</tt> against
<tt>0</tt> is a useful shortcut for checking the list.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">IFF_MULTICAST</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-17-ITERM-7862"></a>
<a name="chp-17-ITERM-7863"></a>Unless
the driver sets this flag in <tt>dev-&gt;flags</tt>, the
interface won't be asked to handle multicast
packets. Nonetheless, the kernel calls the driver's
<span class="docEmphasis">set_multicast_list</span> method when
<tt>dev-&gt;flags</tt> changes, because the multicast list
may have changed while the interface was not active.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">IFF_ALLMULTI</span></span></span></dt></p>
<dd>
<p class="docList">Flag set in <tt>dev-&gt;flags</tt> by the networking
software to tell the driver to retrieve all multicast packets from
the network. This happens when multicast routing is enabled. If the
flag is set, <tt>dev-&gt;mc_list</tt>
shouldn't be used to filter multicast packets.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">IFF_PROMISC</span></span></span></dt></P>
<dd>
<p class="docList">Flag set in <tt>dev-&gt;flags</tt> when the interface is
put into promiscuous mode. Every packet should be received by the
interface, independent of <tt>dev-&gt;mc_list</tt>.</p>
</dd>
</dl>

<p class="docText">The last bit of information needed by the driver developer is the
definition of <tt>struct</tt>
<tt>dev_mc_list</tt>, which lives in
<i>&lt;linux/netdevice.h&gt;</I>:</p>

<pre>struct dev_mc_list {    
    struct dev_mc_list   *next;          /* Next address in list */
    _ _u8                 dmi_addr[MAX_ADDR_LEN]; /* Hardware address */
    unsigned char        dmi_addrlen;    /* Address length */
    int                  dmi_users;      /* Number of users */
    int                  dmi_gusers;     /* Number of groups */
};</pre><br>


<p class="docText">Because multicasting and hardware addresses are independent of the
actual transmission of packets, this structure is portable across
network implementations, and each address is identified by a string
of octets and a length, just like
<tt>dev-&gt;dev_addr</tt>.</P>


<a name="chp-17-sect-14.2"></a>
<h4 class="docSection2Title">17.14.2. A Typical Implementation</H4>

<p class="docText">The best way to describe the design of
<span class="docEmphasis">set_multicast_list</span><a name="chp-17-ITERM-7864"></a>
<a name="chp-17-ITERM-7865"></a>
<a name="chp-17-ITERM-7866"></a>
<a name="chp-17-ITERM-7867"></a>
is to show you some pseudocode.</p>

<p class="docText">The following function is a typical implementation of the function in
a full-featured (<tt>ff</tt>) driver. The driver is full
featured in that the interface it controls has a complex hardware
packet filter, which can hold a table of multicast addresses to be
received by this host. The maximum size of the table is
<tt>FF_TABLE_SIZE</tt>.</p>

<p class="docText">All the functions prefixed with <tt>ff_</tt> are
placeholders for hardware-specific operations:</p>

<pre>void ff_set_multicast_list(struct net_device *dev)
{
    struct dev_mc_list *mcptr;

    if (dev-&gt;flags &amp; IFF_PROMISC) {
        ff_get_all_packets(  );
        return;
    }
    /* If there's more addresses than we handle, get all multicast
    packets and sort them out in software. */
    if (dev-&gt;flags &amp; IFF_ALLMULTI || dev-&gt;mc_count &gt; FF_TABLE_SIZE) {
        ff_get_all_multicast_packets(  );
        return;
    }
    /* No multicast?  Just get our own stuff */
    if (dev-&gt;mc_count =  = 0) {
        ff_get_only_own_packets(  );
        return;
    }
    /* Store all of the multicast addresses in the hardware filter */
    ff_clear_mc_list(  );
    for (mc_ptr = dev-&gt;mc_list; mc_ptr; mc_ptr = mc_ptr-&gt;next)
        ff_store_mc_address(mc_ptr-&gt;dmi_addr);
    ff_get_packets_in_multicast_list(  );
}</pre><br>


<p class="docText">This implementation can be simplified if the interface cannot store a
multicast table in the hardware filter for incoming packets. In that
case, <tt>FF_TABLE_SIZE</tt> reduces to
<tt>0</tt>, and the last four lines of code are not needed.</p>

<p class="docText">As was mentioned earlier, even interfaces that can't
deal with multicast packets need to implement the
<span class="docEmphasis">set_multicast_list</span> method to be notified about
changes in <tt>dev-&gt;flags</tt>. This approach could be
called a "nonfeatured"
(<tt>nf</tt>) implementation. The implementation is very
simple, as shown by the following code:</p>

<pre>void nf_set_multicast_list(struct net_device *dev)
{
    if (dev-&gt;flags &amp; IFF_PROMISC)
        nf_get_all_packets(  );
    else
        nf_get_only_own_packets(  );
}</pre><br>


<p class="docText">Implementing <tt>IFF_PROMISC</tt> is important, because
otherwise the user won't be able to run
<span class="docEmphasis">tcpdump</span> or any other network analyzers. If the
interface runs a point-to-point link, on the other hand,
there's no need to implement
<span class="docEmphasis">set_multicast_list</span> at all, because users receive
every<a name="chp-17-ITERM-7868"></a>
<a name="chp-17-ITERM-7869"></a>
<a name="chp-17-ITERM-7870"></a> packet
anyway.</p>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-13.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17-sect-15.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
