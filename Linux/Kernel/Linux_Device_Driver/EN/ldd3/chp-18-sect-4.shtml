<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>18.4. ioctls</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-18-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-18-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-18-sect-4"></a>
<H3 class="docSection1Title" >18.4. ioctls</H3>

<p class="docText">The <span class="docEmphasis">ioctl</span><a name="chp-18-ITERM-7976"></a>
<a name="chp-18-ITERM-7977"></a> function callback in the
<tt>struct tty_driver</tt> is called by the tty core when
<span class="docEmphasis">ioctl</span>(2) is called on the device node. If the
tty driver does not know how to handle the <span class="docEmphasis">ioctl</span>
value passed to it, it should return <tt>-ENOIOCTLCMD</tt>
to try to let the tty core implement a generic version of the call.</p>

<p class="docText">The 2.6 kernel defines about 70 different tty
<span class="docEmphasis">ioctls</span> that can be be sent to a tty driver. Most
tty drivers do not handle all of these, but only a small subset of
the more common ones. Here is a list of the more popular tty
<span class="docEmphasis">ioctls</span>, what they mean, and how to implement
them:</p>

<a name="chp-18-ITERM-7978"></a><a name="chp-18-ITERM-7979"></a><a name="chp-18-ITERM-7980"></a><dl class="docList"><dt><span class="docPubcolor"> <span class="docPubcolor"><span class="docMonofont">TIOCSERGETLSR</span></span> </span></dt></P>
<dd>
<p class="docList">Gets the value of this tty device's
<a name="chp-18-ITERM-7978"></a>
<a name="chp-18-ITERM-7979"></a>
<a name="chp-18-ITERM-7980"></a>line
status register (LSR).</p>
</dd>
<dt><span class="docPubcolor"> <span class="docPubcolor"><span class="docMonofont">TIOCGSERIAL</span></span> </span></dt></p>
<dd>
<p class="docList">Gets the serial line information. A caller can potentially get a lot
of serial line information from the tty device all at once in this
call. Some programs (such as <i>setserial</I> and
<i>dip</I>) call this function to make sure that the baud
rate was properly set and to get general information on what type of
device the tty driver controls. The caller passes in a pointer to a
large struct of type <tt>serial_struct</tt>, which the tty
driver should fill up with the proper values. Here is an example of
how this can be implemented:</p>
</dd>
</dl>

<pre>static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
    struct tiny_serial *tiny = tty-&gt;driver_data;
    if (cmd =  = TIOCGSERIAL) {
        struct serial_struct tmp;
        if (!arg)
            return -EFAULT;
        memset(&amp;tmp, 0, sizeof(tmp));
        tmp.type        = tiny-&gt;serial.type;
        tmp.line        = tiny-&gt;serial.line;
        tmp.port        = tiny-&gt;serial.port;
        tmp.irq         = tiny-&gt;serial.irq;
        tmp.flags       = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
        tmp.xmit_fifo_size  = tiny-&gt;serial.xmit_fifo_size;
        tmp.baud_base       = tiny-&gt;serial.baud_base;
        tmp.close_delay     = 5*HZ;
        tmp.closing_wait    = 30*HZ;
        tmp.custom_divisor  = tiny-&gt;serial.custom_divisor;
        tmp.hub6        = tiny-&gt;serial.hub6;
        tmp.io_type     = tiny-&gt;serial.io_type;
        if (copy_to_user((void _ _user *)arg, &amp;tmp, sizeof(tmp)))
            return -EFAULT;
        return 0;
    }
    return -ENOIOCTLCMD;
}</pre><br>


<a name="chp-18-ITERM-7981"></a><a name="chp-18-ITERM-7982"></a><a name="chp-18-ITERM-7983"></a><a name="chp-18-ITERM-7984"></a><dl class="docList"><dt><span class="docPubcolor"> <span class="docPubcolor"><span class="docMonofont">TIOCSSERIAL</span></span> </span></dt></p>
<dd>
<p class="docList">Sets the <a name="chp-18-ITERM-7981"></a>
<a name="chp-18-ITERM-7982"></a>serial line information. This is the
opposite of <tt>TIOCGSERIAL</tt> and allows the user to set
the serial line status of the tty device all at once. A pointer to a
<tt>struct</tt> <tt>serial_struct</tt> is passed
to this call, full of data that the tty device should now be set to.
If the tty driver does not implement this call, most programs still
works properly.</p>
</dd>
<dt><span class="docPubcolor"> <span class="docPubcolor"><span class="docMonofont">TIOCMIWAIT</span></span> </span></dt></p>
<dd>
<p class="docList">Waits for MSR change. The user asks for this
<span class="docEmphasis">ioctl</span> in the unusual circumstances that it wants
to sleep within the kernel until something happens to the
<a name="chp-18-ITERM-7983"></a>
<a name="chp-18-ITERM-7984"></a>MSR
register of the tty device. The <tt>arg</tt> parameter
contains the type of event that the user is waiting for. This is
commonly used to wait until a status line changes, signaling that
more data is ready to be sent to the device.</p>
</dd>
</dl>
<p class="docText">Be careful when implementing this <span class="docEmphasis">ioctl</span>, and do
not use the <span class="docEmphasis">interruptible_sleep_on</span> call, as it
is unsafe (there are lots of nasty race conditions involved with it).
Instead, a <span class="docEmphasis">wait_queue</span> should be used to avoid
these problems. Here's an example of how to
implement this ioctl:</p>

<pre>static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
    struct tiny_serial *tiny = tty-&gt;driver_data;
    if (cmd =  = TIOCMIWAIT) {
        DECLARE_WAITQUEUE(wait, current);
        struct async_icount cnow;
        struct async_icount cprev;
        cprev = tiny-&gt;icount;
        while (1) {
            add_wait_queue(&amp;tiny-&gt;wait, &amp;wait);
            set_current_state(TASK_INTERRUPTIBLE);
            schedule(  );
            remove_wait_queue(&amp;tiny-&gt;wait, &amp;wait);
            /* see if a signal woke us up */
            if (signal_pending(current))
                return -ERESTARTSYS;
            cnow = tiny-&gt;icount;
            if (cnow.rng =  = cprev.rng &amp;&amp; cnow.dsr =  = cprev.dsr &amp;&amp;
                cnow.dcd =  = cprev.dcd &amp;&amp; cnow.cts =  = cprev.cts)
                return -EIO; /* no change =&gt; error */
            if (((arg &amp; TIOCM_RNG) &amp;&amp; (cnow.rng != cprev.rng)) ||
                ((arg &amp; TIOCM_DSR) &amp;&amp; (cnow.dsr != cprev.dsr)) ||
                ((arg &amp; TIOCM_CD)  &amp;&amp; (cnow.dcd != cprev.dcd)) ||
                ((arg &amp; TIOCM_CTS) &amp;&amp; (cnow.cts != cprev.cts)) ) {
                return 0;
            }
            cprev = cnow;
        }
    }
    return -ENOIOCTLCMD;
}</pre><br>


<p class="docText">Somewhere in the tty driver's code that recognizes
that the MSR register changes, the following line must be called for
this code to work properly:</p>

<pre>wake_up_interruptible(&amp;tp-&gt;wait);</pre><BR>


<a name="chp-18-ITERM-7985"></a><a name="chp-18-ITERM-7986"></a><dl class="docList"><dt><span class="docPubcolor"> <span class="docPubcolor"><span class="docMonofont">TIOCGICOUNT</span></span> </span></dt></P>
<dd>
<p class="docList">Gets<a name="chp-18-ITERM-7985"></a>
<a name="chp-18-ITERM-7986"></a>
interrupt counts. This is called when the user wants to know how many
serial line interrupts have happened. If the driver has an interrupt
handler, it should define an internal structure of counters to keep
track of these statistics and increment the proper counter every time
the function is run by the kernel.</p>
</dd>
</dl>
<p class="docText">This <span class="docEmphasis">ioctl</span> call passes the kernel a pointer to a
structure
<tt>serial_icounter_struct</tt><a name="chp-18-ITERM-7987"></a>
<a name="chp-18-ITERM-7988"></a>,
which should be filled by the tty driver. This call is often made in
conjunction with the previous <tt>TIOCMIWAIT</tt>
<span class="docEmphasis">ioctl</span> call. If the tty driver keeps track of all
of these interrupts while the driver is operating, the code to
implement this call can be very simple:</p>

<a name="chp-18-ITERM-7989"></a><a name="chp-18-ITERM-7990"></a><a name="chp-18-ITERM-7991"></a><a name="chp-18-ITERM-7992"></a><a name="chp-18-ITERM-7993"></a><pre>static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
    struct tiny_serial *tiny = tty-&gt;driver_data;
    if (cmd =  = TIOCGICOUNT) {
        struct async_icount cnow = tiny-&gt;icount;
        struct serial_icounter_struct icount;
        icount.cts  = cnow.cts;
        icount.dsr  = cnow.dsr;
        icount.rng  = cnow.rng;
        icount.dcd  = cnow.dcd;
        icount.rx   = cnow.rx;
        icount.tx   = cnow.tx;
        icount.frame    = cnow.frame;
        icount.overrun  = cnow.overrun;
        icount.parity   = cnow.parity;
        icount.brk  = cnow.brk;
        icount.buf_overrun = cnow.buf_overrun;
        if (copy_to_user((void _ _user *)arg, &amp;icount, sizeof(icount)))
            return -EFAULT;
        return 0;
    }
    return -ENOIOCTLCMD;




}</pre><br>



<UL></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-18-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-18-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
