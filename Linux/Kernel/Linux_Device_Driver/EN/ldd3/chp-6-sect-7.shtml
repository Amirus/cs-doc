<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>6.7. Quick Reference</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-6-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-6-sect-7"></a>
<h3 class="docSection1Title">6.7. Quick Reference</h3>

<p class="docText">This chapter introduced the following symbols and header files:</p>

<a name="chp-6-ITERM-5421"></a><a name="chp-6-ITERM-5422"></a><a name="chp-6-ITERM-5423"></a><a name="chp-6-ITERM-5424"></a><a name="chp-6-ITERM-5425"></a><a name="chp-6-ITERM-5426"></a><a name="chp-6-ITERM-5427"></a><a name="chp-6-ITERM-5428"></a><a name="chp-6-ITERM-5429"></a><a name="chp-6-ITERM-5430"></a><a name="chp-6-ITERM-5431"></a><a name="chp-6-ITERM-5432"></a><a name="chp-6-ITERM-5433"></a><a name="chp-6-ITERM-5434"></a><a name="chp-6-ITERM-5435"></a><a name="chp-6-ITERM-5436"></a><a name="chp-6-ITERM-5437"></a><a name="chp-6-ITERM-5438"></a><a name="chp-6-ITERM-5439"></a><a name="chp-6-ITERM-5440"></a><a name="chp-6-ITERM-5441"></a><a name="chp-6-ITERM-5442"></a><a name="chp-6-ITERM-5443"></a><a name="chp-6-ITERM-5444"></a><a name="chp-6-ITERM-5445"></a><a name="chp-6-ITERM-5446"></a><a name="chp-6-ITERM-5447"></a><a name="chp-6-ITERM-5448"></a><a name="chp-6-ITERM-5449"></a><a name="chp-6-ITERM-5450"></a><a name="chp-6-ITERM-5451"></a><a name="chp-6-ITERM-5452"></a><a name="chp-6-ITERM-5453"></a><a name="chp-6-ITERM-5454"></a><a name="chp-6-ITERM-5455"></a><a name="chp-6-ITERM-5456"></a><a name="chp-6-ITERM-5457"></a><a name="chp-6-ITERM-5458"></a><a name="chp-6-ITERM-5459"></a><a name="chp-6-ITERM-5460"></a><a name="chp-6-ITERM-5461"></a><a name="chp-6-ITERM-5462"></a><a name="chp-6-ITERM-5463"></a><a name="chp-6-ITERM-5464"></a><a name="chp-6-ITERM-5465"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/ioctl.h&gt;</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-6-ITERM-5421"></a>
<a name="chp-6-ITERM-5422"></a><a name="chp-6-ITERM-5423"></a>Declares all the macros used to define
<span class="docEmphasis">ioctl</span> commands. It is currently included by
<I>&lt;linux/fs.h&gt;</I>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_NRBITS</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_TYPEBITS</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_SIZEBITS</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_DIRBITS</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5424"></a><a name="chp-6-ITERM-5425"></a><a name="chp-6-ITERM-5426"></a><a name="chp-6-ITERM-5427"></a><a name="chp-6-ITERM-5428"></a>The number of
bits available for the different bitfields of
<span class="docEmphasis">ioctl</span> commands. There are also four macros that
specify the <tt>MASK</tt>s and four that specify the
<tt>SHIFT</tt>s, but they're mainly for
internal use. <tt>_IOC_SIZEBITS</tt> is an important value
to check, because it changes across architectures.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_NONE</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_READ</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_WRITE</span></span></span></dt></P>
<dd>
<p class="docList">The possible values for the
"direction" bitfield.
"Read" and
"write" are different bits and can
be ORed to specify read/write. The values are 0-based.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC(dir,type,nr,size)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IO(type,nr)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOR(type,nr,size)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOW(type,nr,size)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOWR(type,nr,size)</span></span></span></dt></P>
<dd>
<p class="docList">Macros used to
create<a name="chp-6-ITERM-5429"></a> <a name="chp-6-ITERM-5430"></a>
<a name="chp-6-ITERM-5431"></a>
an <span class="docEmphasis">ioctl</span> command.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_DIR(nr)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_TYPE(nr)</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_NR(nr)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_IOC_SIZE(nr)</span></span></span></dt></p>
<dd>
<p class="docList">Macros used to decode a command. In particular,
<tt>_IOC_TYPE(nr)</tt> is an OR combination of
<tt>_IOC_READ</tt> and <tt>_IOC_WRITE</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/uaccess.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int access_ok(int type, const void *addr, unsigned long size);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5432"></a>
<a name="chp-6-ITERM-5433"></a>Checks that a pointer to user space is
actually usable. <span class="docEmphasis">access_ok</span> returns a nonzero
value if the access should be allowed.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">VERIFY_READ</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">VERIFY_WRITE</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-6-ITERM-5434"></a>The possible values for the
<tt>type</tt> argument in <span class="docEmphasis">access_ok</span>.
<tt>VERIFY_WRITE</tt> is a superset of
<tt>VERIFY_READ</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/uaccess.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int put_user(datum,ptr);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int get_user(local,ptr);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int _ _put_user(datum,ptr);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int _ _get_user(local,ptr);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5435"></a>
<a name="chp-6-ITERM-5436"></a><a name="chp-6-ITERM-5437"></a>
<a name="chp-6-ITERM-5438"></a>Macros
used to store or retrieve a datum to or from user space. The number
of bytes being transferred depends on
<tt>sizeof(*ptr)</tt>. The regular versions call
<span class="docEmphasis">access_ok</span> first, while the qualified versions
(<span class="docEmphasis">_ _put_user</span> and <span class="docEmphasis">_
_get_user</span>) assume that <span class="docEmphasis">access_ok</span> has
already been called.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/capability.h&gt;</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5439"></a>
<a name="chp-6-ITERM-5440"></a>Defines the various
<tt>CAP_</tt> symbols describing the capabilities a
user-space process may have.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int capable(int capability);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5441"></a>
<a name="chp-6-ITERM-5442"></a>Returns
nonzero if the process has the given capability.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/wait.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">typedef struct { /* ... */ } wait_queue_head_t;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void init_waitqueue_head(wait_queue_head_t *queue);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DECLARE_WAIT_QUEUE_HEAD(queue);</span></span></span></dt></P>
<dd>
<p class="docList">The defined type <a name="chp-6-ITERM-5443"></a>
<a name="chp-6-ITERM-5444"></a>for
Linux wait queues. A <tt>wait_queue_head_t</tt> must be
explicitly initialized with either
<span class="docEmphasis">init_waitqueue_head</span> at runtime or
<span class="docEmphasis">DECLARE_WAIT_QUEUE_HEAD</span> at compile time.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wait_event(wait_queue_head_t q, int condition);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int wait_event_interruptible(wait_queue_head_t q, int condition);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int wait_event_timeout(wait_queue_head_t q, int condition, int time);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int wait_event_interruptible_timeout(wait_queue_head_t q, int condition</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">int</span></span> <span class="docPubcolor"><span class="docMonofont">time);</span></span></span></dt></P>
<dd>
<p class="docList">Cause the process to sleep on the given queue until the given
<tt>condition</tt> evaluates to a true value.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wake_up(struct wait_queue **q);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wake_up_interruptible(struct wait_queue **q);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wake_up_nr(struct wait_queue **q, int nr);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wake_up_interruptible_nr(struct wait_queue **q, int nr);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wake_up_all(struct wait_queue **q);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wake_up_interruptible_all(struct wait_queue **q);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wake_up_interruptible_sync(struct wait_queue **q);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5445"></a>
<a name="chp-6-ITERM-5446"></a><a name="chp-6-ITERM-5447"></a>
<a name="chp-6-ITERM-5448"></a><a name="chp-6-ITERM-5449"></a>
<a name="chp-6-ITERM-5450"></a><a name="chp-6-ITERM-5451"></a>
<a name="chp-6-ITERM-5452"></a><a name="chp-6-ITERM-5453"></a>
<a name="chp-6-ITERM-5454"></a>Wake
processes that are sleeping on the queue <tt>q</tt>. The
<span class="docEmphasis">_interruptible</span> form wakes only interruptible
processes. Normally, only one exclusive waiter is awakened, but that
behavior can be changed with the <span class="docEmphasis">_nr</span> or
<span class="docEmphasis">_all</span> forms. The <span class="docEmphasis">_sync</span>
version does not reschedule the CPU before returning.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/sched.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">set_current_state(int state);</span></span></span></dt></p>
<dd>
<p class="docList">Sets the execution state of the current process.
<tt>TASK_RUNNING</tt> means it is ready to run, while the
sleep states are <tt>TASK_INTERRUPTIBLE</tt> and
<tt>TASK_UNINTERRUPTIBLE</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void schedule(void);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5455"></a>
<a name="chp-6-ITERM-5456"></a>Selects
a runnable process from the run queue. The chosen process can be
<tt>current</tt> or a different one.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">typedef struct { /* ... */ } wait_queue_t;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">init_waitqueue_entry(wait_queue_t *entry, struct task_struct *task);</span></span></span></dt></P>
<dd>
<p class="docList">The <tt>wait_queue_t</tt> type is used to place a process
onto a wait queue.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void prepare_to_wait(wait_queue_head_t *queue, wait_queue_t *wait, int state);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void prepare_to_wait_exclusive(wait_queue_head_t *queue, wait_queue_t *wait</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">int state);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void finish_wait(wait_queue_head_t *queue, wait_queue_t *wait);</span></span></span></dt></p>
<dd>
<p class="docList">Helper functions that can be used to code a manual sleep.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void sleep_on(wiat_queue_head_t *queue);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void interruptible_sleep_on(wiat_queue_head_t *queue);</span></span></span></dt></p>
<dd>
<p class="docList">Obsolete and deprecated functions that unconditionally put the
current process to sleep.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/poll.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void poll_wait(struct file *filp, wait_queue_head_t *q, poll_table *p)</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5457"></a>
<a name="chp-6-ITERM-5458"></a><a name="chp-6-ITERM-5459"></a>
<a name="chp-6-ITERM-5460"></a><a name="chp-6-ITERM-5461"></a>Places the current process into a wait
queue without scheduling immediately. It is designed to be used by
the <span class="docEmphasis">poll</span> method of device drivers.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int fasync_helper(struct inode *inode, struct file *filp, int mode, struct</span></span> </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">fasync_struct **fa);</span></span> </span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5462"></a>
<a name="chp-6-ITERM-5463"></a>A
"helper" for implementing the
<span class="docEmphasis">fasync</span> device method. The
<tt>mode</tt> argument is the same value that is passed to
the method, while <tt>fa</tt> points to a device-specific
<tt>fasync_struct *</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void kill_fasync(struct fasync_struct *fa, int sig, int band);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-6-ITERM-5464"></a>
<a name="chp-6-ITERM-5465"></a>If
the driver supports asynchronous notification, this function can be
used to send a signal to processes registered in
<tt>fa</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int nonseekable_open(struct inode *inode, struct file *filp);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">loff_t no_llseek(struct file *file, loff_t offset, int whence);</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">nonseekable_open</span> should be called in the
<span class="docEmphasis">open</span> method of any device that does not support
seeking. Such devices should also use <span class="docEmphasis">no_llseek</span>
as their <span class="docEmphasis">llseek</span> method.</p>
</dd>
</dl>


<ul></UL></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-6-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
