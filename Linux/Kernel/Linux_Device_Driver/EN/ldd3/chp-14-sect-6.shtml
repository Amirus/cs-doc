<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>14.6. Putting It All Together</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-14-sect-6"></a>
<H3 class="docSection1Title">14.6. Putting It All Together</H3>

<p class="docText">To better understand<a name="chp-14-ITERM-6804"></a>
<a name="chp-14-ITERM-6805"></a>
<a name="chp-14-ITERM-6806"></a>
<a name="chp-14-ITERM-6807"></a>
<a name="chp-14-ITERM-6808"></a> what the driver model does, let
us walk through the steps of a device's lifecycle
within the kernel. We describe how the PCI subsystem interacts with
the driver model, the basic concepts of how a driver is added and
removed, and how a device is added and removed from the system. These
details, while describing the PCI kernel code specifically, apply to
all other subsystems that use the driver core to manage their drivers
and devices.</p>

<p class="docText">The interaction between the PCI core, driver core, and the individual
PCI drivers is quite complex, as <a class="docLink" href="chp-14-sect-1.shtml#chp-14-FIG-2">Figure 14-2</a> shows.</p>

<a name="chp-14-FIG-3"></a><p><center>
<h5 class="docFigureTitle">Figure 14-3. Device-creation process</H5>
<img border="0" alt="" width="414" height="310" SRC="images/0596005903/figs/ldr3_1403.gif"></center></p><br>

<a name="chp-14-sect-6.1"></a>
<H4 class="docSection2Title">14.6.1. Add a Device</h4>

<p class="docText">The PCI subsystem <a name="chp-14-ITERM-6809"></a>
<a name="chp-14-ITERM-6810"></a>
<a name="chp-14-ITERM-6811"></a>declares
a single <tt>struct</tt> <tt>bus_type</tt> called
<tt>pci_bus_type</tt>, which is initialized with the
following values:</p>

<pre>struct bus_type pci_bus_type = {
    .name      = "pci",
    .match     = pci_bus_match,
    .hotplug   = pci_hotplug,
    .suspend   = pci_device_suspend,
    .resume    = pci_device_resume,
    .dev_attrs = pci_dev_attrs,
};</pre><BR>


<p class="docText">This <tt>pci_bus_type</tt><a name="chp-14-ITERM-6812"></a>
<a name="chp-14-ITERM-6813"></a>
variable is registered with the driver core when the PCI subsystem is
loaded in the kernel with a call to
<span class="docEmphasis">bus_register</span>. When that happens, the driver core
creates a sysfs directory in <i>/sys/bus/pci</I> that
consists of two directories: <i>devices</i> and
<i>drivers</i>.</p>

<p class="docText">All PCI drivers must define a <tt>struct pci_driver</tt>
variable that defines the different functions that this PCI driver
can do (for more information about the PCI subsystem and how to write
a PCI driver, see <a class="docLink" href="chp-12.shtml#chp-12">Chapter 12</a>).
That structure contains a <tt>struct device_driver</tt>
that is then initialized by the PCI core when the PCI driver is
registered:</p>

<pre>/* initialize common driver fields */
drv-&gt;driver.name = drv-&gt;name;
drv-&gt;driver.bus = &amp;pci_bus_type;
drv-&gt;driver.probe = pci_device_probe;
drv-&gt;driver.remove = pci_device_remove;
drv-&gt;driver.kobj.ktype = &amp;pci_driver_kobj_type;</pre><br>


<p class="docText">This code sets up the bus for the driver to point to the
<tt>pci_bus_type</tt> and points the
<span class="docEmphasis">probe</span> and <span class="docEmphasis">remove</span> functions
to point to functions within the PCI core. The
<tt>ktype</tt> for the driver's
<tt>kobject</tt> is set to the variable
<tt>pci_driver_kobj_type</tt>, in order for the PCI
driver's attribute files to work properly. Then the
PCI core registers the PCI driver with the driver core:</p>

<pre>/* register with core */
error = driver_register(&amp;drv-&gt;driver);</pre><br>


<p class="docText">The driver is now ready to be bound to any PCI devices it supports.</p>

<p class="docText">The PCI core, with help from the architecture-specific code that
actually talks to the PCI bus, starts probing the PCI address space,
looking for all PCI devices. When a PCI device is found, the PCI core
creates a new variable in memory of type <tt>struct</tt>
<tt>pci_dev</tt>. A portion of the <tt>struct
pci_dev</tt> structure looks like the following:</p>

<pre>struct pci_dev {
    /* ... */
    unsigned int   devfn;
    unsigned short vendor;
    unsigned short device;
    unsigned short subsystem_vendor;
    unsigned short subsystem_device;
    unsigned int   class;
    /* ... */
    struct pci_driver *driver;
    /* ... */
    struct device dev;
    /* ... */
};</pre><br>


<p class="docText">The bus-specific fields of this PCI device are initialized by the PCI
core (the <tt>devfn</tt>, <tt>vendor</tt>,
<tt>device</tt>, and other fields), and the
<tt>struct</tt> <tt>device</tt>
variable's <tt>parent</tt> variable is set
to the PCI bus device that this PCI device lives on. The
<tt>bus</tt> variable is set to point at the
<tt>pci_bus_type</tt> structure. Then the
<tt>name</tt> and <tt>bus_id</tt> variables are
set, depending on the name and ID that is read from the PCI device.</p>

<p class="docText">After the PCI device structure is initialized, the device is
registered with the driver core with a call to:</P>

<pre>device_register(&amp;dev-&gt;dev);</pre><br>


<p class="docText">Within the <span class="docEmphasis">device_register</span> function, the driver
core initializes a number of the device's fields,
registers the device's kobject with the kobject core
(which causes a hotplug event to be generated, but we discuss that
later in this chapter), and then adds the device to the list of
devices that are held by the device's parent. This
is done so that all devices can be walked in the proper order, always
knowing where in the hierarchy of devices each one lives.</P>

<p class="docText">The device is then added to the bus-specific list of all devices, in
this example, the <tt>pci_bus_type</tt> list. Then the list
of all drivers that are registered with the bus is walked, and the
<span class="docEmphasis">match</span> function of the bus is called for every
driver, specifying this device. For the
<tt>pci_bus_type</tt> bus, the <span class="docEmphasis">match</span>
function was set to point to the <span class="docEmphasis">pci_bus_match</span>
function by the PCI core before the device was submitted to the
driver core.</P>

<p class="docText">The <span class="docEmphasis">pci_bus_match</span> function casts the
<tt>struct</tt> <tt>device</tt> that was passed
to it by the driver core, back into a <tt>struct</tt>
<tt>pci_dev</tt>. It also casts the
<tt>struct</tt> <tt>device_driver</tt> back into
a <tt>struct</tt> <tt>pci_driver</tt> and then
looks at the PCI device-specific information of the device and driver
to see if the driver states that it can support this kind of device.
If the match is not successful, the function returns
<tt>0</tt> back to the driver core, and the driver core
moves on to the next driver in its list.</p>

<p class="docText">If the match is successful, the function returns <tt>1</tt>
back to the driver core. This causes the driver core to set the
<tt>driver</tt> pointer in the <tt>struct</tt>
<tt>device</tt> to point to this driver, and then it calls
the <span class="docEmphasis">probe</span> function that is specified in the
<tt>struct device_driver</tt>.</p>

<p class="docText">Earlier, before the PCI driver was registered with the driver core,
the <tt>probe</tt> variable was set to point at the
<span class="docEmphasis">pci_device_probe</span> function. This function casts
(yet again) the <tt>struct</tt> <tt>device</tt>
back into a <tt>struct</tt> <tt>pci_dev</tt> and
the <tt>struct</tt> <tt>driver</tt> that is set
in the device back into a <tt>struct</tt>
<tt>pci_driver</tt>. It again verifies that this driver
states that it can support this device (which seems to be a redundant
extra check for some unknown reason), increments the reference count
of the device, and then calls the PCI driver's
<span class="docEmphasis">probe</span> function with a pointer to the
<tt>struct</tt> <tt>pci_dev</tt> structure it
should bind to.</p>

<p class="docText">If the PCI driver's <span class="docEmphasis">probe</span>
function determines that it can not handle this device for some
reason, it returns a negative error value, which is propagated back
to the driver core and causes it to continue looking through the list
of drivers to match one up with this device. If the
<span class="docEmphasis">probe</span> function can claim the device, it does all
the initialization that it needs to do to handle the device properly,
and then it returns <tt>0</tt> back up to the driver core.
This causes the driver core to add the device to the list of all
devices currently bound by this specific driver and creates a symlink
within the driver's directory in sysfs to the device
that it is now controlling. This symlink allows users to see exactly
which devices are bound to which devices. This can be seen as:</P>

<a name="chp-14-ITERM-6814"></a><a name="chp-14-ITERM-6815"></a><a name="chp-14-ITERM-6816"></a><pre>$ tree /sys/bus/pci
/sys/bus/pci/
|-- devices
|   |-- 0000:00:00.0 -&gt; ../../../devices/pci0000:00/0000:00:00.0
|   |-- 0000:00:00.1 -&gt; ../../../devices/pci0000:00/0000:00:00.1
|   |-- 0000:00:00.2 -&gt; ../../../devices/pci0000:00/0000:00:00.2
|   |-- 0000:00:02.0 -&gt; ../../../devices/pci0000:00/0000:00:02.0
|   |-- 0000:00:04.0 -&gt; ../../../devices/pci0000:00/0000:00:04.0
|   |-- 0000:00:06.0 -&gt; ../../../devices/pci0000:00/0000:00:06.0
|   |-- 0000:00:07.0 -&gt; ../../../devices/pci0000:00/0000:00:07.0
|   |-- 0000:00:09.0 -&gt; ../../../devices/pci0000:00/0000:00:09.0
|   |-- 0000:00:09.1 -&gt; ../../../devices/pci0000:00/0000:00:09.1
|   |-- 0000:00:09.2 -&gt; ../../../devices/pci0000:00/0000:00:09.2
|   |-- 0000:00:0c.0 -&gt; ../../../devices/pci0000:00/0000:00:0c.0
|   |-- 0000:00:0f.0 -&gt; ../../../devices/pci0000:00/0000:00:0f.0
|   |-- 0000:00:10.0 -&gt; ../../../devices/pci0000:00/0000:00:10.0
|   |-- 0000:00:12.0 -&gt; ../../../devices/pci0000:00/0000:00:12.0
|   |-- 0000:00:13.0 -&gt; ../../../devices/pci0000:00/0000:00:13.0
|   `-- 0000:00:14.0 -&gt; ../../../devices/pci0000:00/0000:00:14.0
`-- drivers
    |-- ALI15x3_IDE
    |   `-- 0000:00:0f.0 -&gt; ../../../../devices/pci0000:00/0000:00:0f.0
    |-- ehci_hcd
    |   `-- 0000:00:09.2 -&gt; ../../../../devices/pci0000:00/0000:00:09.2
    |-- ohci_hcd
    |   |-- 0000:00:02.0 -&gt; ../../../../devices/pci0000:00/0000:00:02.0
    |   |-- 0000:00:09.0 -&gt; ../../../../devices/pci0000:00/0000:00:09.0
    |   `-- 0000:00:09.1 -&gt; ../../../../devices/pci0000:00/0000:00:09.1
    |-- orinoco_pci
    |   `-- 0000:00:12.0 -&gt; ../../../../devices/pci0000:00/0000:00:12.0
    |-- radeonfb
    |   `-- 0000:00:14.0 -&gt; ../../../../devices/pci0000:00/0000:00:14.0
    |-- serial
    `-- trident
        `-- 0000:00:04.0 -&gt; ../../../../devices/pci0000:00/0000:00:04

.0</pre><br>



<a name="chp-14-sect-6.2"></a>
<H4 class="docSection2Title">14.6.2. Remove a Device</H4>

<p class="docText">A PCI device
can<a name="chp-14-ITERM-6817"></a>
<a name="chp-14-ITERM-6818"></a>
<a name="chp-14-ITERM-6819"></a>
be removed from a system in a number of different ways. All CardBus
devices are really PCI devices in a different physical form factor,
and the kernel PCI core does not differenciate between them. Systems
that allow the removal or addition of PCI devices while the machine
is still running are becoming more popular, and Linux supports them.
There is also a fake PCI Hotplug driver that allows developers to
test to see if their PCI driver properly handles the removal of a
device while the system is running. This module is called
<tt>fakephp</tt> and causes the kernel to think the PCI
device is gone, but it does not allow users to physically remove a
PCI device from a system that does not have the proper hardware to do
so. See the documentation with this driver for more information on
how to use it to test your PCI drivers.</P>

<p class="docText">The PCI core exerts a lot less effort to remove a device than it does
to add it. When a PCI device is to be removed, the
<i></i><a name="chp-14-ITERM-6820"></a>
<a name="chp-14-ITERM-6821"></a><span class="docEmphasis">pci_remove_bus_device</span>
function is called. This function does some PCI-specific cleanups and
housekeeping, and then calls the
<span class="docEmphasis">device_unregister</span> function with a pointer to the
<tt>struct</tt>
<tt>pci_dev</tt>'s
<tt>struct</tt> <tt>device</tt> member.</p>

<p class="docText">In the <span class="docEmphasis">device_unregister</span> function, the driver
core merely unlinks the sysfs files from the driver bound to the
device (if there was one), removes the device from its internal list
of devices, and calls <span class="docEmphasis">kobject_del</span> with a pointer
to the <tt>struct kobject</tt> that is contained in the
<tt>struct device</tt> structure. That function makes a
hotplug call to user space stating that the kobject is now removed
from the system, and then it deletes all sysfs files associated with
the kobject and the sysfs directory itself that the kobject had
originally created.</p>

<p class="docText">The <span class="docEmphasis">kobject_del</span> function also removes the
kobject reference of the device itself. If that reference was the
last one (meaning no user-space files were open for the sysfs entry
of the device), then the <span class="docEmphasis">release</span> function for
the PCI device itself, <span class="docEmphasis">pci_release_dev</span>, is
called. That function merely frees up the memory that the
<tt>struct pci_dev</tt> took up.</P>

<p class="docText">After this, all sysfs entries associated with the device are removed,
and the memory associated with the device is released. The PCI device
is now totally removed from the system.</P>


<a name="chp-14-sect-6.3"></a>
<H4 class="docSection2Title">14.6.3. Add a Driver</h4>

<p class="docText">A PCI driver is added
<a name="chp-14-ITERM-6822"></a>
<a name="chp-14-ITERM-6823"></a>
<a name="chp-14-ITERM-6824"></a>to
the PCI core when it calls the
<span class="docEmphasis">pci_register_driver</span> function. This function
merely initializes the <tt>struct</tt>
<tt>device_driver</tt> structure that is contained within
the <tt>struct</tt> <tt>pci_driver</tt>
structure, as previously mentioned in the section about adding a
device. Then the PCI core calls the
<span class="docEmphasis">driver_register</span> function in the driver core with
a pointer to the <tt>structdevice_driver</tt> structure
contained in the <tt>struct</tt>
<tt>pci_driver</tt> structure.</P>

<p class="docText">The <span class="docEmphasis">driver_register</span> function initializes a few
locks in the <tt>struct</tt>
<tt>device_driver</tt> structure, and then calls the
<I></i><a name="chp-14-ITERM-6825"></a>
<a name="chp-14-ITERM-6826"></a><span class="docEmphasis">bus_add_driver</span>
function. This function does the following steps:</p>

<ul><li><p class="docList">Looks up the bus that the driver is to be associated with. If this
bus is not found, the function instantly returns.</P></li><li><p class="docList">The driver's sysfs directory is created based on the
name of the driver and the bus that it is associated with.</P></li><li><p class="docList">The bus's internal lock is grabbed, and then all
devices that have been registered with the bus are walked, and the
match function is called for them, just like when a new device is
added. If that match function succeeds, then the rest of the binding
process occurs, as described in the previous section.</P></li></UL>

<a name="chp-14-sect-6.4"></a>
<h4 class="docSection2Title">14.6.4. Remove a Driver</h4>

<p class="docText">Removing a driver is
<a name="chp-14-ITERM-6827"></a>
<a name="chp-14-ITERM-6828"></a>
<a name="chp-14-ITERM-6829"></a>a
very simple action. For a PCI driver, the driver calls the
<span class="docEmphasis">pci_unregister_driver</span> function. This function
merely calls the driver core function
<span class="docEmphasis">driver_unregister</span>, with a pointer to the
<tt>struct</tt> <tt>device_driver</tt> portion of
the <tt>struct</tt> <tt>pci_driver</tt> structure
passed to it.</p>

<p class="docText">The <i></i><a name="chp-14-ITERM-6830"></a>
<a name="chp-14-ITERM-6831"></a><span class="docEmphasis">driver_unregister</span>
function handles some basic housekeeping by cleaning up some sysfs
attributes that were attached to the driver's entry
in the sysfs tree. It then iterates over all devices that were
attached to this driver and calls the <span class="docEmphasis">release</span>
function for it. This happens exactly like the previously mentioned
<span class="docEmphasis">release</span> function for when a device is removed
from the system.</p>

<p class="docText">After all devices are unbound from the driver, the driver code does
this unique bit of logic:</p>

<pre>down(&amp;drv-&gt;unload_sem);
up(&amp;drv-&gt;unload_sem);</pre><br>


<p class="docText">This is done right before returning to the caller of the function.
This lock is grabbed because the code needs to wait for all reference
counts on this driver to be dropped to <tt>0</tt> before it
is safe to return. This is needed because the
<span class="docEmphasis">driver_unregister</span> function is most commonly
called as the exit path of a module that is being unloaded. The
module needs to remain in memory for as long as the driver is being
referenced by devices and by waiting for this lock to be freed, this
allows the kernel to know when it is safe to remove the driver
from<a name="chp-14-ITERM-6832"></a>
<a name="chp-14-ITERM-6833"></a>
<a name="chp-14-ITERM-6834"></a>
<a name="chp-14-ITERM-6835"></a>
<a name="chp-14-ITERM-6836"></a> memory.</p>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
