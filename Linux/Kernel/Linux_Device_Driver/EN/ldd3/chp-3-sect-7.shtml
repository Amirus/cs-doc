<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>3.7. read and write</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-3-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-3-sect-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-3-sect-7"></a>
<H3 class="docSection1Title" >3.7. read and write</H3>

<p class="docText"><a name="chp-3-ITERM-4591"></a><a name="chp-3-ITERM-4592"></a>The <span class="docEmphasis">read</span> and
<span class="docEmphasis">write</span> methods both<a name="chp-3-ITERM-4593"></a> <a name="chp-3-ITERM-4594"></a> <a name="chp-3-ITERM-4595"></a>
<a name="chp-3-ITERM-4596"></a> <a name="chp-3-ITERM-4597"></a>
<a name="chp-3-ITERM-4598"></a>
perform a similar task, that is, copying data from and to application
code. Therefore, their prototypes are pretty similar, and
it's worth introducing them at the same time:</p>

<pre>ssize_t read(struct file *filp, char _ _user *buff,
    size_t count, loff_t *offp);
ssize_t write(struct file *filp, const char _ _user *buff,
    size_t count, loff_t *offp);</pre><br>


<p class="docText"><a name="chp-3-ITERM-4599"></a>For both methods,
<tt>filp</tt> is the file pointer and
<tt>count</tt> is the size of the requested data transfer.
The <tt>buff</tt> argument points to the user buffer
holding the data to be written or the empty buffer where the newly
read data should be placed. Finally, <tt>offp</tt> is a
pointer to a "long offset type"
object that indicates the file position the user is accessing. The
return value is a "signed size
type"; its use is discussed later.</p>

<p class="docText">Let us repeat that the <tt>buff</tt> argument to the
<span class="docEmphasis">read</span> and <span class="docEmphasis">write</span> methods is a
user-space pointer. Therefore, it cannot be directly dereferenced by
kernel code. There are a few reasons for this restriction:</p>

<UL><li><p class="docList">Depending on which architecture your driver is running on, and how
the kernel was configured, the user-space pointer may not be valid
while running in kernel mode at all. There may be no mapping for that
address, or it could point to some other, random data.</p></LI><li><p class="docList">Even if the pointer does mean the same thing in
<a name="chp-3-ITERM-4600"></a>kernel
space, user-space memory is paged, and the memory in question might
not be resident in RAM when the system call is made. Attempting to
reference the user-space memory directly could generate a page fault,
which is something that kernel code is not allowed to do. The result
would be an "oops," which would
result in the death of the process that made the system call.</p></LI><li><p class="docList">The pointer in question has been supplied by a user program, which
could be buggy or malicious. If your driver ever blindly dereferences
a user-supplied pointer, it provides an open doorway allowing a
user-space program to access or overwrite memory anywhere in the
system. If you do not wish to be responsible for compromising the
security of your users' systems, you cannot ever
dereference a user-space pointer directly.</P></li></ul>
<p class="docText">Obviously, your driver must be able to access the user-space buffer
in order to get its job done. This access must always be performed by
special, kernel-supplied functions, however, in order to be safe. We
introduce some of those functions (which are defined in
<i>&lt;asm/uaccess.h&gt;</i>) here, and the rest in the
<a class="docLink" href="chp-6-sect-1.shtml#chp-6-sect-1.4">Section 6.1.4</a>; they use some
special, architecture-dependent magic to ensure that data transfers
between kernel and user space happen in a safe and correct way.
<a name="chp-3-ITERM-4601"></a><a name="chp-3-ITERM-4602"></a><a name="chp-3-ITERM-4603"></a></p>

<p class="docText">The code for <span class="docEmphasis">read</span> and <span class="docEmphasis">write</span>
in <span class="docEmphasis">scull</span> needs to copy a whole segment of data
to or from the user address space. This capability is offered by the
following kernel functions, which copy an arbitrary array of bytes
and sit at the heart of most <span class="docEmphasis">read</span> and
<span class="docEmphasis">write</span> implementations:</p>

<pre>unsigned long copy_to_user(void _ _user *to, 
                           const void *from, 
                           unsigned long count);
unsigned long copy_from_user(void *to, 
                             const void _ _user *from, 
                             unsigned long count);</pre><br>


<p class="docText">Although these functions behave like normal
<span class="docEmphasis">memcpy</span> functions, a little extra care must be
used when accessing user space from kernel code. The user pages being
addressed might not be currently present in memory, and the virtual
memory subsystem can put the process to sleep while the page is being
transferred into place. This happens, for example, when the page must
be retrieved from swap space. The net result for the driver writer is
that any function that accesses user space must be reentrant, must be
able to execute concurrently with other driver functions, and, in
particular, must be in a position where it can legally sleep. We
return to this subject in <a class="docLink" href="chp-5.shtml#chp-5">Chapter 5</a>.</p>

<p class="docText">The role of the two functions is not limited to copying data to and
from user-space: they also check whether the user space pointer is
valid. If the pointer is invalid, no copy is performed; if an invalid
address is encountered during the copy, on the other hand, only part
of the data is copied. In both cases, the return value is the amount
of memory still to be copied. The <span class="docEmphasis">scull</span> code
looks for this error return, and returns <tt>-EFAULT</tt>
to the user if it's not <tt>0</tt>.</p>

<p class="docText">The topic of user-space access and invalid user space pointers is
somewhat advanced and is discussed in <a class="docLink" href="chp-6.shtml#chp-6">Chapter 6</a>. However,
it's worth noting that if you don't
need to check the user-space pointer you can invoke <span class="docEmphasis">_
_copy_to_user</span> and <span class="docEmphasis">_ _copy_from_user</span>
instead. This is useful, for example, if you know you already checked
the argument. Be careful, however; if, in fact, you do
<span class="docEmphasis">not</span> check a user-space pointer that you pass to
these functions, then you can create kernel crashes and/or security
holes.</p>

<p class="docText">As far as the actual device methods are concerned, the task of the
<span class="docEmphasis">read</span> method is to copy data from the device to
user space (using <span class="docEmphasis">copy_to_user</span>), while the
<span class="docEmphasis">write</span> method must copy data from user space to
the device (using <span class="docEmphasis">copy_from_user</span>). Each
<span class="docEmphasis">read</span> or <span class="docEmphasis">write</span> system call
requests transfer of a specific number of bytes, but the driver is
free to transfer less data—the exact rules are slightly
different for reading and writing and are described later in this
chapter.</p>

<p class="docText"><a name="chp-3-ITERM-4604"></a>
<a name="chp-3-ITERM-4605"></a><a name="chp-3-ITERM-4606"></a>
<a name="chp-3-ITERM-4607"></a>Whatever
the amount of data the methods transfer, they should generally update
the file position at <tt>*offp</tt> to represent the
current file position after successful completion of the system call.
The kernel then propagates the file position change back into the
<tt>file</tt> structure when appropriate. The
<span class="docEmphasis">pread</span> and <span class="docEmphasis">pwrite</span> system
calls have different semantics, however; they operate from a given
file offset and do not change the file position as seen by any other
system calls. These calls pass in a pointer to the user-supplied
position, and discard the changes that your driver makes.</p>

<p class="docText"><a name="chp-3-ITERM-4608"></a>
<a name="chp-3-ITERM-4609"></a><a class="docLink" href="chp-3-sect-7.shtml#chp-3-FIG-2">Figure 3-2</a>
represents how a typical <span class="docEmphasis">read</span>
implementation uses its arguments.</p>

<a name="chp-3-FIG-2"></a><P><center>
<h5 class="docFigureTitle">Figure 3-2. The arguments to read</H5>
<img border="0" alt=""  width="475" height="273" SRC="images/0596005903/figs/ldr3_0302.gif"></center></P><br>

<p class="docText"><a name="chp-3-ITERM-4610"></a>Both
the <span class="docEmphasis">read</span> and <span class="docEmphasis">write</span> methods
return a negative value if an error occurs. A return value greater
than or equal to 0, instead, tells the calling program how many bytes
have been successfully transferred. If some data is transferred
correctly and then an error happens, the return value must be the
count of bytes successfully transferred, and the error does not get
reported until the next time the function is called. Implementing
this convention requires, of course, that your driver remember that
the error has occurred so that it can return the error status in the
future.</p>

<p class="docText">Although kernel functions return a negative number to signal an
error, and the value of the number indicates the kind of error that
occurred (as introduced in <a class="docLink" href="chp-2.shtml#chp-2">Chapter 2</a>), programs that run in user space always see
<tt>-1</tt> as the error return value. They need to access
the <tt>errno</tt> variable to find out what happened. The
user-space behavior is dictated by the POSIX standard, but that
standard does not make requirements on how the kernel operates
internally.</p>

<a name="chp-3-sect-7.1"></a>
<H4 class="docSection2Title">3.7.1. The read Method</h4>

<p class="docText"><a name="chp-3-ITERM-4611"></a>
<a name="chp-3-ITERM-4612"></a>The return value
for <span class="docEmphasis">read</span> is interpreted by the calling
application program:</P>

<UL><LI><p class="docList"><a name="chp-3-ITERM-4613"></a>If the value equals the
<tt>count</tt> argument passed to the
<span class="docEmphasis">read</span> system call, the requested number of bytes
has been transferred. This is the optimal case.</p></li><li><p class="docList">If the value is positive, but smaller than <tt>count</tt>,
only part of the data has been transferred. This may happen for a
number of reasons, depending on the device. Most often, the
application program retries the read. For instance, if you read using
the <span class="docEmphasis">fread</span> function, the library function
reissues the system call until completion of the requested data
transfer.</p></LI><LI><p class="docList">If the value is <tt>0</tt>, end-of-file was reached (and no
data was read).</P></li><LI><p class="docList">A negative value means there was an error. The value specifies what
the error was, according to
<I>&lt;linux/errno.h&gt;</i>. Typical values returned
on error include <tt>-EINTR</tt> (interrupted system call)
or <tt>-EFAULT</tt> (bad address).</p></li></ul>
<p class="docText">What is missing from the preceding list is the case of
"there is no data, but it may arrive
later." In this case, the <span class="docEmphasis">read</span>
system call should block. We'll deal with blocking
input in <a class="docLink" href="chp-6.shtml#chp-6">Chapter 6</a>.</P>

<p class="docText">The <span class="docEmphasis">scull</span> code takes advantage of these rules.
In particular, it takes advantage of the partial-read rule. Each
invocation of <span class="docEmphasis">scull_read</span> deals only with a
single data quantum, without implementing a loop to gather all the
data; this makes the code shorter and easier to read. If the reading
program really wants more data, it reiterates the call. If the
standard I/O library (i.e., <span class="docEmphasis">fread</span>) is used to
read the device, the application won't even notice
the quantization of the data transfer.</p>

<p class="docText">If the current read position is greater than the device size, the
<span class="docEmphasis">read</span> method of <span class="docEmphasis">scull</span>
returns <tt>0</tt> to signal that there's
no data available (in other words, we're at
end-of-file). This situation can happen if process A is reading the
device while process B opens it for writing, thus truncating the
device to a length of 0. Process A suddenly finds itself past
end-of-file, and the next <span class="docEmphasis">read</span> call returns
<tt>0</tt>.</p>

<p class="docText"><a name="chp-3-ITERM-4614"></a>
<a name="chp-3-ITERM-4615"></a>Here is the code for
<span class="docEmphasis">read</span> (ignore the calls to
<span class="docEmphasis">down_interruptible</span> and <span class="docEmphasis">up</span>
for now; we will get to them in the next chapter):</P>

<pre>ssize_t scull_read(struct file *filp, char _ _user *buf, size_t count,
                loff_t *f_pos)
{
    struct scull_dev *dev = filp-&gt;private_data; 
    struct scull_qset *dptr;    /* the first listitem */
    int quantum = dev-&gt;quantum, qset = dev-&gt;qset;
    int itemsize = quantum * qset; /* how many bytes in the listitem */
    int item, s_pos, q_pos, rest;
    ssize_t retval = 0;

    if (down_interruptible(&amp;dev-&gt;sem))
        return -ERESTARTSYS;
    if (*f_pos &gt;= dev-&gt;size)
        goto out;
    if (*f_pos + count &gt; dev-&gt;size)
        count = dev-&gt;size - *f_pos;

    /* find listitem, qset index, and offset in the quantum */
    item = (long)*f_pos / itemsize;
    rest = (long)*f_pos % itemsize;
    s_pos = rest / quantum; q_pos = rest % quantum;

    /* follow the list up to the right position (defined elsewhere) */
    dptr = scull_follow(dev, item);

    if (dptr =  = NULL || !dptr-&gt;data || ! dptr-&gt;data[s_pos])
        goto out; /* don't fill holes */

    /* read only up to the end of this quantum */
    if (count &gt; quantum - q_pos)
        count = quantum - q_pos;

    if (copy_to_user(buf, dptr-&gt;data[s_pos] + q_pos, count)) {
        retval = -EFAULT;
        goto out;
    }
    *f_pos += count;
    retval = count;

  out:
    up(&amp;dev-&gt;sem);
    return retval;
}</pre><br>



<a name="chp-3-sect-7.2"></a>
<h4 class="docSection2Title">3.7.2. The write Method</H4>

<p class="docText"><a name="chp-3-ITERM-4616"></a><a name="chp-3-ITERM-4617"></a>
<a name="chp-3-ITERM-4618"></a><a name="chp-3-ITERM-4619"></a><span class="docEmphasis">write</span>, like
<span class="docEmphasis">read</span>, can transfer less data than was requested,
according to the following rules for the return value:</p>

<UL><li><p class="docList">If the value equals <tt>count</tt>, the requested number of
bytes has been transferred.</p></li><li><p class="docList">If the value is positive, but smaller than <tt>count</tt>,
only part of the data has been transferred. The program will most
likely retry writing the rest of the data.</p></li><li><p class="docList">If the value is <tt>0</tt>, nothing was written. This
result is not an error, and there is no reason to return an error
code. Once again, the standard library retries the call to
<span class="docEmphasis">write</span>. We'll examine the exact
meaning of this case in <a class="docLink" href="chp-6.shtml#chp-6">Chapter 6</a>, where blocking <span class="docEmphasis">write</span> is introduced.</p></li><li><p class="docList">A negative value means an error occurred; as for
<span class="docEmphasis">read</span>, valid error values are those defined in
<i>&lt;linux/errno.h&gt;</i>.</p></LI></ul>
<p class="docText">Unfortunately, there may still be misbehaving programs that issue an
error message and abort when a partial transfer is performed. This
happens because some programmers are accustomed to seeing
<span class="docEmphasis">write</span> calls that either fail or succeed
completely, which is actually what happens most of the time and
should be supported by devices as well. This limitation in the
<span class="docEmphasis">scull</span> implementation could be fixed, but we
didn't want to complicate the code more than
necessary.</P>

<p class="docText"><a name="chp-3-ITERM-4620"></a>
<a name="chp-3-ITERM-4621"></a>The <span class="docEmphasis">scull</span> code for
<span class="docEmphasis">write</span> deals with a single quantum at a time, as
the <span class="docEmphasis">read</span> method does:</P>

<a name="chp-3-ITERM-4622"></a><a name="chp-3-ITERM-4623"></a><a name="chp-3-ITERM-4624"></a><a name="chp-3-ITERM-4625"></a><a name="chp-3-ITERM-4626"></a><a name="chp-3-ITERM-4627"></a><pre>ssize_t scull_write(struct file *filp, const char _ _user *buf, size_t count,
                loff_t *f_pos)
{
    struct scull_dev *dev = filp-&gt;private_data;
    struct scull_qset *dptr;
    int quantum = dev-&gt;quantum, qset = dev-&gt;qset;
    int itemsize = quantum * qset;
    int item, s_pos, q_pos, rest;
    ssize_t retval = -ENOMEM; /* value used in "goto out" statements */

    if (down_interruptible(&amp;dev-&gt;sem))
        return -ERESTARTSYS;

    /* find listitem, qset index and offset in the quantum */
    item = (long)*f_pos / itemsize;
    rest = (long)*f_pos % itemsize;
    s_pos = rest / quantum; q_pos = rest % quantum;

    /* follow the list up to the right position */
    dptr = scull_follow(dev, item);
    if (dptr =  = NULL)
        goto out;
    if (!dptr-&gt;data) {
        dptr-&gt;data = kmalloc(qset * sizeof(char *), GFP_KERNEL);
        if (!dptr-&gt;data)
            goto out;
        memset(dptr-&gt;data, 0, qset * sizeof(char *));
    }
    if (!dptr-&gt;data[s_pos]) {
        dptr-&gt;data[s_pos] = kmalloc(quantum, GFP_KERNEL);
        if (!dptr-&gt;data[s_pos])
            goto out;
    }
    /* write only up to the end of this quantum */
    if (count &gt; quantum - q_pos)
        count = quantum - q_pos;

    if (copy_from_user(dptr-&gt;data[s_pos]+q_pos, buf, count)) {
        retval = -EFAULT;
        goto out;
    }
    *f_pos += count;
    retval = count;

        /* update the size */
    if (dev-&gt;size &lt; *f_pos)
        dev-&gt;size = *f_pos;

  out:
    up(&amp;dev-&gt;sem);
    return retval;






}</pre><br>



<a name="chp-3-sect-7.3"></a>
<h4 class="docSection2Title">3.7.3. readv and writev</h4>

<p class="docText">Unix systems have long supported two <a name="chp-3-ITERM-4628"></a> <a name="chp-3-ITERM-4629"></a>
<a name="chp-3-ITERM-4630"></a> <a name="chp-3-ITERM-4631"></a>
<a name="chp-3-ITERM-4632"></a> <a name="chp-3-ITERM-4633"></a>
<a name="chp-3-ITERM-4634"></a>system
calls named <span class="docEmphasis">readv</span> and
<span class="docEmphasis">writev</span>. These
"vector" versions of
<span class="docEmphasis">read</span> and <span class="docEmphasis">write</span> take an
array of structures, each of which contains a pointer to a buffer and
a length value. A <span class="docEmphasis">readv</span> call would then be
expected to read the indicated amount into each buffer in turn.
<span class="docEmphasis">writev</span>, instead, would gather together the
contents of each buffer and put them out as a single write operation.</P>

<p class="docText">If your driver does not supply methods to handle the
<a name="chp-3-ITERM-4635"></a>
<a name="chp-3-ITERM-4636"></a>
<a name="chp-3-ITERM-4637"></a>vector
operations, <span class="docEmphasis">readv</span> and
<span class="docEmphasis">writev</span> are implemented with multiple calls to
your <span class="docEmphasis">read</span> and <span class="docEmphasis">write</span>
methods. In many situations, however, greater efficiency is acheived
by implementing <span class="docEmphasis">readv</span> and
<span class="docEmphasis">writev</span> directly.</p>

<p class="docText">The prototypes for the vector operations are:</P>

<pre>ssize_t (*readv) (struct file *filp, const struct iovec *iov, 
                  unsigned long count, loff_t *ppos);
ssize_t (*writev) (struct file *filp, const struct iovec *iov, 
                  unsigned long count, loff_t *ppos);</pre><BR>


<p class="docText">Here, the <tt>filp</tt> and <tt>ppos</tt>
arguments are the same as for <span class="docEmphasis">read</span> and
<span class="docEmphasis">write</span>. The <tt>iovec</tt> structure,
defined in <I>&lt;linux/uio.h&gt;</i>, looks like:</p>

<pre>struct iovec
{
    void _  _user *iov_base;
    _ _kernel_size_t iov_len;
};</pre><br>


<p class="docText">Each <tt>iovec</tt> describes one chunk of data to be
transferred; it starts at <tt>iov_base</tt> (in user space)
and is <tt>iov_len</tt> bytes long. The
<tt>count</tt> parameter tells the method how many
<tt>iovec</tt> structures there are. These structures are
created by the application, but the kernel copies them into kernel
space before calling the driver.</p>

<p class="docText">The simplest implementation of the vectored operations would be a
straightforward loop that just passes the address and length out of
each <tt>iovec</tt> to the driver's
<span class="docEmphasis">read</span> or <span class="docEmphasis">write</span> function.
Often, however, efficient and correct behavior requires that the
driver do something smarter. For example, a
<span class="docEmphasis">writev</span> on a tape drive should write the contents
of all the <tt>iovec</tt> structures as a single record on
the tape.</P>

<p class="docText">Many drivers, however, gain no benefit from implementing these
methods themselves. Therefore, <span class="docEmphasis">scull</span> omits them.
The kernel emulates them with <span class="docEmphasis">read</span> and
<span class="docEmphasis">write</span>, and the end result is the same.</P>



<UL></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-3-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-3-sect-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
