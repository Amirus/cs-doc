<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>17.6. Packet Reception</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17-sect-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-17-sect-6"></a>
<h3 class="docSection1Title">17.6. Packet Reception</H3>

<p class="docText">Receiving data from the network is trickier than transmitting it,
because an <tt>sk</tt>_<tt>buff</tt> must be
allocated and handed off to the upper layers from within an atomic
context. There are two modes of packet reception that may be
implemented by network drivers: interrupt driven and polled. Most
drivers implement the interrupt-driven technique, and that is the one
we cover first. Some drivers for high-bandwidth adapters may also
implement the polled technique; we look at this approach in the
<a class="docLink" href="chp-17-sect-8.shtml#chp-17-sect-8">Section 17.8</a>.</p>

<p class="docText">The implementation of <span class="docEmphasis">snull</span> separates the
"hardware" details from the
device-independent housekeeping. Therefore, the function
<span class="docEmphasis">snull_rx</span> is called from the
<span class="docEmphasis">snull</span>
"interrupt" handler after the
hardware has received the packet, and it is already in the
computer's memory. <span class="docEmphasis">snull_rx</span>
receives a pointer to the data and the length of the packet; its sole
responsibility is to send the packet and some additional information
to the upper layers of networking code. This code is independent of
the way the data pointer and length are obtained.</p>

<pre>void snull_rx(struct net_device *dev, struct snull_packet *pkt)
{
    struct sk_buff *skb;
    struct snull_priv *priv = netdev_priv(dev);

    /*
     * The packet has been retrieved from the transmission
     * medium. Build an skb around it, so upper layers can handle it
     */
    skb = dev_alloc_skb(pkt-&gt;datalen + 2);
    if (!skb) {
        if (printk_ratelimit(  ))
            printk(KERN_NOTICE "snull rx: low on mem - packet dropped\n");
        priv-&gt;stats.rx_dropped++;
        goto out;
    }
    memcpy(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);

    /* Write metadata, and then pass to the receive level */
    skb-&gt;dev = dev;
    skb-&gt;protocol = eth_type_trans(skb, dev);
    skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
    priv-&gt;stats.rx_packets++;
    priv-&gt;stats.rx_bytes += pkt-&gt;datalen;
    netif_rx(skb);
  out:
    return;
}</pre><BR>


<p class="docText">The function is sufficiently general to act as a template for any
network driver, but some explanation is necessary before you can
reuse this code fragment with confidence.</p>

<p class="docText"><a name="chp-17-ITERM-7727"></a>
<a name="chp-17-ITERM-7728"></a>
<a name="chp-17-ITERM-7729"></a><a name="chp-17-ITERM-7730"></a>The
first step is to allocate a buffer to hold the packet. Note that the
buffer allocation function (<span class="docEmphasis">dev_alloc_skb</span>) needs
to know the data length. The information is used by the function to
allocate space for the buffer. <span class="docEmphasis">dev_alloc_skb</span>
calls <span class="docEmphasis">kmalloc</span> with atomic priority, so it can be
used safely at interrupt time. The kernel offers other interfaces to
socket-buffer allocation, but they are not worth introducing here;
socket buffers are explained in detail in <a class="docLink" href="chp-17-sect-10.shtml#chp-17-sect-10">Section 17.10</a>.</P>

<p class="docText">Of course, the return value from <span class="docEmphasis">dev_alloc_skb</span>
must be checked, and <span class="docEmphasis">snull</span> does so. We call
<span class="docEmphasis">printk_ratelimit</span> before complaining about
failures, however. Generating hundreds or thousands of console
messages per second is a good way to bog down the system entirely and
hide the real source of problems;
<span class="docEmphasis">printk_ratelimit</span> helps prevent that problem by
returning <tt>0</tt> when too much output has gone to the
console, and things need to be slowed down a bit.</p>

<p class="docText">Once there is a valid <tt>skb</tt> pointer, the packet data
is copied into the buffer by calling <span class="docEmphasis">memcpy</span>; the
<span class="docEmphasis">skb_put</span> function updates the end-of-data pointer
in the buffer and returns a pointer to the newly created space.</p>

<p class="docText"><a name="chp-17-ITERM-7731"></a><a name="chp-17-ITERM-7732"></a>If you are writing a high-performance
driver for an interface that can do full bus-mastering I/O, there is
a possible optimization that is worth considering here. Some drivers
allocate socket buffers for incoming packets prior to their
reception, then instruct the interface to place the packet data
directly into the socket buffer's space. The
networking layer cooperates with this strategy by allocating all
socket buffers in DMA-capable space (which may be in high memory if
your device has the <tt>NETIF_F_HIGHDMA</tt> feature flag
set). Doing things this way avoids the need for a separate copy
operation to fill the socket buffer, but requires being careful with
buffer sizes because you won't know in advance how
big the incoming packet is. The implementation of a
<span class="docEmphasis">change_mtu</span> method is also important in this
situation, since it allows the driver to respond to a change in the
maximum packet size.</p>

<p class="docText"><a name="chp-17-ITERM-7733"></a>The network layer needs to have some
information spelled out before it can make sense of the packet. To
this end, the <tt>dev</tt> and <tt>protocol</tt>
fields must be assigned before the buffer is passed upstairs. The
Ethernet support code exports a helper function
(<span class="docEmphasis">eth_type_trans</span>), which finds an appropriate
value to put into <tt>protocol</tt>. Then we need to
specify how checksumming is to be performed or has been performed on
the packet (<span class="docEmphasis">snull</span> does not need to perform any
checksums). The possible policies for
<tt>skb-&gt;ip_summed</tt> are:</p>

<a name="chp-17-ITERM-7734"></a><a name="chp-17-ITERM-7735"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CHECKSUM_HW</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-17-ITERM-7734"></a>
<a name="chp-17-ITERM-7735"></a>The
device has already performed checksums in hardware. An example of a
hardware checksum is the SPARC HME interface.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CHECKSUM_NONE</span></span></span></dt></p>
<dd>
<p class="docList">Checksums have not yet been verified, and the task must be
accomplished by system software. This is the default in newly
allocated buffers.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CHECKSUM_UNNECESSARY</span></span></span></dt></p>
<dd>
<p class="docList">Don't do any checksums. This is the policy in
<span class="docEmphasis">snull</span> and in the loopback interface.</P>
</dd>
</dl>

<p class="docText">You may be wondering why the checksum status must be specified here
when we have already set a flag in the <tt>features</tt>
field of our <tt>net_device</tt> structure. The answer is
that the <tt>features</tt> flag tells the kernel about how
our device treats outgoing packets. It is not used for incoming
packets, which must, instead, be marked individually.</P>

<p class="docText">Finally, the driver updates its statistics counter to record that a
packet has been received. The statistics structure is made up of
several fields; the most important are <tt>rx_packets</tt>,
<tt>rx_bytes</tt>, <tt>tx_packets</tt>, and
<tt>tx_bytes</tt>, which contain the number of packets
received and transmitted and the total number of octets transferred.
All the fields are thoroughly described in <a class="docLink" href="chp-17-sect-13.shtml#chp-17-sect-13">Section 17.13</a>.</p>

<p class="docText">The last step in packet reception is performed by
<span class="docEmphasis">netif_rx</span>, which hands off the socket buffer to
the upper layers. <span class="docEmphasis">netif_rx</span> actually returns an
integer value; <tt>NET_RX_SUCCESS</tt>
(<tt>0</tt>) means that the packet was successfully
received; any other value indicates trouble. There are three return
values (<tt>NET_RX_CN_LOW</tt>,
<tt>NET_RX_CN_MOD</tt>, and
<tt>NET_RX_CN_HIGH</tt>) that indicate increasing levels of
congestion in the networking subsystem;
<tt>NET_RX_DROP</tt> means the packet was dropped. A driver
could use these values to stop feeding packets into the kernel when
congestion gets high, but, in practice, most drivers ignore the
return value from <span class="docEmphasis">netif_rx</span>. If you are writing a
driver for a high-bandwidth device and wish to do the right thing in
response to congestion, the best approach is to implement NAPI, which
we get to after a quick discussion of interrupt handlers.</p>


<ul></UL></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17-sect-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
