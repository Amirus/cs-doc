<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>6.4. Asynchronous Notification</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-6-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-6-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-6-sect-4"></a>
<h3 class="docSection1Title">6.4. Asynchronous Notification</h3>

<p class="docText">Although the combination<a name="chp-6-ITERM-5343"></a> <a name="chp-6-ITERM-5344"></a> <a name="chp-6-ITERM-5345"></a> of blocking and nonblocking
operations and the <span class="docEmphasis">select</span> method are sufficient
for querying the device most of the time, some situations
aren't efficiently managed by the techniques
we've seen so far.</p>

<p class="docText">Let's imagine a process that executes a long
computational loop at low priority but needs to process incoming data
as soon as possible. If this process is responding to new
observations available from some sort of data acquisition peripheral,
it would like to know immediately when new data is available. This
application could be written to call <span class="docEmphasis">poll</span>
regularly to check for data, but, for many situations, there is a
better way. By enabling asynchronous notification, this application
can receive a signal whenever data becomes available and need not
concern itself with polling.</P>

<p class="docText"><a name="chp-6-ITERM-5346"></a><a name="chp-6-ITERM-5347"></a><a name="chp-6-ITERM-5348"></a><a name="chp-6-ITERM-5349"></a>User programs
have to execute two steps to enable asynchronous notification from an
input file. First, they specify a process as the
"owner" of the file. When a process
invokes the <tt>F_SETOWN</tt><a name="chp-6-ITERM-5350"></a>
<a name="chp-6-ITERM-5351"></a>
command using the <span class="docEmphasis">fcntl</span> system call, the process
ID of the owner process is saved in
<tt>filp-&gt;f_owner</tt> for later use. This step is
necessary for the kernel to know just whom to notify. In order to
actually enable asynchronous notification, the user programs must set
the <tt>FASYNC</tt><a name="chp-6-ITERM-5352"></a>
<a name="chp-6-ITERM-5353"></a>
flag in the device by means of the
<tt>F_SETFL</tt><a name="chp-6-ITERM-5354"></a>
<a name="chp-6-ITERM-5355"></a> <span class="docEmphasis">fcntl</span> command.</p>

<p class="docText"><a name="chp-6-ITERM-5356"></a>After these two
calls have been executed,
<a name="chp-6-ITERM-5357"></a>the input file can
request delivery of a <tt>SIGIO</tt> signal whenever new
data arrives. The signal is sent to the process (or process group, if
the value is negative) stored in <tt>filp-&gt;f_owner</tt>.</P>

<p class="docText">For example, the following lines of code in a user program enable
asynchronous notification to the current process for the
<tt>stdin</tt> input file:</P>

<pre>signal(SIGIO, &amp;input_handler); /* dummy sample; sigaction(  ) is better */
fcntl(STDIN_FILENO, F_SETOWN, getpid(  ));
oflags = fcntl(STDIN_FILENO, F_GETFL);
fcntl(STDIN_FILENO, F_SETFL, oflags | FASYNC);</pre><BR>


<p class="docText">The program named
<span class="docEmphasis">asynctest</span><a name="chp-6-ITERM-5358"></a>
<a name="chp-6-ITERM-5359"></a>
in the sources is a simple program that reads
<tt>stdin</tt> as shown. It can be used to test the
asynchronous capabilities of <span class="docEmphasis">scullpipe</span>. The
program is similar to <span class="docEmphasis">cat</span> but
doesn't terminate on end-of-file; it responds only
to input, not to the absence of input.</p>

<p class="docText"><a name="chp-6-ITERM-5360"></a>Note, however, that not all the
devices support asynchronous notification, and you can choose not to
offer it. Applications usually assume that the asynchronous
capability is available only for sockets and ttys.</p>

<p class="docText">There is one remaining problem with input notification. When a
process receives a <tt>SIGIO</tt>, it
doesn't know which input file has new input to
offer. If more than one file is enabled to asynchronously notify the
process of pending input, the application must still resort to
<span class="docEmphasis">poll</span> or <span class="docEmphasis">select</span> to find out
what happened.</p>

<a name="chp-6-sect-4.1"></a>
<h4 class="docSection2Title">6.4.1. The Driver's Point of View</H4>

<p class="docText"><a name="chp-6-ITERM-5361"></a>A more relevant topic for us
is how the device driver can implement asynchronous signaling. The
following list details the sequence of operations from the
kernel's point of view:</P>

<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">When <tt>F_SETOWN</tt> is invoked, nothing happens, except
that a value is assigned to <tt>filp-&gt;f_owner</tt>.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">When <tt>F_SETFL</tt> is executed to turn on
<tt>FASYNC</tt>, the driver's
<span class="docEmphasis">fasync</span> method is called. This method is called
whenever the value of <tt>FASYNC</tt> is changed in
<tt>filp-&gt;f_flags</tt> to notify the driver of the
change, so it can respond properly. The flag is cleared by default
when the file is opened. We'll look at the standard
implementation of the driver method later in this section.</p></div></li><li><div style="font-weight:normal"><p class="docList">When data arrives, all the processes registered for asynchronous
notification must be sent a <tt>SIGIO</tt> signal.</p></div></LI></ol></div>
<p class="docText">While implementing the first step is
trivial—there's nothing to do on the
driver's part—the other steps involve
maintaining a dynamic data structure to keep track of the different
asynchronous readers; there might be several. This dynamic data
structure, however, doesn't depend on the particular
device involved, and the kernel offers a suitable general-purpose
implementation so that you don't have to rewrite the
same code in every driver.</p>

<p class="docText"><a name="chp-6-ITERM-5362"></a><a name="chp-6-ITERM-5363"></a>The general implementation offered by
Linux is based on one data structure and two functions (which are
called in the second and third steps described earlier). The header
that declares related material is
<i>&lt;linux/fs.h&gt;</I> (nothing new here), and the
data structure is called <tt>struct</tt>
<tt>fasync_struct</tt>. As with wait queues, we need to
insert a pointer to the structure in the device-specific data
structure.</p>

<p class="docText"><a name="chp-6-ITERM-5364"></a>
<a name="chp-6-ITERM-5365"></a><a name="chp-6-ITERM-5366"></a>
<a name="chp-6-ITERM-5367"></a>The
two functions that the driver calls correspond to the following
prototypes:</p>

<pre>int fasync_helper(int fd, struct file *filp,
       int mode, struct fasync_struct **fa);
void kill_fasync(struct fasync_struct **fa, int sig, int band);</pre><BR>


<p class="docText"><tt>fasync_helper</tt> is invoked to add or remove entries
from the list of interested processes when the
<tt>FASYNC</tt> flag changes for an open file. All of its
arguments except the last are provided to the
<span class="docEmphasis">fasync</span> method and can be passed through
directly. <tt>kill_fasync</tt> is used to signal the
interested processes when data arrives. Its arguments are the signal
to send (usually <tt>SIGIO</tt>) and the band, which is
almost always <tt>POLL_IN</tt><sup class="docFootnote"><a class="docLink" href="chp-6-sect-4.shtml#chp-6-FNOTE-6">[6]</a></sup> (but that
may be used to send "urgent" or
out-of-band data in the networking code).</p><blockquote><p class="docFootnote"><sup><a name="chp-6-FNOTE-6">[6]</a></sup> <tt>POLL_IN</tt> is a symbol used in the asynchronous
notification code; it is equivalent to
<tt>POLLIN|POLLRDNORM</tt>.</P></blockquote>

<p class="docText">Here's how <span class="docEmphasis">scullpipe</span> implements
the <span class="docEmphasis">fasync</span> method:</p>

<pre>static int scull_p_fasync(int fd, struct file *filp, int mode)
{
    struct scull_pipe *dev = filp-&gt;private_data;

    return fasync_helper(fd, filp, mode, &amp;dev-&gt;async_queue);
}</pre><br>


<p class="docText">It's clear that all the work is performed by
<span class="docEmphasis">fasync_helper</span>. It wouldn't be
possible, however, to implement the functionality without a method in
the driver, because the helper function needs to access the correct
pointer to <tt>struct</tt> <tt>fasync_struct</tt>
<tt>*</tt> (here
<tt>&amp;dev-&gt;async_queue</tt>), and only the driver can
provide the information.</p>

<p class="docText">When data arrives, then, the following statement must be executed to
signal asynchronous readers. Since new data for the
<span class="docEmphasis">scullpipe</span> reader is generated by a process
issuing a <span class="docEmphasis">write</span>, the statement appears in the
<span class="docEmphasis">write</span> method of <span class="docEmphasis">scullpipe</span>.</p>

<pre>if (dev-&gt;async_queue)
    kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);</pre><br>


<p class="docText">Note that some devices also implement asynchronous notification to
indicate when the device can be written; in this case, of course,
<span class="docEmphasis">kill_fasync</span> must be called with a mode of
<tt>POLL_OUT</tt>.</p>

<p class="docText">It might appear that we're done, but
there's still one thing missing. We must invoke our
<span class="docEmphasis">fasync</span> method when the file is closed to remove
the file from the list of active asynchronous readers. Although this
call is required only if <tt>filp-&gt;f_flags</tt> has
<tt>FASYNC</tt> set, calling the function anyway
doesn't hurt and is the usual implementation. The
following lines, for example, are part of the
<span class="docEmphasis">release</span> method for
<span class="docEmphasis">scullpipe</span>:</p>

<pre>/* remove this filp from the asynchronously notified filp's */
scull_p_fasync(-1, filp, 0);</pre><br>


<p class="docText">The data structure underlying asynchronous notification is almost
identical to the structure <tt>struct</tt>
<tt>wait_queue</tt>, because both situations involve
waiting on an event. The difference is that <tt>struct</tt>
<tt>file</tt> is used in place of <tt>struct</tt>
<tt>task_struct</tt>. The <tt>struct</tt>
<tt>file</tt> in the queue is then used to retrieve
<tt>f_owner</tt>, in<a name="chp-6-ITERM-5368"></a> <a name="chp-6-ITERM-5369"></a> <a name="chp-6-ITERM-5370"></a> order to signal the process.</p>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-6-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-6-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
