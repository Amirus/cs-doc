<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>4.2. Debugging by Printing</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-4-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-4-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="chp-4-sect-2"></a>
<h3 class="docSection1Title">4.2. Debugging by Printing</h3>

<p class="docText">The most common debugging <a name="chp-4-ITERM-4688"></a> <a name="chp-4-ITERM-4689"></a>
<a name="chp-4-ITERM-4690"></a>technique
is monitoring, which in applications programming is done by calling
<span class="docEmphasis">printf</span> at
suitable<a name="chp-4-ITERM-4691"></a>
points. When you are debugging kernel code, you can accomplish the
same goal with <span class="docEmphasis">printk</span>.</p>

<a name="chp-4-sect-2.1"></a>
<h4 class="docSection2Title">4.2.1. printk</H4>

<p class="docText">We used the <span class="docEmphasis">printk</span><a name="chp-4-ITERM-4692"></a> <a name="chp-4-ITERM-4693"></a>
function in earlier chapters with the simplifying assumption that it
works like <span class="docEmphasis">printf</span>. Now it's
time to introduce some of the differences.</p>

<p class="docText"><a name="chp-4-ITERM-4694"></a>One of the differences is that
<span class="docEmphasis">printk</span> lets you classify messages according to
their severity by associating different
<span class="docEmphasis">loglevels</span><a name="chp-4-ITERM-4695"></a>,
or <a name="chp-4-ITERM-4696"></a>priorities,
with the messages. You usually indicate the loglevel with a macro.
For example, <tt>KERN_INFO</tt>, which we saw prepended to
some of the earlier print statements, is one of the possible
loglevels of the message. The loglevel macro expands
to<a name="chp-4-ITERM-4697"></a>
<a name="chp-4-ITERM-4698"></a> a string, which is concatenated to the
message text at compile time; that's why there is no
comma between the priority and the format string in the following
examples. Here are two examples of <span class="docEmphasis">printk</span>
commands, a debug message and a critical message:</P>

<pre>printk(KERN_DEBUG "Here I am: %s:%i\n", _ _FILE_ _, _ _LINE_ _);
printk(KERN_CRIT "I'm trashed; giving up on %p\n", ptr);</pre><BR>


<p class="docText">There are eight possible loglevel strings, defined in the header
<i>&lt;linux/kernel.h&gt;</i>; we list them in order of
decreasing severity:</p>

<a name="chp-4-ITERM-4699"></a><a name="chp-4-ITERM-4700"></a><a name="chp-4-ITERM-4701"></a><a name="chp-4-ITERM-4702"></a><a name="chp-4-ITERM-4703"></a><a name="chp-4-ITERM-4704"></a><a name="chp-4-ITERM-4705"></a><a name="chp-4-ITERM-4706"></a><a name="chp-4-ITERM-4707"></a><a name="chp-4-ITERM-4708"></a><a name="chp-4-ITERM-4709"></a><a name="chp-4-ITERM-4710"></a><a name="chp-4-ITERM-4711"></a><a name="chp-4-ITERM-4712"></a><a name="chp-4-ITERM-4713"></a><a name="chp-4-ITERM-4714"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KERN_EMERG</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-4-ITERM-4699"></a>
<a name="chp-4-ITERM-4700"></a>Used
for emergency messages, usually those that precede a crash.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KERN_ALERT</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-4-ITERM-4701"></a>
<a name="chp-4-ITERM-4702"></a>A
situation requiring immediate action.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KERN_CRIT</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-4-ITERM-4703"></a>
<a name="chp-4-ITERM-4704"></a>Critical
conditions, often related to serious hardware or software failures.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KERN_ERR</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-4-ITERM-4705"></a>
<a name="chp-4-ITERM-4706"></a>Used
to report error conditions; device drivers often use
<tt>KERN_ERR</tt> to report hardware difficulties.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KERN_WARNING</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-4-ITERM-4707"></a>
<a name="chp-4-ITERM-4708"></a>Warnings
about problematic situations that do not, in themselves, create
serious problems with the system.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KERN_NOTICE</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-4-ITERM-4709"></a>
<a name="chp-4-ITERM-4710"></a>Situations
that are normal, but still worthy of note. A number of
security-related conditions are reported at this level.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KERN_INFO</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-4-ITERM-4711"></a>
<a name="chp-4-ITERM-4712"></a>Informational
messages. Many drivers print information about the hardware they find
at startup time at this level.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">KERN_DEBUG</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-4-ITERM-4713"></a>
<a name="chp-4-ITERM-4714"></a>Used
for debugging messages.</p>
</dd>
</dl>

<p class="docText">Each string (in the macro expansion) represents an integer in angle
brackets. Integers range from 0 to 7, with smaller values
representing higher priorities.</p>

<p class="docText"><a name="chp-4-ITERM-4715"></a>A
<span class="docEmphasis">printk</span> statement with no specified priority
defaults to <tt>DEFAULT_MESSAGE_LOGLEVEL</tt>, specified in
<i>kernel/printk.c</i> as an integer. In the 2.6.10
kernel, <tt>DEFAULT_MESSAGE_LOGLEVEL</tt> is
<tt>KERN_WARNING</tt>, but that has been known to change in
the past.</p>

<p class="docText"><a name="chp-4-ITERM-4716"></a>
<a name="chp-4-ITERM-4717"></a>Based
on the loglevel, the kernel may print the message to the current
console, be it a text-mode terminal, a serial port, or a parallel
printer. If the priority is less than the integer variable
<tt>console_loglevel</tt>, the message is delivered to the
console one line at a time (nothing is sent unless a trailing newline
is provided). If both <span class="docEmphasis">klogd</span> and
<span class="docEmphasis">syslogd</span> are running on the system, kernel
messages are appended to <i>/var/log/messages</i> (or
otherwise treated depending on your <span class="docEmphasis">syslogd</span>
configuration), independent of <tt>console_loglevel</tt>.
If <span class="docEmphasis">klogd</span> is not running, the message
won't reach user space unless you read
<i>/proc/kmsg</i> (which is often most easily done with
the <span class="docEmphasis">dmesg</span><a name="chp-4-ITERM-4718"></a>
<a name="chp-4-ITERM-4719"></a>
command). When using <span class="docEmphasis">klogd</span>, you should remember
that it doesn't save consecutive identical lines; it
only saves the first such line and, at a later time, the number of
repetitions it received.</p>

<p class="docText"><a name="chp-4-ITERM-4720"></a><a name="chp-4-ITERM-4721"></a>
<a name="chp-4-ITERM-4722"></a><a name="chp-4-ITERM-4723"></a>
<a name="chp-4-ITERM-4724"></a>The
variable <tt>console_loglevel</tt> is initialized to
<tt>DEFAULT_CONSOLE_LOGLEVEL</tt> and can be modified
through the <span class="docEmphasis">sys_syslog</span> system call. One way to
change it is by specifying the <span class="docEmphasis">-c</span> switch when
invoking <span class="docEmphasis">klogd</span>, as specified in the
<span class="docEmphasis">klogd</span> manpage. Note that to change the current
value, you must first kill <span class="docEmphasis">klogd</span> and then
restart it with the <span class="docEmphasis">-c</span> option. Alternatively,
you can write a program to change the console loglevel.
You'll find a version of such a program in
<I>misc-progs/setlevel.c</i> in the source files
provided on O'Reilly's FTP site.
The new level is specified as an integer value between 1 and 8,
inclusive. If it is set to <tt>1</tt>, only messages of
level 0 (<tt>KERN_EMERG</tt>) reach the console; if it is
set to <tt>8</tt>, all messages, including debugging ones,
are displayed.</P>

<p class="docText"><a name="chp-4-ITERM-4725"></a>It is also possible to
read and modify the console loglevel using the text file
<I>/proc/sys/kernel/printk</i>. The file hosts four
integer values: the current loglevel, the default level for messages
that lack an explicit loglevel, the minimum allowed loglevel, and the
boot-time default loglevel. Writing a single value to this file
changes the current loglevel to that value; thus, for example, you
can cause all kernel messages to appear at the console by simply
entering:</p>

<pre> # <b>echo 8 &gt; /proc/sys/kernel/printk</b></pre><BR>


<p class="docText">It should now be apparent why the <i>hello.c</I> sample
had the <tt>KERN_ALERT;</tt> markers; they are there to
make sure that the messages appear on the console.</P>


<a name="chp-4-sect-2.2"></a>
<H4 class="docSection2Title">4.2.2. Redirecting Console Messages</h4>

<p class="docText"><a name="chp-4-ITERM-4726"></a>
<a name="chp-4-ITERM-4727"></a>
<a name="chp-4-ITERM-4728"></a><a name="chp-4-ITERM-4729"></a><a name="chp-4-ITERM-4730"></a><a name="chp-4-ITERM-4731"></a>Linux allows for some flexibility in
console logging policies by letting you send messages to a specific
virtual console (if your console lives on the text screen). By
default, the "console" is the
current virtual terminal. To select a different virtual terminal to
receive messages, you can issue <tt>ioctl(TIOCLINUX)</tt>
on any console device. The following program,
<span class="docEmphasis">setconsole</span><a name="chp-4-ITERM-4732"></a>
<a name="chp-4-ITERM-4733"></a>,
can be used to choose which console receives kernel messages; it must
be run by the superuser and is available in the
<i>misc-progs</i><a name="chp-4-ITERM-4734"></a>
<a name="chp-4-ITERM-4735"></a> directory.</p>

<p class="docText">The following is the program in its entirety. You should invoke it
with a single argument specifying the number of the console that is
to receive messages.</P>

<pre>int main(int argc, char **argv)
{
    char bytes[2] = {11,0}; /* 11 is the TIOCLINUX cmd number */

    if (argc=  =2) bytes[1] = atoi(argv[1]); /* the chosen console */
    else {
        fprintf(stderr, "%s: need a single arg\n",argv[0]); exit(1);
    }
    if (ioctl(STDIN_FILENO, TIOCLINUX, bytes)&lt;0) {    /* use stdin */
        fprintf(stderr,"%s: ioctl(stdin, TIOCLINUX): %s\n",
                argv[0], strerror(errno));
        exit(1);
    }
    exit(0);
}</pre><BR>


<p class="docText"><span class="docEmphasis">setconsole</span> uses the special
<span class="docEmphasis">ioctl</span> command <tt>TIOCLINUX</tt>,
which implements Linux-specific functions. To use
<tt>TIOCLINUX</tt>, you pass it an argument that is a
pointer to a byte array. The first byte of the array is a number that
specifies the requested subcommand, and the following bytes are
subcommand specific. In <span class="docEmphasis">setconsole</span>, subcommand
11 is used, and the next byte (stored in <tt>bytes[1]</tt>)
identifies the virtual console. The complete description of
<tt>TIOCLINUX</tt> can be found in
<I>drivers/char/tty_io.c</i>, in the kernel sources.</P>


<a name="chp-4-sect-2.3"></a>
<H4 class="docSection2Title">4.2.3. How Messages Get Logged</h4>

<p class="docText"><a name="chp-4-ITERM-4736"></a><a name="chp-4-ITERM-4737"></a><a name="chp-4-ITERM-4738"></a>
<a name="chp-4-ITERM-4739"></a><a name="chp-4-ITERM-4740"></a><a name="chp-4-ITERM-4741"></a>
<a name="chp-4-ITERM-4742"></a><a name="chp-4-ITERM-4743"></a>
<a name="chp-4-ITERM-4744"></a><a name="chp-4-ITERM-4745"></a><a name="chp-4-ITERM-4746"></a><a name="chp-4-ITERM-4747"></a><a name="chp-4-ITERM-4748"></a>
<a name="chp-4-ITERM-4749"></a>The
<a name="chp-4-ITERM-4750"></a><span class="docEmphasis">printk</span> function
writes messages into a circular buffer that is <tt>_
_LOG_BUF_LEN</tt> bytes long: a value from 4 KB to 1 MB chosen
while configuring the kernel. The function then wakes any process
that is waiting for messages, that is, any process that is sleeping
in the <span class="docEmphasis">syslog</span> system call or that is reading
<i>/proc/kmsg</i>. These two interfaces to the logging
engine are almost equivalent, but note that reading from
<i>/proc/kmsg</I> consumes the data from the log
buffer, whereas the <span class="docEmphasis">syslog</span> system call can
optionally return log data while leaving it for other processes as
well. In general, reading the <i>/proc</i> file is
easier and is the default behavior for <span class="docEmphasis">klogd</span>.
The <span class="docEmphasis">dmesg</span> command can be used to look at the
content of the buffer without flushing it; actually, the command
returns to <span class="docEmphasis">stdout</span> the whole content of the
buffer, whether or not it has already been read.</P>

<p class="docText">If you happen to read the kernel messages by hand, after stopping
<span class="docEmphasis">klogd</span>, you'll find that the
<i>/proc</i> file looks like a FIFO, in that the reader
blocks, waiting for more data. Obviously, you can't
read messages this way if <span class="docEmphasis">klogd</span> or another
process is already reading the same data, because
you'll contend for it.</P>

<p class="docText">If the circular buffer fills up, <span class="docEmphasis">printk</span> wraps
around and starts adding new data to the beginning of the buffer,
overwriting the oldest data. Therefore, the logging process loses the
oldest data. This problem is negligible compared with the advantages
of using such a circular buffer. For example, a circular buffer
allows the system to run even without a logging process, while
minimizing memory waste by overwriting old data should nobody read
it. Another feature of the Linux approach to messaging is that
<span class="docEmphasis">printk</span> can be invoked from anywhere, even from
an interrupt handler, with no limit on how much data can be printed.
The only disadvantage is the possibility of losing some data.</p>

<p class="docText"><a name="chp-4-ITERM-4751"></a><a name="chp-4-ITERM-4752"></a>
<a name="chp-4-ITERM-4753"></a><a name="chp-4-ITERM-4754"></a>If the <span class="docEmphasis">klogd</span> process
is running, it retrieves kernel messages and dispatches them to
<span class="docEmphasis">syslogd</span>, which in turn checks
<I>/etc/syslog.conf</i> to find out how to deal with
them. <span class="docEmphasis">syslogd</span> differentiates between messages
according to a facility and a priority; allowable values for both the
facility and the priority are defined in
<i>&lt;sys/syslog.h&gt;</i>. Kernel messages are logged
by the <tt>LOG_KERN</tt> facility at a priority
corresponding to the one used in <span class="docEmphasis">printk</span> (for
example, <tt>LOG_ERR</tt> is used for
<tt>KERN_ERR</tt> messages). If <span class="docEmphasis">klogd</span>
isn't running, data remains in the circular buffer
until someone reads it or the buffer overflows.</p>

<p class="docText">If you want to avoid clobbering your system log with the monitoring
messages from your driver, you can either specify the
<span class="docEmphasis">-f</span> (file) option to <span class="docEmphasis">klogd</span>
to instruct it to save messages to a specific file, or customize
<i>/etc/syslog.conf</i> to suit your needs. Yet another
possibility is to take the brute-force approach: kill
<span class="docEmphasis">klogd</span> and verbosely print messages on an unused
virtual terminal,<sup class="docFootnote"><a class="docLink" href="chp-4-sect-2.shtml#chp-4-FNOTE-1">[1]</a></sup> or issue the command <span class="docEmphasis">cat
/proc/kmsg</span> from an unused <span class="docEmphasis">xterm</span>.</p><blockquote><p class="docFootnote"><sup><a name="chp-4-FNOTE-1">[1]</a></sup> For example, use <span class="docEmphasis">setlevel
8; setconsole 10</span> to set up terminal 10 to display
messages.</p></blockquote>


<a name="chp-4-sect-2.4"></a>
<h4 class="docSection2Title">4.2.4. Turning the Messages On and Off</h4>

<p class="docText"><a name="chp-4-ITERM-4755"></a>
<a name="chp-4-ITERM-4756"></a>
<a name="chp-4-ITERM-4757"></a><a name="chp-4-ITERM-4758"></a><a name="chp-4-ITERM-4759"></a><a name="chp-4-ITERM-4760"></a>
<a name="chp-4-ITERM-4761"></a>During the early stages
of driver development, <span class="docEmphasis">printk</span> can help
considerably in debugging and testing new code. When you officially
release the driver, on the other hand, you should remove, or at least
disable, such print statements. Unfortunately,
you're likely to find that as soon as you think you
no longer need the messages and remove them, you implement a new
feature in the driver (or somebody finds a bug), and you want to turn
at least one of the messages back on. There are several ways to solve
both issues, to globally enable or disable your debug messages and to
turn individual messages on or off.</p>

<p class="docText">Here we show one way to code <span class="docEmphasis">printk</span> calls so you
can turn them on and off individually or globally; the technique
depends on defining a macro that resolves to a
<span class="docEmphasis">printk</span> (or <span class="docEmphasis">printf</span> ) call
when you want it to:</p>

<ul><LI><p class="docList">Each print statement can be enabled or disabled by removing or adding
a single letter to the macro's name.</p></LI><LI><p class="docList">All the messages can be disabled at once by changing the value of the
<tt>CFLAGS</tt> variable before compiling.</p></li><li><p class="docList">The same print statement can be used in kernel code and user-level
code, so that the driver and test programs can be managed in the same
way with regard to extra messages.</P></li></UL>
<p class="docText"><a name="chp-4-ITERM-4762"></a>The following code fragment
implements these features and comes directly from the header
<I>scull.h</I>:</p>

<pre>#undef PDEBUG             /* undef it, just in case */
#ifdef SCULL_DEBUG
#  ifdef _ _KERNEL_ _
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scull: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */</pre><br>


<p class="docText"><a name="chp-4-ITERM-4763"></a>
<a name="chp-4-ITERM-4764"></a>The
symbol <tt>PDEBUG</tt> is defined or undefined, depending
on whether <tt>SCULL_DEBUG</tt> is defined, and displays
information in whatever manner is appropriate to the environment
where the code is running: it uses the kernel call
<span class="docEmphasis">printk</span> when it's in the kernel
and the <span class="docEmphasis">libc</span> call <span class="docEmphasis">fprintf</span>
to the standard error when run in user space. The
<tt>PDEBUGG</tt> symbol, on the other hand, does nothing;
it can be used to easily "comment"
print statements without removing them entirely.</p>

<p class="docText">To simplify the process further, add the following lines to your
makefile:</p>

<pre># Comment/uncomment the following line to disable/enable debugging
DEBUG = y

# Add your debugging flag (or not) to CFLAGS
ifeq ($(DEBUG),y)
  DEBFLAGS = -O -g -DSCULL_DEBUG # "-O" is needed to expand inlines
else
  DEBFLAGS = -O2
endif

CFLAGS += $(DEBFLAGS)</pre><BR>


<p class="docText">The macros shown in this section depend on a <span class="docEmphasis">gcc</span>
extension to the ANSI C preprocessor that supports macros with a
variable number of arguments. This <span class="docEmphasis">gcc</span>
dependency shouldn't be a problem, because the
kernel proper depends heavily on <span class="docEmphasis">gcc</span> features
anyway. In addition, the
<a name="chp-4-ITERM-4765"></a>makefile depends on
GNU's version of <span class="docEmphasis">make</span> ; once
again, the kernel already depends on GNU <span class="docEmphasis">make</span>,
so this dependency is not a problem.</P>

<p class="docText"><a name="chp-4-ITERM-4766"></a>
<a name="chp-4-ITERM-4767"></a>
<a name="chp-4-ITERM-4768"></a><a name="chp-4-ITERM-4769"></a>If
you're familiar with the C preprocessor, you can
expand on the given definitions to implement the concept of a
"debug level," defining different
levels and assigning an integer (or bit mask) value to each level to
determine how verbose it should be.</P>

<p class="docText">But every driver has its own features and monitoring needs. The art
of good programming is in choosing the best trade-off between
flexibility and efficiency, and we can't tell what
is the best for you. Remember that preprocessor conditionals (as well
as constant expressions in the code) are executed at compile time, so
you must recompile to turn messages on or off. A possible alternative
is to use C conditionals, which are executed at runtime and,
therefore, permit you to turn messaging on and off during program
execution. This is a nice feature, but it requires additional
processing every time the code is executed, which can affect
performance even when the messages are disabled. Sometimes this
performance hit is unacceptable.</p>

<p class="docText"><a name="chp-4-ITERM-4770"></a><a name="chp-4-ITERM-4771"></a>The macros shown
in this section have proven themselves useful in a number of
situations, with the only disadvantage being the requirement to
recompile a module after any changes to its messages.</P>


<a name="chp-4-sect-2.5"></a>
<H4 class="docSection2Title">4.2.5. Rate Limiting</h4>

<p class="docText">If you are not careful, you<a name="chp-4-ITERM-4772"></a> can<a name="chp-4-ITERM-4773"></a>
<a name="chp-4-ITERM-4774"></a> find yourself generating
thousands of messages with <span class="docEmphasis">printk</span>, overwhelming
the console and, possibly, overflowing the system log file. When
using a slow console device (e.g., a serial port), an excessive
message rate can also slow down the system or just make it
unresponsive. It can be very hard to get a handle on what is wrong
with a system when the console is spewing out data nonstop.
Therefore, you should be very careful about what you print,
especially in production versions of drivers and especially once
initialization is complete. In general, production code should never
print anything during normal operation; printed output should be an
indication of an exceptional situation requiring attention.</p>

<p class="docText">On the other hand, you may want to emit a log message if a device you
are driving stops working. But you should be careful not to overdo
things. An unintelligent process that continues forever in the face
of failures can generate thousands of retries per second; if your
driver prints a "my device is
broken" message every time, it could create vast
amounts of output and possibly hog the CPU if the console device is
slow—no interrupts can be used to driver the console, even if
it is a serial port or a line printer.</p>

<p class="docText">In many cases, the best behavior is to set a flag saying,
"I have already complained about
this," and not print any further messages once the
flag gets set. In others, though, there are reasons to emit an
occasional "the device is still
broken" notice. The kernel has provided a function
that can be helpful in such cases:</p>

<a name="chp-4-ITERM-4775"></a><a name="chp-4-ITERM-4776"></a><pre>int printk_ratelimit(void);</pre><BR>


<p class="docText">This function should be called before you consider printing a message
that could be repeated often. If the function returns a nonzero
value, go ahead and print your message, otherwise skip it. Thus,
typical calls look like this:</p>

<pre>if (printk_ratelimit(  ))
    printk(KERN_NOTICE "The printer is still on fire\n");</pre><br>


<p class="docText"><span class="docEmphasis">printk_ratelimit</span> works by tracking how many
messages are sent to the console. When the level of output exceeds a
threshold, <span class="docEmphasis">printk_ratelimit</span> starts returning
<tt>0</tt> and causing messages to be dropped.</P>

<p class="docText">The behavior of <span class="docEmphasis">printk_ratelimit</span> can be
customized by modifying
<i>/proc/sys/kernel/printk_ratelimit</i> (the number of
seconds to wait before re-enabling messages) and are
<I>/proc/sys/kernel/printk_ratelimit_burst</i> (the
number of messages accepted before rate-limiting).</P>


<a name="chp-4-sect-2.6"></a>
<h4 class="docSection2Title">4.2.6. Printing Device Numbers</h4>

<p class="docText">Occasionally, when printing a message from a driver, you will want to
print the device number associated
withp<a name="chp-4-ITERM-4777"></a>
<a name="chp-4-ITERM-4778"></a>
<a name="chp-4-ITERM-4779"></a> the hardware of interest. It is
not particularly hard to print the major and minor numbers, but, in
the interest of consistency, the kernel provides a couple of utility
macros (defined in <i>&lt;linux/kdev_t.h&gt;</i>) for
this purpose:</p>

<pre>int print_dev_t(char *buffer, dev_t dev);
char *format_dev_t(char *buffer, dev_t dev);</pre><br>


<p class="docText">Both macros encode the device number into the given
<tt>buffer</tt>; the only difference is that
<span class="docEmphasis">print_dev_t</span> returns the number of characters
printed, while <span class="docEmphasis">format_dev_t</span> returns
<tt>buffer</tt>; therefore, it can be used as a parameter
to a <span class="docEmphasis">printk</span> call directly, although one must
remember that <span class="docEmphasis">printk</span> doesn't
flush until a trailing newline is provided. The buffer should be
large enough to hold a device number; given that 64-bit device
numbers are a distinct possibility in <a name="chp-4-ITERM-4780"></a> <a name="chp-4-ITERM-4781"></a>future <a name="chp-4-ITERM-4782"></a> <a name="chp-4-ITERM-4783"></a> <a name="chp-4-ITERM-4784"></a>kernel releases, the buffer should
probably be at least 20 bytes long.</p>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-4-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-4-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
