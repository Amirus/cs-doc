<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>3.2. Major and Minor Numbers</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-3-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-3-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-3-sect-2"></a>
<a name="chp-3-ITERM-4347"></a><H3 class="docSection1Title">3.2. Major and Minor Numbers</H3>

<p class="docText"><a name="chp-3-ITERM-4348"></a><a name="chp-3-ITERM-4349"></a><a name="chp-3-ITERM-4350"></a>
<a name="chp-3-ITERM-4351"></a><a name="chp-3-ITERM-4352"></a><a name="chp-3-ITERM-4353"></a>Char <a name="chp-3-ITERM-4354"></a>devices are accessed
<a name="chp-3-ITERM-4355"></a>through <a name="chp-3-ITERM-4356"></a> <a name="chp-3-ITERM-4357"></a> <a name="chp-3-ITERM-4358"></a> <a name="chp-3-ITERM-4359"></a> <a name="chp-3-ITERM-4360"></a>
<a name="chp-3-ITERM-4361"></a>names in the filesystem. Those names are
called special files or device files or simply nodes of the
filesystem tree; they are conventionally located in the
<i>/dev</i><a name="chp-3-ITERM-4362"></a>
<a name="chp-3-ITERM-4363"></a> directory. Special files
for char drivers are identified by a
"c" in the first column of the
output of <span class="docEmphasis">ls -l</span>. Block devices appear in
<i>/dev</i> as well, but they are identified by a
"b." The focus of this chapter is
on char devices, but much of the following information applies to
block devices as well.</P>

<p class="docText"><a name="chp-3-ITERM-4364"></a>If you
issue the <span class="docEmphasis">ls -l</span> command, you'll
see two numbers (separated by a comma) in the device file entries
before the date of the last modification, where the file length
normally appears. These numbers are the major and minor device number
for the particular device. The following listing shows a few devices
as they appear on a typical system. Their major numbers are 1, 4, 7,
and 10, while the minors are 1, 3, 5, 64, 65, and 129.</p>

<pre> crw-rw-rw-    1 root     root       1,   3 Apr 11  2002 null
 crw-------    1 root     root      10,   1 Apr 11  2002 psaux
 crw-------    1 root     root       4,   1 Oct 28 03:04 tty1
 crw-rw-rw-    1 root     tty        4,  64 Apr 11  2002 ttys0
 crw-rw----    1 root     uucp       4,  65 Apr 11  2002 ttyS1
 crw--w----    1 vcsa     tty        7,   1 Apr 11  2002 vcs1
 crw--w----    1 vcsa     tty        7, 129 Apr 11  2002 vcsa1
 crw-rw-rw-    1 root     root       1,   5 Apr 11  2002 zero</pre><br>


<p class="docText">Traditionally, the major number identifies the driver associated with
the device. For example, <I>/dev/null</i> and
<i>/dev/zero</I> are both managed by driver 1, whereas
virtual consoles and serial terminals are managed by driver 4;
similarly, both <i>vcs1</I> and
<i>vcsa1</i> devices are managed by driver 7. Modern
Linux kernels allow multiple drivers to share major numbers, but most
devices that you will see are still organized on the
one-major-one-driver principle.</p>

<p class="docText"><a name="chp-3-ITERM-4365"></a><a name="chp-3-ITERM-4366"></a>The minor number is used by the
kernel to determine exactly which device is being referred to.
Depending on how your driver is written (as we will see below), you
can either get a direct pointer to your device from the kernel, or
you can use the minor number yourself as an index into a local array
of devices. Either way, the kernel itself knows almost nothing about
minor numbers beyond the fact that they refer to devices implemented
by your driver.</p>

<a name="chp-3-sect-2.1"></a>
<h4 class="docSection2Title">3.2.1. The Internal Representation of Device Numbers</h4>

<p class="docText">Within the kernel, the <tt>dev_t</tt> type (defined in
<i>&lt;linux/types.h&gt;</i>)
is<a name="chp-3-ITERM-4367"></a> used to hold device numbersâ€”both
the major and<a name="chp-3-ITERM-4368"></a>
<a name="chp-3-ITERM-4369"></a> minor parts. As of
Version 2.6.0 of the kernel, <tt>dev_t</tt> is a 32-bit
quantity with 12 bits set aside for the
<a name="chp-3-ITERM-4370"></a>major number and 20 for the
minor number. Your code should, of course, never make any assumptions
about the internal organization of device numbers; it should,
instead, make use of a set of
<a name="chp-3-ITERM-4371"></a>macros found
in <i>&lt;linux/kdev_t.h&gt;</i>. To obtain the major
or minor parts of a <tt>dev_t</tt>, use:</p>

<pre>MAJOR(dev_t dev);
MINOR(dev_t dev);</pre><br>


<p class="docText">If, instead, you have the major and minor numbers and need to turn
them into a <tt>dev_t</tt>, use:</p>

<pre>MKDEV(int major, int minor);</pre><BR>


<p class="docText">Note that the 2.6 kernel can accommodate a vast number of devices,
while previous kernel versions were limited to 255 major and 255
minor numbers. One assumes that the wider range will be sufficient
for quite some time, but the computing field is littered with
erroneous assumptions of that nature. So you should expect that the
format of <tt>dev_t</tt> could change again in the future;
if you write your drivers carefully, however, these changes will not
be a problem.</p>


<a name="chp-3-sect-2.2"></a>
<H4 class="docSection2Title">3.2.2. Allocating and Freeing Device Numbers</H4>

<p class="docText">One of the first things your
driver<a name="chp-3-ITERM-4372"></a>
<a name="chp-3-ITERM-4373"></a>
<a name="chp-3-ITERM-4374"></a>
<a name="chp-3-ITERM-4375"></a> will need to do
<a name="chp-3-ITERM-4376"></a>when setting up a char
device is to obtain one or more device numbers to work with. The
necessary function for this task is
<span class="docEmphasis">register_chrdev_region</span>, which is declared in
<i>&lt;linux/fs.h&gt;</i>:</p>

<pre>int register_chrdev_region(dev_t first, unsigned int count, 
                           char *name);</pre><BR>


<p class="docText">Here, <tt>first</tt> is the beginning
<a name="chp-3-ITERM-4377"></a>device number of the range you would
like to allocate. The minor number portion of
<tt>first</tt> is often <tt>0</tt>, but there is
no requirement to that effect. <tt>count</tt> is the total
number of contiguous device numbers you are requesting. Note that, if
<tt>count</tt> is large, the range you request could spill
over to the next major number; but everything will still work
properly as long as the number range you request is available.
Finally, <tt>name</tt> is the name of the device that
should be associated with this number range; it will appear in
<i>/proc/devices</I> and sysfs.</P>

<p class="docText">As with most kernel functions, the return value from
<span class="docEmphasis">register_chrdev_region</span> will be
<tt>0</tt> if the allocation was successfully performed. In
case of error, a negative error code will be returned, and you will
not have access to the requested region.</P>

<p class="docText"><span class="docEmphasis">register_chrdev_region</span> works well if you know
ahead of time exactly which device numbers you want. Often, however,
you will not know which major numbers your device will use; there is
a constant effort within the Linux kernel development community to
move over to the use of dynamicly-allocated device numbers. The
kernel will happily allocate a major number for you on the fly, but
you must request this allocation by using a different function:</p>

<pre>int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, 
                        unsigned int count, char *name);</pre><br>


<p class="docText">With this function, <tt>dev</tt> is an output-only
parameter that will, on successful completion, hold the first number
in your allocated range. <tt>firstminor</tt> should be the
requested first minor number to use; it is usually
<tt>0</tt>. The <tt>count</tt> and
<tt>name</tt> parameters work like those given to
<span class="docEmphasis">request_chrdev_region</span>.</p>

<p class="docText">Regardless of how you allocate your device numbers, you should free
them when they are no longer in use. Device numbers are freed with:</p>

<pre>void unregister_chrdev_region(dev_t first, unsigned int count);</pre><BR>


<p class="docText">The usual place to call <span class="docEmphasis">unregister_chrdev_region</span>
would be in your module's cleanup function.</P>

<p class="docText">The above functions allocate device numbers for your
driver's use, but they do not tell the kernel
anything about what you will actually do with those numbers. Before a
user-space program can access one of those device numbers, your
driver needs to connect them to its internal functions that implement
the device's operations. We will describe how this
connection is accomplished shortly, but there are a couple of
necessary digressions to take care of first.</P>


<a name="chp-3-sect-2.3"></a>
<h4 class="docSection2Title">3.2.3. Dynamic Allocation of Major Numbers</H4>

<p class="docText">Some major device numbers are statically <a name="chp-3-ITERM-4378"></a>
<a name="chp-3-ITERM-4379"></a>
<a name="chp-3-ITERM-4380"></a>assigned to the most common devices. A
list of those devices can be found in
<I>Documentation/devices.txt</i> within the kernel
source tree. The chances of a <a name="chp-3-ITERM-4381"></a>static number having already been
assigned for the use of your new driver are small, however, and new
numbers are not being assigned. So, as a driver writer, you have a
choice: you can simply pick a number that appears to be unused, or
you can allocate major numbers in a dynamic manner. Picking a number
may work as long as the only user of your driver is you; once your
driver is more widely deployed, a randomly picked major number will
lead to conflicts and trouble.</p>

<p class="docText">Thus, for new drivers, we strongly
<a name="chp-3-ITERM-4382"></a>suggest that you use dynamic
allocation to obtain your major device number, rather than choosing a
number randomly from the ones that are currently free. In other
words, your drivers should almost certainly be using
<span class="docEmphasis">alloc_chrdev_region</span> rather than
<span class="docEmphasis">register_chrdev_region</span>.</p>

<p class="docText"><a name="chp-3-ITERM-4383"></a><a name="chp-3-ITERM-4384"></a>The disadvantage of dynamic assignment is
that you can't create the device nodes in advance,
because the major number assigned to your module will vary. For
normal use of the driver, this is hardly a problem, because once the
number has been assigned, you can read it from
<i>/proc/devices</I>.<sup class="docFootnote"><a class="docLink" href="chp-3-sect-2.shtml#chp-3-FNOTE-1">[1]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="chp-3-FNOTE-1">[1]</a></sup> Even better
device information can usually be obtained from sysfs, generally
mounted on <i>/sys</I> on 2.6-based systems. Getting
<span class="docEmphasis">scull</span> to export information via sysfs is beyond
the scope of this chapter, however; we'll return to
this topic in <a class="docLink" href="chp-14.shtml#chp-14">Chapter 14</a>.</p></blockquote>

<p class="docText"><a name="chp-3-ITERM-4385"></a>To load a driver using a
dynamic<a name="chp-3-ITERM-4386"></a>
<a name="chp-3-ITERM-4387"></a>
major number, therefore, the invocation of
<span class="docEmphasis">insmod</span> can be replaced by a simple script that,
after calling <span class="docEmphasis">insmod</span>, reads
<i>/proc/devices</I> in order to create the special
file(s).</p>

<p class="docText">A typical <I>/proc/devices</i> file looks like the
following:</p>

<pre>Character devices:
 1 mem
 2 pty
 3 ttyp
 4 ttyS
 6 lp
 7 vcs
 10 misc
 13 input
 14 sound
 21 sg
180 usb

Block devices:
 2 fd
 8 sd
 11 sr
 65 sd
 66 sd</pre><br>


<p class="docText"><a name="chp-3-ITERM-4388"></a>The script to load a
module that<a name="chp-3-ITERM-4389"></a>
<a name="chp-3-ITERM-4390"></a>
<a name="chp-3-ITERM-4391"></a> has been assigned a dynamic number
can, therefore, be written using a tool such as
<span class="docEmphasis">awk</span> to retrieve information from
<i>/proc/devices</i> in order to create the files in
<i>/dev</i>.</p>

<p class="docText">The following script, <span class="docEmphasis">scull_load</span>, is part of the
<span class="docEmphasis">scull</span> distribution. The user of a driver that is
distributed in the form of a module can invoke such a script from the
system's <i>rc.local</i> file or call
it manually whenever the module is needed.</p>

<pre>#!/bin/sh
module="scull"
device="scull"
mode="664"

# invoke insmod with all arguments we got
# and use a pathname, as newer modutils don't look in . by default
/sbin/insmod ./$module.ko $* || exit 1

# remove stale nodes
rm -f /dev/${device}[0-3]

major=$(awk "\\$2=  =\"$module\" {print \\$1}" /proc/devices)

mknod /dev/${device}0 c $major 0
mknod /dev/${device}1 c $major 1
mknod /dev/${device}2 c $major 2
mknod /dev/${device}3 c $major 3

# give appropriate group/permissions, and change the group.
# Not all distributions have staff, some have "wheel" instead.
group="staff"
grep -q '^staff:' /etc/group || group="wheel"

chgrp $group /dev/${device}[0-3]
chmod $mode  /dev/${device}[0-3]</pre><br>


<p class="docText">The script can be adapted for another driver by redefining the
variables and adjusting the <span class="docEmphasis">mknod</span> lines. The
script just shown creates four devices because four is the default in
the <span class="docEmphasis">scull</span> sources.</p>

<p class="docText"><a name="chp-3-ITERM-4392"></a><a name="chp-3-ITERM-4393"></a><a name="chp-3-ITERM-4394"></a>The last few lines
of the script may seem obscure: why change the group and mode of a
device? The reason is that the script must be run by the superuser,
so newly created special files are owned by root. The permission bits
default so that only root has write access, while anyone can get read
access. Normally, a device node requires a different access policy,
so in some way or another access rights must be changed. The default
in our script is to give access to a group of users, but your needs
may vary. In <a class="docLink" href="chp-6-sect-6.shtml#chp-6-sect-6">Section 6.6</a> in <a class="docLink" href="chp-3.shtml#chp-3">Chapter 3</a>, the code for
<span class="docEmphasis">sculluid</span> demonstrates how the driver can enforce
its own kind of authorization for device access.</P>

<p class="docText">A <span class="docEmphasis">scull_unload</span> script is also available to clean
up the <i>/dev</I> directory and remove the module.</P>

<p class="docText"><a name="chp-3-ITERM-4395"></a><a name="chp-3-ITERM-4396"></a>As an alternative to using a pair
of scripts for loading and unloading, you could write an init script,
ready to be placed in the directory your distribution uses for these
scripts.<sup class="docFootnote"><a class="docLink" href="chp-3-sect-2.shtml#chp-3-FNOTE-2">[2]</a></sup> As part of the
<span class="docEmphasis">scull</span> source, we offer a fairly complete and
configurable example of an init script, called
<i>scull.init</i>; it accepts the conventional
argumentsâ€”<tt>start</tt>, <tt>stop</tt>,
and <tt>restart</tt>â€”and performs the role of both
<span class="docEmphasis">scull_load</span> and
<span class="docEmphasis">scull_unload</span>.</p><blockquote><p class="docFootnote"><sup><a name="chp-3-FNOTE-2">[2]</a></sup> The Linux Standard Base specifies that init
scripts should be placed in <I>/etc/init.d</i>, but
some distributions still place them elsewhere. In addition, if your
script is to be run at boot time, you need to make a link to it from
the appropriate run-level directory (i.e.,
<I>.../rc3.d</I>).</P></blockquote>

<p class="docText"><a name="chp-3-ITERM-4397"></a><a name="chp-3-ITERM-4398"></a>If repeatedly creating and destroying
<i>/dev</i> nodes sounds like overkill, there is a
useful workaround. If you are loading and unloading only a single
driver, you can just use <span class="docEmphasis">rmmod</span> and
<span class="docEmphasis">insmod</span> after the first time you create the
special files with your script: dynamic numbers are not
randomized,<sup class="docFootnote"><a class="docLink" href="chp-3-sect-2.shtml#chp-3-FNOTE-3">[3]</a></sup> and
you can count on the same number being chosen each time if you
don't load any other (dynamic) modules. Avoiding
lengthy scripts is useful during development. But this trick,
clearly, doesn't scale to more than one driver at a
time.</p><blockquote><p class="docFootnote"><sup><a name="chp-3-FNOTE-3">[3]</a></sup> Though certain kernel developers have
threatened to do exactly that in the future.</p></blockquote>

<p class="docText">The best way to assign major numbers, in our opinion, is by
defaulting to dynamic allocation while leaving yourself the option of
specifying the major number at load time, or even at compile time.
The <span class="docEmphasis">scull</span> implementation works in this way; it
uses a global variable, <tt>scull_major</tt>, to hold the
chosen number (there is also a <tt>scull_minor</tt> for the
minor number). The variable is initialized to
<tt>SCULL_MAJOR</tt>, defined in
<I>scull.h</I>. The default value of
<tt>SCULL_MAJOR</tt> in the distributed source is
<tt>0</tt>, which means "use dynamic
assignment." The user can accept the default or
choose a particular major number, either by modifying the macro
before compiling or by specifying a value for
<tt>scull_major</tt> on the <span class="docEmphasis">insmod</span>
command line. Finally, by using the <span class="docEmphasis">scull_load</span>
script, the user can pass arguments to <span class="docEmphasis">insmod</span> on
<I>scull_load</i> 's command
line.<sup class="docFootnote"><a class="docLink" href="chp-3-sect-2.shtml#chp-3-FNOTE-4">[4]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="chp-3-FNOTE-4">[4]</a></sup> The init script <span class="docEmphasis">scull.init</span>
doesn't accept driver options on the command line,
but it supports a configuration file, because it's
designed for automatic use at boot and shutdown time.</P></blockquote>

<p class="docText">Here's the code we use in <span class="docEmphasis">scull</span>
's source to get a major number:</p>

<pre>if (scull_major) {
    dev = MKDEV(scull_major, scull_minor);
    result = register_chrdev_region(dev, scull_nr_devs, "scull");
} else {
    result = alloc_chrdev_region(&amp;dev, scull_minor, scull_nr_devs,
            "scull");
    scull_major = MAJOR(dev);
}
if (result &lt; 0) {
    printk(KERN_WARNING "scull: can't get major %d\n", scull_major);
    return result;
}</pre><br>


<p class="docText">Almost all of the sample drivers used in <a name="chp-3-ITERM-4399"></a> <a name="chp-3-ITERM-4400"></a> <a name="chp-3-ITERM-4401"></a> <a name="chp-3-ITERM-4402"></a> <a name="chp-3-ITERM-4403"></a> <a name="chp-3-ITERM-4404"></a>this book use
similar code for their major number assignment.</p>



<ul></UL></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-3-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-3-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
