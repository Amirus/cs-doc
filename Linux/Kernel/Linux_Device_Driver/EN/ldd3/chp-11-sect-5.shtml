<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>11.5. Linked Lists</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-11-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-11-sect-6.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="chp-11-sect-5"></a>
<h3 class="docSection1Title">11.5. Linked Lists</h3>

<p class="docText">Operating system <a name="chp-11-ITERM-6251"></a>kernels, like many other programs, often
need to maintain lists of data structures. The Linux kernel has, at
times, been host to several linked list implementations at the same
time. To reduce the amount of duplicated code, the kernel developers
have created a standard implementation of circular, doubly linked
lists; others needing to manipulate lists are encouraged to use this
facility.</p>

<p class="docText">When working with the linked list interface, you should always bear
in mind that the list functions perform no locking. If there is a
possibility that your driver could attempt to perform concurrent
operations on the same list, it is your responsibility to implement a
locking scheme. The alternatives (corrupted list structures, data
loss, kernel panics) tend to be difficult to diagnose.</p>

<p class="docText">To use the list mechanism, your driver must include the file
<I>&lt;linux/list.h&gt;</i>. This file defines a simple
structure of type <tt>list_head</tt>:</P>

<pre>struct list_head {
    struct list_head *next, *prev;
};</pre><BR>


<p class="docText">Linked lists used in real code are almost invariably made up of some
type of structure, each one describing one entry in the list. To use
the Linux list facility in your code, you need only embed a
<tt>list_head</tt> inside the structures that make up the
list. If your driver maintains a list of things to do, say, its
declaration would look something like this:</p>

<pre>struct todo_struct {
    struct list_head list;
    int priority; /* driver specific */
    /* ... add other driver-specific fields */
};</pre><br>


<p class="docText"><a name="chp-11-ITERM-6252"></a>
<a name="chp-11-ITERM-6253"></a>The
head of the list is usually a standalone <tt>list_head</tt>
structure. <a class="docLink" href="chp-11-sect-5.shtml#chp-11-FIG-1">Figure 11-1</a> shows
how the simple <tt>struct</tt> <tt>list_head</tt>
is used to maintain a list of data structures.</p>

<a name="chp-11-FIG-1"></a><P><center>
<h5 class="docFigureTitle">Figure 11-1. The list_head data structure</H5>
<img border="0" alt="" width="480" height="280" SRC="images/0596005903/figs/ldr3_1101.gif"></center></P><BR>

<p class="docText">List heads must be initialized prior to use with the
<tt>INIT_LIST_HEAD</tt> macro. A "things
to do" list head could be declared and initialized
with:</p>

<pre>struct list_head todo_list;

INIT_LIST_HEAD(&amp;todo_list);</pre><br>


<p class="docText">Alternatively, lists can be initialized at compile time:</p>

<pre>LIST_HEAD(todo_list);</pre><br>


<p class="docText">Several functions are defined in
<I>&lt;linux/list.h&gt;</I> that work with lists:</P>

<a name="chp-11-ITERM-6254"></a><a name="chp-11-ITERM-6255"></a><a name="chp-11-ITERM-6256"></a><a name="chp-11-ITERM-6257"></a><a name="chp-11-ITERM-6258"></a><a name="chp-11-ITERM-6259"></a><a name="chp-11-ITERM-6260"></a><a name="chp-11-ITERM-6261"></a><a name="chp-11-ITERM-6262"></a><a name="chp-11-ITERM-6263"></a><a name="chp-11-ITERM-6264"></a><a name="chp-11-ITERM-6265"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_add(struct list_head *new, struct list_head *head);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-11-ITERM-6254"></a>
<a name="chp-11-ITERM-6255"></a>Adds
the <tt>new</tt> entry immediately after the list
head—normally at the beginning of the list. Therefore, it can
be used to build stacks. Note, however, that the
<tt>head</tt> need not be the nominal head of the list; if
you pass a <tt>list_head</tt> structure that happens to be
in the middle of the list somewhere, the new entry goes immediately
after it. Since Linux lists are circular, the head of the list is not
generally different from any other entry.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_add_tail(struct list_head *new, struct list_head *head);</span></span> </span></dt></P>
<dd>
<p class="docList"><a name="chp-11-ITERM-6256"></a>
<a name="chp-11-ITERM-6257"></a>Adds
a new entry just before the given list head—at the end of the
list, in other words. <span class="docEmphasis">list_add_tail</span> can, thus,
be used to build first-in first-out queues.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_del(struct list_head *entry);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_del_init(struct list_head *entry);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-11-ITERM-6258"></a>
<a name="chp-11-ITERM-6259"></a>
<a name="chp-11-ITERM-6260"></a>
<a name="chp-11-ITERM-6261"></a>The
given entry is removed from the list. If the entry might ever be
reinserted into another list, you should use
<span class="docEmphasis">list_del_init</span>, which reinitializes the linked
list pointers.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_move(struct list_head *entry, struct list_head *head);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_move_tail(struct list_head *entry, struct list_head *head);</span></span></span></dt></p>
<dd>
<p class="docList">The given <tt>entry</tt> is removed from its current list
and added to the beginning of <tt>head</tt>. To put the
entry at the end of the new list, use
<span class="docEmphasis">list_move_tail</span> instead.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_empty(struct list_head *head);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-11-ITERM-6262"></a>
<a name="chp-11-ITERM-6263"></a>Returns
a nonzero value if the given list is empty.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_splice(struct list_head *list, struct list_head *head);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-11-ITERM-6264"></a>
<a name="chp-11-ITERM-6265"></a>Joins
two lists by inserting <tt>list</tt> immediately after
<tt>head</tt>.</P>
</dd>
</dl>

<p class="docText"><a name="chp-11-ITERM-6266"></a>
<a name="chp-11-ITERM-6267"></a>The
<tt>list_head</tt> structures are good for implementing a
list of like structures, but the invoking program is usually more
interested in the larger structures that make up the list as a whole.
A macro, <span class="docEmphasis">list_entry</span>, is provided that maps a
<tt>list_head</tt> structure pointer back into a pointer to
the structure that contains it. It is invoked as follows:</P>

<pre>list_entry(struct list_head *ptr, type_of_struct, field_name);</pre><br>


<p class="docText">where <tt>ptr</tt> is a pointer to the <tt>struct
list_head</tt> being used, <tt>type_of_struct</tt> is
the type of the structure containing the <tt>ptr</tt>, and
<tt>field_name</tt> is the name of the list field within
the structure. In our <tt>todo_struct</tt> structure from
before, the list field is called simply <tt>list</tt>.
Thus, we would turn a list entry into its containing structure with a
line such as:</p>

<pre>struct todo_struct *todo_ptr =
    list_entry(listptr, struct todo_struct, list);</pre><br>


<p class="docText">The <span class="docEmphasis">list_entry</span> macro takes a little getting used
to but is not that hard to use.</P>

<p class="docText"><a name="chp-11-ITERM-6268"></a>
<a name="chp-11-ITERM-6269"></a>The traversal of linked lists is easy: one
need only follow the <tt>prev</tt> and
<tt>next</tt> pointers. As an example, suppose we want to
keep the list of <tt>todo_struct</tt> items sorted in
descending priority order. A function to add a new entry would look
something like this:</p>

<pre>void todo_add_entry(struct todo_struct *new)
{
    struct list_head *ptr;
    struct todo_struct *entry;

    for (ptr = todo_list.next; ptr != &amp;todo_list; ptr = ptr-&gt;next) {
        entry = list_entry(ptr, struct todo_struct, list);
        if (entry-&gt;priority &lt; new-&gt;priority) {
            list_add_tail(&amp;new-&gt;list, ptr);
            return;
        }
    }
    list_add_tail(&amp;new-&gt;list, &amp;todo_struct)
}</pre><BR>


<p class="docText">However, as a general rule, it is better to use one of a set of
predefined macros for creating loops that iterate through lists. The
previous loop, for example, could be coded as:</P>

<pre>void todo_add_entry(struct todo_struct *new)
{
    struct list_head *ptr;
    struct todo_struct *entry;

    list_for_each(ptr, &amp;todo_list) {
        entry = list_entry(ptr, struct todo_struct, list);
        if (entry-&gt;priority &lt; new-&gt;priority) {
            list_add_tail(&amp;new-&gt;list, ptr);
            return;
        }
    }
    list_add_tail(&amp;new-&gt;list, &amp;todo_struct)
}</pre><BR>


<p class="docText">Using the provided macros helps avoid simple programming errors; the
developers of these macros have also put some effort into ensuring
that they perform well. A few variants exist:</p>

<a name="chp-11-ITERM-6270"></a><a name="chp-11-ITERM-6271"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_for_each(struct list_head *cursor, struct list_head *list)</span></span><a name="chp-11-ITERM-6270"></a>
<a name="chp-11-ITERM-6271"></a></span></dt></p>
<dd>
<p class="docList">This macro creates a <tt>for</tt> loop that executes once
with <tt>cursor</tt> pointing at each successive entry in
the list. Be careful about changing the list while iterating through
it.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_for_each_prev(struct list_head *cursor, struct list_head *list)</span></span></span></dt></p>
<dd>
<p class="docList">This version iterates backward through the list.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_for_each_safe(struct list_head *cursor, struct list_head *next, struct</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">list_head *list)</span></span></span></dt></P>
<dd>
<p class="docList">If your loop may delete entries in the list, use this version. It
simply stores the next entry in the list in <tt>next</tt>
at the beginning of the loop, so it does not get confused if the
entry pointed to by <tt>cursor</tt> is deleted.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_for_each_entry(type *cursor, struct list_head *list, member)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">list_for_each_entry_safe(type *cursor, type *next, struct list_head *list</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">member)</span></span></span></dt></p>
<dd>
<p class="docList">These macros ease the process of dealing with a list containing a
given <tt>type</tt> of structure. Here,
<tt>cursor</tt> is a pointer to the containing structure
type, and <tt>member</tt> is the name of the
<tt>list_head</tt> structure within the containing
structure. With these macros, there is no need to put
<tt>list_entry</tt> calls inside the loop.</p>
</dd>
</dl>

<p class="docText"><a name="chp-11-ITERM-6272"></a><a name="chp-11-ITERM-6273"></a><a name="chp-11-ITERM-6274"></a>If you look inside
<i>&lt;linux/list.h&gt;</i>, you see some additional
declarations. The <tt>hlist</tt> type is a
<a name="chp-11-ITERM-6275"></a>doubly linked list with a
separate, single-pointer list head type; it is often used for
creation of hash tables and similar structures. There are also macros
for iterating through both types of lists that are intended to work
with the read-copy-update mechanism (described in <a class="docLink" href="chp-5-sect-7.shtml#chp-5-sect-7.5">Section 5.7.5</a>
in <a class="docLink" href="chp-5.shtml#chp-5">Chapter 5</a>). These primitives
are unlikely to be useful in device drivers; see the header file if
you would like more information on how <a name="chp-11-ITERM-6276"></a>they work.</p>


<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-11-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-11-sect-6.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
