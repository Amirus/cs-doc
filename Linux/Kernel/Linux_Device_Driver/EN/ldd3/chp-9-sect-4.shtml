<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>9.4. Using I/O Memory</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-9-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-9-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-9-sect-4"></a>
<h3 class="docSection1Title">9.4. Using I/O Memory</h3>

<p class="docText">Despite the popularity of I/O ports in the x86 world, the main
mechanism used to communicate with devices is through memory-mapped
registers and device memory. Both are called <span class="docEmphasis">I/O
memory</span> because the difference between registers and memory
is transparent to software.</p>

<p class="docText">I/O memory is simply a region of RAM-like locations that the device
makes available to the processor over the bus. This memory can be
used for a number of purposes, such as holding video data or Ethernet
packets, as well as implementing device registers that behave just
like I/O ports (i.e., they have side effects associated with reading
and writing them).</p>

<p class="docText">The way to access I/O memory depends on the computer architecture,
bus, and device being used, although the principles are the same
everywhere. The discussion in this chapter touches mainly on ISA and
PCI memory, while trying to convey general information as well.
Although access to PCI memory is introduced here, a thorough
discussion of PCI is deferred to <a class="docLink" href="chp-12.shtml#chp-12">Chapter 12</a>.</p>

<p class="docText"><a name="chp-9-ITERM-5970"></a> <a name="chp-9-ITERM-5971"></a><a name="chp-9-ITERM-5972"></a>
<a name="chp-9-ITERM-5973"></a>
<a name="chp-9-ITERM-5974"></a>
<a name="chp-9-ITERM-5975"></a>Depending on the computer platform
and bus being used, I/O memory may or may not be accessed through
page tables. When access passes though page tables, the kernel must
first arrange for the physical address to be visible from your
driver, and this usually means that you must call
<span class="docEmphasis">ioremap</span><a name="chp-9-ITERM-5976"></a> before doing any I/O. If no page
tables are needed, I/O memory locations look pretty much like I/O
ports, and you can just read and write to them using proper wrapper
functions.</p>

<p class="docText">Whether or not <span class="docEmphasis">ioremap</span> is required to access I/O
memory, direct use of pointers to I/O memory is discouraged. Even
though (as introduced in <a class="docLink" href="chp-9-sect-1.shtml#chp-9-sect-1">Section 9.1</a>) I/O memory is addressed like normal RAM
at hardware level, the extra care outlined in the <a class="docLink" href="chp-9-sect-1.shtml#chp-9-sect-1.1">Section 9.1.1</a> suggests avoiding normal
pointers. The wrapper functions used to access I/O memory are safe on
all platforms and are optimized away whenever straight pointer
dereferencing can perform the operation.</p>

<p class="docText">Therefore, even though dereferencing a pointer works (for now) on the
x86, failure to use the proper macros hinders the portability and
readability of the driver.</p>

<a name="chp-9-sect-4.1"></a>
<h4 class="docSection2Title">9.4.1. I/O Memory Allocation and Mapping</h4>

<p class="docText">I/O memory regions
<a name="chp-9-ITERM-5977"></a>
<a name="chp-9-ITERM-5978"></a>
<a name="chp-9-ITERM-5979"></a>
<a name="chp-9-ITERM-5980"></a>
<a name="chp-9-ITERM-5981"></a>must
be allocated prior to use. The interface for allocation of memory
regions (defined in <i>&lt;linux/ioport.h&gt;</i>) is:</P>

<pre>struct resource *request_mem_region(unsigned long start, unsigned long len,
                                    char *name);</pre><br>


<p class="docText">This function allocates a memory region of <tt>len</tt>
bytes, starting at <tt>start</tt>. If all goes well, a
non-<tt>NULL</tt> pointer is returned; otherwise the return
value is <tt>NULL</tt>. All I/O memory allocations are
listed in <I>/proc/iomem</I>.</p>

<p class="docText">Memory regions should be freed when no longer needed:</p>

<pre>void release_mem_region(unsigned long start, unsigned long len);</pre><br>


<p class="docText">There is also an old function for checking I/O memory region
availability:</P>

<pre>int check_mem_region(unsigned long start, unsigned long len);</pre><br>


<p class="docText">But, as with <span class="docEmphasis">check_region</span>, this function is
unsafe and should be avoided.</P>

<p class="docText">Allocation of I/O memory is not the only required step before that
memory may be accessed. You must also ensure that this I/O memory has
been made accessible to the kernel. Getting at I/O memory is not just
a matter of dereferencing a pointer; on many systems, I/O memory is
not directly accessible in this way at all. So a mapping must be set
up first. This is the role of the <span class="docEmphasis">ioremap</span>
function, introduced in <a class="docLink" href="chp-8-sect-4.shtml#chp-8-sect-4">Section 8.4</a> in <a class="docLink" href="chp-8.shtml#chp-8">Chapter 8</a>. The function is
designed specifically to assign virtual addresses to I/O memory
regions.</P>

<p class="docText">Once equipped with <span class="docEmphasis">ioremap</span> (and
<span class="docEmphasis">iounmap</span>), a device driver can access any I/O
memory address, whether or not it is directly mapped to virtual
address space. Remember, though, that the addresses returned from
<span class="docEmphasis">ioremap</span> should not be dereferenced directly;
instead, accessor functions provided by the kernel should be used.
Before we get into those functions, we'd better
review the <span class="docEmphasis">ioremap</span> prototypes and introduce a
few details that we passed over in the previous chapter.</P>

<p class="docText">The functions are called according to the following definition:
<a name="chp-9-ITERM-5982"></a>
<a name="chp-9-ITERM-5983"></a>
<a name="chp-9-ITERM-5984"></a><a name="chp-9-ITERM-5985"></a>
<a name="chp-9-ITERM-5986"></a></p>

<pre>#include &lt;asm/io.h&gt;
void *ioremap(unsigned long phys_addr, unsigned long size);
void *ioremap_nocache(unsigned long phys_addr, unsigned long size);
void iounmap(void * addr);</pre><br>


<p class="docText"><a name="chp-9-ITERM-5987"></a>
<a name="chp-9-ITERM-5988"></a>First
of all, you notice the new function
<span class="docEmphasis">ioremap_nocache</span>. We didn't
cover it in <a class="docLink" href="chp-8.shtml#chp-8">Chapter 8</a>, because
its meaning is definitely hardware related. Quoting from one of the
kernel headers: "It's useful if
some control registers are in such an area, and write combining or
read caching is not desirable." Actually, the
function's implementation is identical to
<span class="docEmphasis">ioremap</span> on most computer platforms: in
situations where all of I/O memory is already visible through
noncacheable addresses, there's no reason to
implement a separate, noncaching version of
<span class="docEmphasis">ioremap</span>.</p>


<a name="chp-9-sect-4.2"></a>
<h4 class="docSection2Title">9.4.2. Accessing I/O Memory</H4>

<p class="docText">On some platforms,
you<a name="chp-9-ITERM-5989"></a> may get away with using the return
value from <span class="docEmphasis">ioremap</span> as a pointer. Such use is not
portable, and, increasingly, the kernel developers have been working
to eliminate any such use. The proper way of getting at I/O memory is
via a set of functions (defined via
<I>&lt;asm/io.h&gt;</I>) provided for that purpose.</p>

<p class="docText">To read from I/O memory, use one of the following:</P>

<pre>unsigned int ioread8(void *addr);
unsigned int ioread16(void *addr);
unsigned int ioread32(void *addr);</pre><BR>


<p class="docText">Here, <tt>addr</tt> should be an address obtained from
<span class="docEmphasis">ioremap</span> (perhaps with an integer offset); the
return value is what was read from the given I/O memory.</p>

<p class="docText">There is a similar set of functions for writing to I/O memory:</p>

<pre>void iowrite8(u8 value, void *addr);
void iowrite16(u16 value, void *addr);
void iowrite32(u32 value, void *addr);</pre><br>


<p class="docText">If you must read or write a series of values to a given I/O memory
address, you can use the repeating versions of the functions:</p>

<pre>void ioread8_rep(void *addr, void *buf, unsigned long count);
void ioread16_rep(void *addr, void *buf, unsigned long count);
void ioread32_rep(void *addr, void *buf, unsigned long count);
void iowrite8_rep(void *addr, const void *buf, unsigned long count);
void iowrite16_rep(void *addr, const void *buf, unsigned long count);
void iowrite32_rep(void *addr, const void *buf, unsigned long count);</pre><BR>


<p class="docText">These functions read or write <tt>count</tt> values from
the given <tt>buf</tt> to the given
<tt>addr</tt>. Note that <tt>count</tt> is
expressed in the size of the data being written;
<span class="docEmphasis">ioread32_rep</span> reads <tt>count</tt>
32-bit values starting at <tt>buf</tt>.</p>

<p class="docText">The functions described above perform all I/O to the given
<tt>addr</tt>. If, instead, you need to operate on a block
of I/O memory, you can use one of the following:</p>

<pre>void memset_io(void *addr, u8 value, unsigned int count);
void memcpy_fromio(void *dest, void *source, unsigned int count);
void memcpy_toio(void *dest, void *source, unsigned int count);</pre><BR>


<p class="docText">These functions behave like their C library analogs.</p>

<p class="docText">If you read through the kernel source, you see many calls to an older
set of functions when I/O memory is being used. These functions still
work, but their use in new code is discouraged. Among other things,
they are less safe because they do not perform the same sort of type
checking. Nonetheless, we describe them here:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned readb(address);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned readw(address);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned readl(address);</span></span></span></dt></p>
<dd>
<p class="docList">These macros are used to retrieve 8-bit, 16-bit, and 32-bit data
values from I/O memory.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void writeb(unsigned value, address);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void writew(unsigned value, address);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void writel(unsigned value, address);</span></span></span></dt></P>
<dd>
<p class="docList">Like the previous functions, these functions (macros) are used to
write 8-bit, 16-bit, and 32-bit data items.</P>
</dd>
</dl>

<p class="docText">Some 64-bit platforms also offer <span class="docEmphasis">readq</span> and
<span class="docEmphasis">writeq</span>, for quad-word (8-byte) memory operations
on the PCI bus. The <span class="docEmphasis">quad-word</span> nomenclature is a
historical leftover from the times when all real processors had
16-bit words. Actually, the <span class="docEmphasis">L</span> naming used for
32-bit values has become incorrect too, but renaming everything would
confuse things even more.</p>


<a name="chp-9-sect-4.3"></a>
<h4 class="docSection2Title">9.4.3. Ports as I/O Memory</h4>

<p class="docText">Some hardware has an interesting feature: some versions use I/O
ports, while others use I/O memory. The registers exported to the
processor are the same in either case, but the access method is
different. As a way of making life easier for drivers dealing with
this kind of hardware, and as a way of minimizing the apparent
differences between I/O port and memory accesses, the 2.6 kernel
provides a function called <span class="docEmphasis">ioport_map</span>:</P>

<pre>void *ioport_map(unsigned long port, unsigned int count);</pre><br>


<p class="docText">This function remaps <tt>count</tt> I/O ports and makes
them appear to be I/O memory. From that point thereafter, the driver
may use <span class="docEmphasis">ioread8</span> and friends on the returned
addresses and forget that it is using I/O ports at all.</P>

<p class="docText">This mapping should be undone when it is no longer needed:</P>

<pre>void ioport_unmap(void *addr);</pre><BR>


<p class="docText">These functions make I/O ports look like memory. Do note, however,
that the I/O ports must still be allocated with
<span class="docEmphasis">request_region</span> before they can be remapped in
this way.</p>


<a name="chp-9-sect-4.4"></a>
<h4 class="docSection2Title">9.4.4. Reusing short for I/O Memory</h4>

<p class="docText"><a name="chp-9-ITERM-5990"></a>
<a name="chp-9-ITERM-5991"></a>
<a name="chp-9-ITERM-5992"></a>The <span class="docEmphasis">short</span> sample
module, introduced earlier to access I/O ports, can be used to access
I/O memory as well. To this aim, you must tell it to use I/O memory
at load time; also, you need to change the base address to make it
point to your I/O region.</p>

<p class="docText">For example, this is how we used <span class="docEmphasis">short</span> to light
the debug LEDs on a MIPS development board:</P>

<pre>mips.root# <B>./short_load use_mem=1 base=0xb7ffffc0</b>
mips.root# <B>echo -n 7 &gt; /dev/short0</b></pre><br>


<p class="docText">Use of <span class="docEmphasis">short</span> for I/O memory is the same as it is
for I/O ports.</P>

<p class="docText">The following fragment shows the loop used by
<span class="docEmphasis">short</span> in writing to a memory location:</P>

<pre>while (count--) {
    iowrite8(*ptr++, address);
    wmb(  );
}</pre><br>


<p class="docText">Note the use of a write memory barrier here. Because
<span class="docEmphasis">iowrite8</span> likely turns into a direct assignment
on many architectures, the memory barrier is needed to ensure that
the writes happen in the expected order.</p>

<p class="docText"><span class="docEmphasis">short</span> uses <span class="docEmphasis">inb</span> and
<span class="docEmphasis">outb</span> to show how that is done. It would be a
straightforward exercise for the reader, however, to change
<span class="docEmphasis">short</span> to remap I/O ports with
<span class="docEmphasis">ioport_map</span>, and simplify the rest of the code
considerably.</p>


<a name="chp-9-sect-4.5"></a>
<a name="chp-9-ITERM-5993"></a><h4 class="docSection2Title">9.4.5. ISA Memory Below 1 MB</H4>

<p class="docText">One of the most well-known I/O memory regions is the ISA range found
on personal computers. This is the memory range between 640 KB
(<tt>0xA0000</tt>) and 1 MB (<tt>0x100000</tt>).
Therefore, it appears right in the middle of regular system RAM. This
positioning may seem a little strange; it is an artifact of a
decision made in the early 1980s, when 640 KB of memory seemed like
more than anybody would ever be able to use.</p>

<p class="docText">This memory range belongs to the non-directly-mapped class of
memory.<sup class="docFootnote"><a class="docLink" href="chp-9-sect-4.shtml#chp-9-FNOTE-5">[5]</a></sup> You can read/write a few bytes in that
memory range using the <span class="docEmphasis">short</span> module as explained
previously, that is, by setting <tt>use_mem</tt> at load
time.</p><blockquote><p class="docFootnote"><sup><a name="chp-9-FNOTE-5">[5]</a></sup> Actually, this is not completely true. The
memory range is so small and so frequently used that the kernel
builds page tables at boot time to access those addresses. However,
the virtual address used to access them is not the same as the
physical address, and thus <span class="docEmphasis">ioremap</span> is needed
anyway.</P></blockquote>

<p class="docText">Although ISA I/O memory exists only in x86-class computers, we think
it's worth spending a few words and a sample driver
on it.</p>

<p class="docText">We are not going to discuss PCI memory in this chapter, since it is
the cleanest kind of I/O memory: once you know the physical address,
you can simply remap and access it. The
"problem" with PCI I/O memory is
that it doesn't lend itself to a working example for
this chapter, because we can't know in advance the
physical addresses your PCI memory is mapped to, or whether
it's safe to access either of those ranges. We chose
to describe the ISA memory range, because it's both
less clean and more suitable to running sample code.</p>

<p class="docText"><a name="chp-9-ITERM-5994"></a>
<a name="chp-9-ITERM-5995"></a>
<a name="chp-9-ITERM-5996"></a>To
demonstrate access to ISA memory, we use yet another silly little
module (part of the sample sources). In fact, this one is called
<span class="docEmphasis">silly</span>, as an acronym for Simple Tool for
Unloading and Printing ISA Data, or something like that.</P>

<p class="docText">The module supplements the functionality of
<span class="docEmphasis">short</span> by giving access to the whole 384-KB
memory space and by showing all the different I/O functions. It
features four device nodes that perform the same task using different
data transfer functions. The <span class="docEmphasis">silly</span> devices act
as a window over I/O memory, in a way similar to
<i>/dev/mem</I>. You can read and write data, and
<span class="docEmphasis">lseek</span> to an arbitrary I/O memory address.</p>

<p class="docText">Because <span class="docEmphasis">silly</span> provides access to ISA memory, it
must start by mapping the physical ISA addresses into kernel virtual
addresses. In the early days of the Linux kernel, one could simply
assign a pointer to an ISA address of interest, then dereference it
directly. In the modern world, though, we must work with the virtual
memory system and remap the memory range first. This mapping is done
with <span class="docEmphasis">ioremap</span>, as explained earlier for
<span class="docEmphasis">short</span>:</p>

<pre>#define ISA_BASE    0xA0000
#define ISA_MAX     0x100000  /* for general memory access */

    /* this line appears in silly_init */
    io_base = ioremap(ISA_BASE, ISA_MAX - ISA_BASE);</pre><br>


<p class="docText"><span class="docEmphasis">ioremap</span> returns a pointer value that can be used
with <span class="docEmphasis">ioread8</span> and the other functions explained
in <a class="docLink" href="chp-9-sect-4.shtml#chp-9-sect-4.2">Section 9.4.2</a>.</p>

<p class="docText">Let's look back at our sample module to see how
these functions might be used. <i>/dev/sillyb</i>,
featuring minor number <tt>0</tt>, accesses I/O memory with
<span class="docEmphasis">ioread8</span> and <span class="docEmphasis">iowrite8</span>. The
following code shows the implementation for
<span class="docEmphasis">read</span>, which makes the address range
<tt>0xA0000-0xFFFFF</tt> available as a virtual file in the
range <tt>0-0x5FFFF</tt>. The <span class="docEmphasis">read</span>
function is structured as a <tt>switch</tt> statement over
the different access modes; here is the <i>sillyb</i>
<tt>case</tt>:</p>

<pre>case M_8: 
  while (count) {
      *ptr = ioread8(add);
      add++;
      count--;
      ptr++;
  }
  break;</pre><br>


<p class="docText">The next two devices are <i>/dev/sillyw</i> (minor
number 1) and <i>/dev/sillyl</I> (minor number 2). They
act like <i>/dev/sillyb</I>, except that they use
16-bit and 32-bit functions. Here's the
<span class="docEmphasis">write</span> implementation of
<I>sillyl</i>, again part of a
<tt>switch</tt>:</p>

<pre>case M_32: 
  while (count &gt;= 4) {
      iowrite8(*(u32 *)ptr, add);
      add += 4;
      count -= 4;
      ptr += 4;
  }
  break;</pre><br>


<p class="docText">The last device is <I>/dev/sillycp</i> (minor number
3), which uses the <span class="docEmphasis">memcpy_*io</span> functions to
perform the same task. Here's the core of its
<span class="docEmphasis">read</span> implementation:</P>

<pre>case M_memcpy:
  memcpy_fromio(ptr, add, count);
  break;</pre><BR>


<p class="docText">Because <span class="docEmphasis">ioremap</span> was used to provide access to
the ISA memory area, <span class="docEmphasis">silly</span> must invoke
<span class="docEmphasis">iounmap</span> when the module is unloaded:</P>

<a name="chp-9-ITERM-5997"></a><pre>iounmap(io_base);</pre><br>



<a name="chp-9-sect-4.6"></a>
<h4 class="docSection2Title">9.4.6. isa_readb and Friends</h4>

<p class="docText"><a name="chp-9-ITERM-5998"></a>
<a name="chp-9-ITERM-5999"></a>A
look at the kernel source will turn up another set of routines with
names such as <span class="docEmphasis">isa_readb</span>. In fact, each of the
functions just described has an <span class="docEmphasis">isa_</span> equivalent.
These functions provide access to ISA memory without the need for a
separate <span class="docEmphasis">ioremap</span> step. The word from the kernel
developers, however, is that these functions are intended to be
temporary driver-porting aids and that <a name="chp-9-ITERM-6000"></a> <a name="chp-9-ITERM-6001"></a> <a name="chp-9-ITERM-6002"></a> <a name="chp-9-ITERM-6003"></a> <a name="chp-9-ITERM-6004"></a>they may go away in the future.
Therefore, you should avoid using them.</p>



<UL></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-9-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-9-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
