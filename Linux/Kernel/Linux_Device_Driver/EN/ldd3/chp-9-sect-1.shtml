<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>9.1. I/O Ports and I/O Memory</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-9.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-9-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-9-sect-1"></a>
<h3 class="docSection1Title" >9.1. I/O Ports and I/O Memory</h3>

<p class="docText">Every peripheral device is <a name="chp-9-ITERM-5828"></a>
<a name="chp-9-ITERM-5829"></a> <a name="chp-9-ITERM-5830"></a>
<a name="chp-9-ITERM-5831"></a>
<a name="chp-9-ITERM-5832"></a>controlled by writing and reading
its registers. Most of the time a device has several registers, and
they are accessed at consecutive addresses, either in the memory
address space or in the I/O address space.</p>

<p class="docText">At the hardware level, there is no conceptual difference between
memory regions and I/O regions: both of them are accessed by
asserting electrical signals on the address bus and control bus
(i.e., the <span class="docEmphasis">read</span> and <span class="docEmphasis">write</span>
signals)<sup class="docFootnote"><a class="docLink" href="chp-9-sect-1.shtml#chp-9-FNOTE-1">[1]</a></sup> and by reading from or writing to the data bus.</p><blockquote><p class="docFootnote"><sup><a name="chp-9-FNOTE-1">[1]</a></sup> Not all computer platforms use a
<span class="docEmphasis">read</span> and a <span class="docEmphasis">write</span> signal;
some have different means to address external circuits. The
difference is irrelevant at software level, however, and
we'll assume all have <span class="docEmphasis">read</span> and
<span class="docEmphasis">write</span> to simplify the discussion.</p></blockquote>

<p class="docText">While some CPU manufacturers implement a single address space in
their chips, others decided that peripheral devices are different
from memory and, therefore, deserve a separate address space. Some
processors (most notably the x86 family) have separate
<span class="docEmphasis">read</span> and <span class="docEmphasis">write</span> electrical
lines for I/O ports and special CPU instructions to access ports.</p>

<p class="docText">Because peripheral devices are built to fit a peripheral bus, and the
most popular I/O buses are modeled on the personal computer, even
processors that do not have a separate address space for I/O ports
must fake reading and writing I/O ports when accessing some
peripheral devices, usually by means of external chipsets or extra
circuitry in the CPU core. The latter solution is common within tiny
processors meant for embedded use.</p>

<p class="docText">For the same reason, Linux implements the concept of I/O ports on all
computer platforms it runs on, even on platforms where the CPU
implements a single address space. The implementation of port access
sometimes depends on the specific make and model of the host computer
(because different models use different chipsets to map bus
transactions into memory address space).</p>

<p class="docText">Even if the peripheral bus has a separate address space for I/O
ports, not all devices map their registers to I/O ports. While use of
I/O ports is common for ISA peripheral boards, most PCI devices map
registers into a memory address region. This I/O memory approach is
generally preferred, because it doesn't require the
use of special-purpose processor instructions; CPU cores access
memory much more efficiently, and the compiler has much more freedom
in register allocation and addressing-mode selection when accessing
memory.</p>

<a name="chp-9-sect-1.1"></a>
<h4 class="docSection2Title">9.1.1. I/O Registers and Conventional Memory</h4>

<p class="docText"><a name="chp-9-ITERM-5833"></a>
<a name="chp-9-ITERM-5834"></a>
<a name="chp-9-ITERM-5835"></a><a name="chp-9-ITERM-5836"></a><a name="chp-9-ITERM-5837"></a><a name="chp-9-ITERM-5838"></a><a name="chp-9-ITERM-5839"></a><a name="chp-9-ITERM-5840"></a><a name="chp-9-ITERM-5841"></a><a name="chp-9-ITERM-5842"></a>Despite the strong
similarity between<a name="chp-9-ITERM-5843"></a> hardware
registers and memory, a programmer accessing I/O registers must be
careful to avoid being tricked by CPU (or compiler) optimizations
that can modify the expected I/O behavior.</p>

<p class="docText">The main difference between I/O registers and RAM is that I/O
operations have side effects, while memory operations have none: the
only effect of a memory write is storing a value to a location, and a
memory read returns the last value written there. Because memory
access speed is so critical to CPU performance, the no-side-effects
case has been optimized in several ways: values are cached and
read/write instructions are reordered.</P>

<p class="docText">The compiler can cache data values into CPU registers without writing
them to memory, and even if it stores them, both write and read
operations can operate on cache memory without ever reaching physical
RAM. Reordering can also happen both at the compiler level and at the
hardware level: often a sequence of instructions can be executed more
quickly if it is run in an order different from that which appears in
the program text, for example, to prevent interlocks in the RISC
pipeline. On CISC processors, operations that take a significant
amount of time can be executed concurrently with other, quicker ones.</p>

<p class="docText">These optimizations are transparent and benign when applied to
conventional memory (at least on uniprocessor systems), but they can
be fatal to correct I/O operations, because they interfere with those
"side effects" that are the main
reason why a driver accesses I/O registers. The processor cannot
anticipate a situation in which some other process (running on a
separate processor, or something happening inside an I/O controller)
depends on the order of memory access. The compiler or the CPU may
just try to outsmart you and reorder the operations you request; the
result can be strange errors that are very difficult to debug.
Therefore, a driver must ensure that no caching is performed and no
read or write reordering takes place when accessing registers.</P>

<p class="docText"><a name="chp-9-ITERM-5844"></a>
<a name="chp-9-ITERM-5845"></a><a name="chp-9-ITERM-5846"></a>
<a name="chp-9-ITERM-5847"></a>The
problem with hardware caching is the easiest to face: the underlying
hardware is already configured (either automatically or by Linux
initialization code) to disable any hardware cache when accessing I/O
regions (whether they are memory or port regions).</P>

<p class="docText"><a name="chp-9-ITERM-5848"></a>
<a name="chp-9-ITERM-5849"></a>The
solution to compiler optimization and hardware reordering is to place
a <i>memory barrier</i> between operations that must
be visible to the hardware (or to another processor) in a particular
order. Linux provides four macros to cover all possible ordering
needs:</p>

<a name="chp-9-ITERM-5850"></a><a name="chp-9-ITERM-5851"></a><a name="chp-9-ITERM-5852"></a><a name="chp-9-ITERM-5853"></a><a name="chp-9-ITERM-5854"></a><a name="chp-9-ITERM-5855"></a><a name="chp-9-ITERM-5856"></a><a name="chp-9-ITERM-5857"></a><a name="chp-9-ITERM-5858"></a><a name="chp-9-ITERM-5859"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/kernel.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void barrier(void)</span></span><a name="chp-9-ITERM-5850"></a>
<a name="chp-9-ITERM-5851"></a></span></dt></p>
<dd>
<p class="docList">This function tells the compiler to insert a memory barrier but has
no effect on the hardware. Compiled code stores to memory all values
that are currently modified and resident in CPU registers, and
rereads them later when they are needed. A call to
<span class="docEmphasis">barrier</span> prevents compiler optimizations across
the barrier but leaves the hardware free to do its own reordering.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/system.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void rmb(void);</span></span><a name="chp-9-ITERM-5852"></a>
<a name="chp-9-ITERM-5853"></a></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void read_barrier_depends(void);</span></span><a name="chp-9-ITERM-5854"></a>
<a name="chp-9-ITERM-5855"></a></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void wmb(void);</span></span><a name="chp-9-ITERM-5856"></a>
<a name="chp-9-ITERM-5857"></a></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void mb(void);</span></span><a name="chp-9-ITERM-5858"></a>
<a name="chp-9-ITERM-5859"></a></span></dt></p>
<dd>
<p class="docList">These functions insert hardware memory barriers in the compiled
instruction flow; their actual instantiation is platform dependent.
An <span class="docEmphasis">rmb</span> (read memory barrier) guarantees that any
reads appearing before the barrier are completed prior to the
execution of any subsequent read. <span class="docEmphasis">wmb</span> guarantees
ordering in write operations, and the <span class="docEmphasis">mb</span>
instruction guarantees both. Each of these functions is a superset of
<span class="docEmphasis">barrier</span>.</P>
</dd>
</dl>
<p class="docText"><span class="docEmphasis">read_barrier_depends</span> is a special, weaker form
of read barrier. Whereas <span class="docEmphasis">rmb</span> prevents the
reordering of all reads across the barrier,
<span class="docEmphasis">read_barrier_depends</span> blocks only the reordering
of reads that depend on data from other reads. The distinction is
subtle, and it does not exist on all architectures. Unless you
understand exactly what is going on, and you have a reason to believe
that a full read barrier is exacting an excessive performance cost,
you should probably stick to using <span class="docEmphasis">rmb</span>.</p>

<a name="chp-9-ITERM-5860"></a><a name="chp-9-ITERM-5861"></a><a name="chp-9-ITERM-5862"></a><a name="chp-9-ITERM-5863"></a><a name="chp-9-ITERM-5864"></a><a name="chp-9-ITERM-5865"></a><a name="chp-9-ITERM-5866"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void smp_rmb(void);</span></span><a name="chp-9-ITERM-5860"></a>
<a name="chp-9-ITERM-5861"></a></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void smp_read_barrier_depends(void);</span></span><a name="chp-9-ITERM-5862"></a></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void smp_wmb(void);</span></span><a name="chp-9-ITERM-5863"></a>
<a name="chp-9-ITERM-5864"></a></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void smp_mb(void);</span></span><a name="chp-9-ITERM-5865"></a>
<a name="chp-9-ITERM-5866"></a></span></dt></p>
<dd>
<p class="docList">These versions of the barrier macros insert hardware barriers only
when the kernel is compiled for SMP systems; otherwise, they all
expand to a simple <span class="docEmphasis">barrier</span> call.</p>
</dd>
</dl>

<p class="docText">A typical usage of memory barriers in a device driver
<a name="chp-9-ITERM-5867"></a>may have this sort of form:</p>

<pre>writel(dev-&gt;registers.addr, io_destination_address);
writel(dev-&gt;registers.size, io_size);
writel(dev-&gt;registers.operation, DEV_READ);
wmb(  );
writel(dev-&gt;registers.control, DEV_GO);</pre><br>


<p class="docText">In this case, it is important to be sure that all of the device
registers controlling a particular operation have been properly set
prior to telling it to begin. The memory barrier enforces the
completion of the writes in the necessary order.</p>

<p class="docText"><a name="chp-9-ITERM-5868"></a>
<a name="chp-9-ITERM-5869"></a>
<a name="chp-9-ITERM-5870"></a><a name="chp-9-ITERM-5871"></a>Because memory barriers affect
performance, they should be used only where they are really needed.
The different types of barriers can also have different performance
characteristics, so it is worthwhile to use the most specific type
possible. For example, on the x86 architecture, <span class="docEmphasis">wmb(
)</span> currently does nothing, since writes outside the
processor are not reordered. Reads are reordered, however, so
<span class="docEmphasis">mb( )</span> is slower than <span class="docEmphasis">wmb(
)</span>.</p>

<p class="docText">It is worth noting that most of the other kernel primitives dealing
with synchronization, such as spinlock and
<tt>atomic_t</tt> operations, also function as memory
barriers. Also worthy of note is that some peripheral buses (such as
the PCI bus) have caching issues of their own; we discuss those when
we get to them in later chapters.</P>

<p class="docText"><a name="chp-9-ITERM-5872"></a>
<a name="chp-9-ITERM-5873"></a><a name="chp-9-ITERM-5874"></a>
<a name="chp-9-ITERM-5875"></a><a name="chp-9-ITERM-5876"></a>
<a name="chp-9-ITERM-5877"></a>Some
architectures allow the efficient combination of an assignment and a
memory barrier. The kernel provides a few macros that perform this
combination; in the default case, they are defined as follows:</p>

<pre>#define set_mb(var, value)  do {var = value; mb(  );}  while 0
#define set_wmb(var, value) do {var = value; wmb(  );} while 0
#define set_rmb(var, value) do {var = value; rmb(  );} while 0</pre><BR>


<p class="docText">Where appropriate, <I>&lt;asm/system.h&gt;</i> defines
these macros to use architecture-specific instructions that
accomplish the task more quickly. Note that
<span class="docEmphasis">set_rmb</span> is defined only by a small number of
architectures. (The use of a <tt>do...while</tt> construct
is a standard C idiom that causes the expanded macro to work as a
normal C statement in all contexts.)</p>



<ul></UL></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-9.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-9-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
