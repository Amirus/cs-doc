<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>14.1. Kobjects, Ksets, and Subsystems</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-14-sect-1"></a>
<H3 class="docSection1Title">14.1. Kobjects, Ksets, and Subsystems</H3>

<p class="docText">The <i>kobject</i> is the <a name="chp-14-ITERM-6613"></a> <a name="chp-14-ITERM-6614"></a>
<a name="chp-14-ITERM-6615"></a>
<a name="chp-14-ITERM-6616"></a>
<a name="chp-14-ITERM-6617"></a>
<a name="chp-14-ITERM-6618"></a>
<a name="chp-14-ITERM-6619"></a>fundamental
structure
<a name="chp-14-ITERM-6620"></a>that holds the device
model together. It was initially conceived as a simple reference
counter, but its responsibilities have grown over time, and so have
its fields. The tasks handled by <tt>struct</tt>
<tt>kobject</tt> and its supporting code now include:</p>

<dl class="docList"><dt><i><span class="docPubcolor">Reference counting of objects </span></i></dt></P>
<dd>
<p class="docList">Often, when a kernel object is created, there is no way to know just
how long it will exist. One way of tracking the lifecycle of such
objects is through reference counting. When no code in the kernel
holds a reference to a given object, that object has finished its
useful life and can be deleted.</p>
</dd>
<dt><i><span class="docPubcolor">Sysfs representation </span></I></dt></p>
<dd>
<p class="docList">Every object that shows up in sysfs has, underneath it, a kobject
that interacts with the kernel to create its visible representation.</p>
</dd>
<dt><i><span class="docPubcolor">Data structure glue </span></i></dt></p>
<dd>
<p class="docList">The device model is, in its entirety, a fiendishly complicated data
structure made up of multiple hierarchies with numerous links between
them. The kobject implements this structure and holds it together.</p>
</dd>
<dt><i><span class="docPubcolor">Hotplug event handling </span></i></dt></p>
<dd>
<p class="docList">The kobject subsystem handles the generation of events that notify
user space about the comings and goings of hardware on the system.</P>
</dd>
</dl>

<p class="docText">One might conclude from the preceding list that the kobject is a
complicated structure. One would be right. By looking at one piece at
a time, however, it is possible to understand this structure and how
it works.</p>

<a name="chp-14-sect-1.1"></a>
<H4 class="docSection2Title">14.1.1. Kobject Basics</H4>

<p class="docText">A kobject has the type <tt>struct kobject</tt>; it is
defined in <i>&lt;linux/kobject.h&gt;</i>. That file
also includes declarations for a number of other structures related
to kobjects and, of course, a long list of functions for manipulating
them.</p>

<a name="chp-14-sect-1.1.1"></a>
<H5 class="docSection3Title">14.1.1.1 Embedding kobjects</h5>

<p class="docText">Before we get into
<a name="chp-14-ITERM-6621"></a>
<a name="chp-14-ITERM-6622"></a>the
details, it is worth taking a moment to understand how kobjects are
used. If you look back at the list of functions handled by kobjects,
you see that they are all services performed on behalf of other
objects. A kobject, in other words, is of little interest on its own;
it exists only to tie a higher-level object into the device model.</P>

<p class="docText">Thus, it is rare (even unknown) for kernel code to create a
standalone kobject; instead, kobjects are used to control access to a
larger, domain-specific object. To this end, kobjects are found
embedded in other structures. If you are used to thinking of things
in object-oriented terms, kobjects can be seen as a top-level,
abstract class from which other classes are derived. A kobject
implements a set of capabilities that are not particularly useful by
themselves but that are nice to have in other objects. The C language
does not allow for the direct expression of inheritance, so other
techniques—such as embedding one structure in
another—must be used.</P>

<p class="docText">As an example, let's look back at
<tt>struct</tt> <tt>cdev</tt>, which we
encountered in <a class="docLink" href="chp-3.shtml#chp-3">Chapter 3</a>. That
structure, as found in the 2.6.10 kernel, looks like this:</P>

<pre>struct cdev {
    struct kobject kobj;
    struct module *owner;
    struct file_operations *ops;
    struct list_head list;
    dev_t dev;
    unsigned int count;
};</pre><br>


<p class="docText">As we can see, the <tt>cdev</tt> structure has a kobject
embedded within it. If you have one of these structures, finding its
embedded kobject is just a matter of using the
<tt>kobj</tt> field. Code that works with kobjects often
has the opposite problem, however: given a <tt>struct
kobject</tt> pointer, what is the pointer to the containing
structure? You should avoid tricks (such as assuming that the kobject
is at the beginning of the structure), and, instead, use the
<span class="docEmphasis">container_of</span> macro (introduced in 
<a class="docLink" href="chp-3-sect-5.shtml#chp-3-sect-5.1">Section 3.5.1</a>.
So the way to convert a
pointer
<a name="chp-14-ITERM-6623"></a>to
a <tt>struct</tt> <tt>kobject</tt> called
<tt>kp</tt> embedded within a <tt>struct
cdev</tt> would be:</p>

<pre>struct cdev *device = container_of(kp, struct cdev, kobj);</pre><br>


<p class="docText">Programmers often define a simple macro for
"<a name="chp-14-ITERM-6624"></a>back-casting" kobject
pointers to the containing type.</p>



<a name="chp-14-sect-1.1.2"></a>
<H5 class="docSection3Title">14.1.1.2 Kobject initialization</H5>

<p class="docText">This book has presented a
number<a name="chp-14-ITERM-6625"></a>
of types with simple mechanisms for initialization at compile or
runtime. The initialization of a kobject is a bit more complicated,
especially when all of its functions are used. Regardless of how a
kobject is used, however, a few steps must be performed.</P>

<p class="docText">The first of those is to simply set the entire kobject to
<tt>0</tt>, usually with a call to
<span class="docEmphasis">memset</span>. Often this initialization happens as
part of the zeroing of the structure into which the kobject is
embedded. Failure to zero out a kobject often leads to very strange
crashes further down the line; it is not a step you want to skip.</p>

<p class="docText">The next step is to set up some of the internal fields with a call to
<span class="docEmphasis">kobject_init( )</span>:</P>

<pre>void kobject_init(struct kobject *kobj);</pre><BR>


<p class="docText">Among other things, <span class="docEmphasis">kobject_init</span> sets the
kobject's reference count to one. Calling
<span class="docEmphasis">kobject_init</span> is not sufficient, however. Kobject
users must, at a minimum, set the name of the kobject; this is the
name that is used in sysfs entries. If you dig through the kernel
source, you can find the code that copies a string directly into the
kobject's <tt>name</tt> field, but that
approach should be avoided. Instead, use:</p>

<pre>int kobject_set_name(struct kobject *kobj, const char *format, ...);</pre><br>


<p class="docText">This function takes a <span class="docEmphasis">printk</span>-style variable
argument list. Believe it or not, it is actually possible for this
operation to fail (it may try to allocate memory); conscientious code
should check the return value and react accordingly.</p>

<p class="docText">The other kobject fields that should be set, directly or indirectly,
by the creator are <tt>ktype</tt>, <tt>kset</tt>,
and <tt>parent</tt>. We will get to these later in this
chapter.</p>



<a name="chp-14-sect-1.1.3"></a>
<H5 class="docSection3Title">14.1.1.3 Reference count manipulation</h5>

<p class="docText">One of the key functions <a name="chp-14-ITERM-6626"></a>
<a name="chp-14-ITERM-6627"></a>of a kobject is to serve as a
reference counter for the object in which it is embedded. As long as
references to the object exist, the object (and the code that
supports it) must continue to exist. The low-level functions for
manipulating a kobject's reference counts are:</p>

<pre>struct kobject *kobject_get(struct kobject *kobj);
void kobject_put(struct kobject *kobj);</pre><BR>


<p class="docText">A successful call to <span class="docEmphasis">kobject_get</span> increments the
kobject's reference counter and returns a pointer to
the kobject. If, however, the kobject is already in the process of
being destroyed, the operation fails, and
<span class="docEmphasis">kobject_get</span> returns <tt>NULL</tt>.
This return value must always be tested, or no end of unpleasant race
conditions could result.</p>

<p class="docText">When a reference is released, the call to
<span class="docEmphasis">kobject_put</span> decrements the reference count and,
possibly, frees the object. Remember that
<span class="docEmphasis">kobject_init</span> sets the reference count to one; so
when you create a kobject, you should make sure that the
corresponding <span class="docEmphasis">kobject_put</span> call is made when that
initial reference is no longer needed.</p>

<p class="docText">Note that, in many cases, the reference count in the kobject itself
may not be sufficient to prevent race conditions. The existence of a
kobject (and its containing structure) may well, for example, require
the continued existence of the module that created that kobject. It
would not do to unload that module while the kobject is still being
passed around. That is why the <tt>cdev</tt> structure we
saw above contains a <tt>struct</tt>
<tt>module</tt> pointer. Reference counting for
<tt>struct cdev</tt> is implemented as follows:</P>

<pre>struct kobject *cdev_get(struct cdev *p)
{
    struct module *owner = p-&gt;owner;
    struct kobject *kobj;

    if (owner &amp;&amp; !try_module_get(owner))
        return NULL;
    kobj = kobject_get(&amp;p-&gt;kobj);
    if (!kobj)
        module_put(owner);
    return kobj;
}</pre><br>


<p class="docText">Creating a reference to a <tt>cdev</tt> structure requires
creating a reference also to the module that owns it. So
<span class="docEmphasis">cdev_get</span> uses
<span class="docEmphasis">try_module_get</span> to attempt to increment that
module's usage count. If that operation succeeds,
<span class="docEmphasis">kobject_get</span> is used to increment the
kobject's reference count as well. That operation
could fail, of course, so the code checks the return value from
<span class="docEmphasis">kobject_get</span> and releases its reference to the
module if things don't work out.</P>



<a name="chp-14-sect-1.1.4"></a>
<h5 class="docSection3Title">14.1.1.4 Release functions and kobject types</h5>

<p class="docText">One important thing <a name="chp-14-ITERM-6628"></a>
<a name="chp-14-ITERM-6629"></a>
<a name="chp-14-ITERM-6630"></a>still missing from the discussion is
what happens to a kobject when its reference count reaches
<tt>0</tt>. The code that created the kobject generally
does not know when that will happen; if it did, there would be little
point in using a reference count in the first place. Even predictable
object life cycles become more complicated when sysfs is brought in;
user-space programs can keep a reference to a kobject (by keeping one
of its associated sysfs files open) for an arbitrary period of time.</p>

<p class="docText">The end result is that a structure protected by a kobject cannot be
freed at any single, predictable point in the
driver's lifecycle, but in code that must be
prepared to run at whatever moment the kobject's
reference count goes to <tt>0</tt>. The reference count is
not under the direct control of the code that created the kobject. So
that code must be notified asynchronously whenever the last reference
to one of its kobjects goes away.</p>

<p class="docText">This notification is done through a kobject's
<span class="docEmphasis">release</span><a name="chp-14-ITERM-6631"></a>
<a name="chp-14-ITERM-6632"></a>
method. Usually, this method has a form such as:</p>

<pre>void my_object_release(struct kobject *kobj)
{
    struct my_object *mine = container_of(kobj, struct my_object, kobj);

    /* Perform any additional cleanup on this object, then... */
    kfree(mine);
}</pre><br>


<p class="docText">One important point cannot be overstated: every kobject must have a
<span class="docEmphasis">release</span> method, and the kobject must persist (in
a consistent state) until that method is called. If these constraints
are not met, the code is flawed. It risks freeing the object when it
is still in use, or it fails to release the object after the last
reference is returned.</p>

<p class="docText">Interestingly, the <span class="docEmphasis">release</span> method is not stored
in the kobject itself; instead, it is associated with the type of the
structure that contains the kobject. This type is tracked with a
structure of type <tt>struct kobj_type</tt>, often simply
called a "ktype." This structure
looks like the following:</p>

<pre>struct kobj_type {
    void (*release)(struct kobject *);
    struct sysfs_ops *sysfs_ops;
    struct attribute **default_attrs;
};</pre><br>


<p class="docText">The <tt>release</tt> field in <tt>struct
kobj_type</tt> is, of course, a pointer to the
<span class="docEmphasis">release</span> method for this type of kobject. We will
come back to the other two fields (<tt>sysfs_ops</tt> and
<tt>default_attrs</tt>) later in this chapter.</p>

<p class="docText">Every kobject needs to have an associated
<tt>kobj_type</tt> structure. Confusingly, the pointer to
this structure can be found in two different places. The kobject
structure itself contains a field (called <tt>ktype</tt>)
that can contain this pointer. If, however, this kobject is a member
of a kset, the <tt>kobj_type</tt> pointer is provided by
that kset instead. (We will look at ksets in the next section.)
Meanwhile, the macro:</p>

<pre>struct kobj_type *get_ktype(struct kobject *kobj);</pre><br>


<p class="docText">finds the <tt>kobj_type</tt> pointer for a given kobject.</p>



<a name="chp-14-sect-1.2"></a>
<H4 class="docSection2Title">14.1.2. Kobject Hierarchies, Ksets, and Subsystems</h4>

<p class="docText">The kobject structure is
often<a name="chp-14-ITERM-6633"></a>
<a name="chp-14-ITERM-6634"></a>
<a name="chp-14-ITERM-6635"></a> used to link
together objects into a hierarchical structure that matches the
structure of the subsystem being modeled. There are two separate
mechanisms for this linking: the <tt>parent</tt> pointer
and ksets.</P>

<p class="docText">The <tt>parent</tt> field in <tt>struct
kobject</tt> is a pointer to another kobject—the one
representing the next level up in the hierarchy. If, for example, a
kobject represents a USB device, its <tt>parent</tt>
pointer may indicate the object representing the hub into which the
device is plugged.</P>

<p class="docText">The main use for the <tt>parent</tt> pointer is to position
the object in the sysfs hierarchy. We'll see how
this works in <a class="docLink" href="chp-14-sect-2.shtml#chp-14-sect-2">Section 14.2</a>.</p>

<a name="chp-14-sect-1.2.1"></a>
<h5 class="docSection3Title">14.1.2.1 Ksets</h5>

<p class="docText">In many ways, a kset looks like an extension of the
<tt>kobj_type</tt> structure; a kset is a collection of
kobjects embedded within structures of the same type. However, while
<tt>struct</tt> <tt>kobj_type</tt> concerns
itself with the type of an object, <tt>struct</tt>
<tt>kset</tt> is concerned with aggregation and collection.
The two concepts have been separated so that objects of identical
type can appear in distinct sets.</P>

<p class="docText">Therefore, the main function of a kset is containment; it can be
thought of as the top-level container class for kobjects. In fact,
each kset contains its own kobject internally, and it can, in many
ways, be treated the same way as a kobject. It is worth noting that
ksets are always represented in sysfs; once a kset has been set up
and added to the system, there will be a sysfs directory for it.
Kobjects do not necessarily show up in sysfs, but every kobject that
is a member of a kset is represented there.</p>

<p class="docText">Adding a kobject to a kset is usually done when the object is
created; it is a two-step process. The kobject's
<tt>kset</tt> field must be pointed at the kset of
interest; then the kobject should be passed to:</P>

<pre>int kobject_add(struct kobject *kobj);</pre><BR>


<p class="docText">As always, programmers should be aware that this function can fail
(in which case it returns a negative error code) and respond
accordingly. There is a convenience function provided by the kernel:</P>

<pre>extern int kobject_register(struct kobject *kobj);</pre><br>


<p class="docText">This function is simply a combination of
<span class="docEmphasis">kobject_init</span> and
<span class="docEmphasis">kobject_add</span>.</p>

<p class="docText">When a kobject is passed to <span class="docEmphasis">kobject_add</span>, its
reference count is incremented. Containment within the kset is, after
all, a reference to the object. At some point, the kobject will
probably have to be removed from the kset to clear that reference;
that is done with:</p>

<pre>void kobject_del(struct kobject *kobj);</pre><br>


<p class="docText">There is also a <span class="docEmphasis">kobject_unregister</span> function,
which is a combination of <span class="docEmphasis">kobject_del</span> and
<span class="docEmphasis">kobject_put</span>.</P>

<p class="docText">A kset keeps its children in a standard kernel linked list. In almost
all cases, the contained kobjects also have pointers to the kset (or,
strictly, its embedded kobject) in their parent's
fields. So, typically, a kset and its kobjects look something like
what you see in <a class="docLink" href="chp-14.shtml#chp-14-FIG-1">Figure 14-1</a>.
Bear in mind that:</P>

<UL><li><p class="docList">All of the contained kobjects in the diagram are actually embedded
within some other type, possibly even other ksets.</P></LI><li><p class="docList">It is not required that a kobject's parent be the
containing kset (although any other organization would be strange and
rare).</p></li></ul>
<a name="chp-14-FIG-2"></a><P><center>
<h5 class="docFigureTitle">Figure 14-2. A simple kset hierarchy</h5>
<img border="0" alt="" width="374" height="138" SRC="images/0596005903/figs/ldr3_1402.gif"></center></P><br>



<a name="chp-14-sect-1.2.2"></a>
<h5 class="docSection3Title">14.1.2.2 Operations on ksets</H5>

<p class="docText">For initialization and setup, ksets have an
<a name="chp-14-ITERM-6636"></a>
<a name="chp-14-ITERM-6637"></a>interface very similar
to<a name="chp-14-ITERM-6638"></a>
that of kobjects. The following functions exist:</p>

<pre>void kset_init(struct kset *kset);
int kset_add(struct kset *kset);
int kset_register(struct kset *kset);
void kset_unregister(struct kset *kset);</pre><BR>


<p class="docText">For the most part, these
functions<a name="chp-14-ITERM-6639"></a>
just call the analogous <span class="docEmphasis">kobject_</span> function on the
kset's embedded kobject.</p>

<p class="docText">To manage the reference counts of ksets, the situation is about the
same:</p>

<pre>struct kset *kset_get(struct kset *kset);
void kset_put(struct kset *kset);</pre><br>


<p class="docText">A kset also has a name, which is stored in the embedded kobject. So,
if you have a kset called <tt>my_set</tt>, you would set
its name with:</p>

<pre>kobject_set_name(&amp;my_set-&gt;kobj, "The name");</pre><br>


<p class="docText">Ksets also have a pointer (in the <tt>ktype</tt> field) to
the <tt>kobj_type</tt> structure describing the kobjects it
contains. This type is used in preference to the
<tt>ktype</tt> field in a kobject itself. As a result, in
typical usage, the <tt>ktype</tt> field in
<tt>struct</tt> <tt>kobject</tt> is left
<tt>NULL</tt>, because the same field within the kset is
the one actually used.</p>

<p class="docText">Finally, a kset contains a subsystem pointer (called subsys). So
it's time to talk about subsystems.</p>



<a name="chp-14-sect-1.2.3"></a>
<h5 class="docSection3Title">14.1.2.3 Subsystems</h5>

<p class="docText">A subsystem is
a<a name="chp-14-ITERM-6640"></a>
<a name="chp-14-ITERM-6641"></a>
representation for a high-level portion of the kernel as a whole.
Subsystems usually (but not always) show up at the top of the sysfs
hierarchy. Some example subsystems in the kernel include
<tt>block_subsys</tt> (<i>/sys/block</i>, for
block devices), <tt>devices_subsys</tt>
(<i>/sys/devices</i>, the core device hierarchy), and a
specific subsystem for every bus type known to the kernel. A driver
author almost never needs to create a new subsystem; if you feel
tempted to do so, think again. What you probably want, in the end, is
to add a new class, as discussed in <a class="docLink" href="chp-14-sect-5.shtml#chp-14-sect-5">Section 14.5</a>.</P>

<p class="docText">A subsystem is represented by a simple structure:</p>

<pre>struct subsystem {
    struct kset kset;
    struct rw_semaphore rwsem;
};</pre><BR>


<p class="docText">A subsystem, thus, is really just a wrapper around a kset, with a
semaphore thrown in.</P>

<p class="docText">Every kset must belong to a subsystem. The subsystem membership helps
establish the kset's position in the hierarchy, but,
more importantly, the subsystem's
<tt>rwsem</tt> semaphore is used to serialize access to a
kset's internal-linked list. This membership is
represented by the <tt>subsys</tt> pointer in
<tt>struct kset</tt>. Thus, one can find each
kset's containing subsystem from the
kset's structure, but one cannot find the multiple
ksets contained in a subsystem directly from the subsystem structure.</p>

<p class="docText">Subsystems are often declared with a special macro:</p>

<pre>decl_subsys(name, struct kobj_type *type, 
            struct kset_hotplug_ops *hotplug_ops);</pre><br>


<p class="docText">This macro creates a <tt>struct subsystem</tt> with a name
formed by taking the <tt>name</tt> given to the macro and
appending <tt>_subsys</tt> to it. The macro also
initializes the internal kset with the given <tt>type</tt>
and <tt>hotplug_ops</tt>. (We discuss hotplug operations
later in this chapter.)</P>

<p class="docText">Subsystems have the usual list of setup and teardown functions:</p>

<pre>void subsystem_init(struct subsystem *subsys);
int subsystem_register(struct subsystem *subsys);
void subsystem_unregister(struct subsystem *subsys);
struct subsystem *subsys_get(struct subsystem *subsys)
void subsys_put(struct subsystem *subsys);</pre><BR>


<p class="docText">Most of these operations just act upon<a name="chp-14-ITERM-6642"></a> <a name="chp-14-ITERM-6643"></a> <a name="chp-14-ITERM-6644"></a> <a name="chp-14-ITERM-6645"></a> <a name="chp-14-ITERM-6646"></a> <a name="chp-14-ITERM-6647"></a> <a name="chp-14-ITERM-6648"></a> the subsystem's
kset.</P>




<UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
