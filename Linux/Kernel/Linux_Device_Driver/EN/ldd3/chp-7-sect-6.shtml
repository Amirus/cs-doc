<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>7.6. Workqueues</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7-sect-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-7-sect-6"></a>
<h3 class="docSection1Title">7.6. Workqueues</h3>

<p class="docText"><i>Workqueues</I> are, superficially, similar to
tasklets; they allow kernel code to request that a function be
called<a name="chp-7-ITERM-5619"></a>
<a name="chp-7-ITERM-5620"></a>
<a name="chp-7-ITERM-5621"></a>
<a name="chp-7-ITERM-5622"></a>
at some future time. There are, however, some significant differences
between the two, including:</p>

<UL><LI><p class="docList">Tasklets run in software interrupt context with the result that all
tasklet code must be atomic. Instead, workqueue functions run in the
context of a special kernel process; as a result, they have more
flexibility. In particular, workqueue functions can sleep.</P></li><li><p class="docList">Tasklets always run on the processor from which they were originally
submitted. Workqueues work in the same way, by default.</p></li><LI><p class="docList">Kernel code can request that the execution of workqueue functions be
delayed for an explicit interval.</P></LI></ul>
<p class="docText">The key difference between the two is that tasklets execute quickly,
for a short period of time, and in atomic mode, while workqueue
functions may have higher latency but need not be atomic. Each
mechanism has situations where it is appropriate.</P>

<p class="docText">Workqueues have a type of <tt>struct</tt>
<tt>workqueue_struct</tt>, which is defined in
<I>&lt;linux/workqueue.h&gt;</i>. A workqueue must be
explicitly created before use, using one of the following two
functions:</p>

<pre>struct workqueue_struct *create_workqueue(const char *name);
struct workqueue_struct *create_singlethread_workqueue(const char *name);</pre><br>


<p class="docText">Each workqueue has one or more dedicated processes
("kernel threads"), which run
functions submitted to the queue. If you use
<span class="docEmphasis">create_workqueue</span>, you get a workqueue that has a
dedicated thread for each processor on the system. In many cases, all
those threads are simply overkill; if a single worker thread will
suffice, create the workqueue with
<span class="docEmphasis">create_singlethread_workqueue</span> instead.</p>

<p class="docText">To submit a task to a workqueue, you need to fill in a
<tt>work_struct</tt> structure. This can be done at compile
time as follows:</P>

<pre>DECLARE_WORK(name, void (*function)(void *), void *data);</pre><br>


<p class="docText">Where <tt>name</tt> is the name of the structure to be
declared, <tt>function</tt> is the function that is to be
called from the workqueue, and <tt>data</tt> is a value to
pass to that function. If you need to set up the
<tt>work_struct</tt> structure at runtime, use the
following two macros:</p>

<pre>INIT_WORK(struct work_struct *work, void (*function)(void *), void *data);
PREPARE_WORK(struct work_struct *work, void (*function)(void *), void *data);</pre><BR>


<p class="docText"><span class="docEmphasis">INIT_WORK</span> does a more thorough job of
initializing the structure; you should use it the first time that
structure is set up. <span class="docEmphasis">PREPARE_WORK</span> does almost
the same job, but it does not initialize the pointers used to link
the <tt>work_struct</tt> structure into the workqueue. If
there is any possibility that the structure may currently be
submitted to a workqueue, and you need to change that structure, use
<span class="docEmphasis">PREPARE_WORK</span> rather than
<span class="docEmphasis">INIT_WORK</span>.</p>

<p class="docText">There are two functions
for<a name="chp-7-ITERM-5623"></a>
submitting work to a workqueue:</p>

<pre>int queue_work(struct workqueue_struct *queue, struct work_struct *work);
int queue_delayed_work(struct workqueue_struct *queue, 
                       struct work_struct *work, unsigned long delay);</pre><BR>


<p class="docText">Either one adds <tt>work</tt> to the given
<tt>queue</tt>. If <span class="docEmphasis">queue_delayed_work</span>
is used, however, the actual work is not performed until at least
<tt>delay</tt> jiffies have passed. The return value from
these functions is <tt>0</tt> if the work was successfully
added to the queue; a nonzero result means that this
<tt>work_struct</tt> structure was already waiting in the
queue, and was not added a second time.</p>

<p class="docText">At some time in the future, the work function will be called with the
given <tt>data</tt> value. The function will be running in
the context of the worker thread, so it can sleep if need
beâ€”although you should be aware of how that sleep might affect
any other tasks submitted to the same workqueue. What the function
cannot do, however, is access user space. Since it is running inside
a kernel thread, there simply is no user space to access.</P>

<p class="docText">Should you need to cancel a pending workqueue entry, you may call:</p>

<pre>int cancel_delayed_work(struct work_struct *work);</pre><br>


<p class="docText">The return value is nonzero if the entry was canceled before it began
execution. The kernel guarantees that execution of the given entry
will not be initiated after a call to
<span class="docEmphasis">cancel_delayed_work</span>. If
<span class="docEmphasis">cancel_delayed_work</span> returns
<tt>0</tt>, however, the entry may have already been
running on a different processor, and might still be running after a
call to <span class="docEmphasis">cancel_delayed_work</span>. To be absolutely
sure that the work function is not running anywhere in the system
after <span class="docEmphasis">cancel_delayed_work</span> returns
<tt>0</tt>, you must follow that call with a call to:</p>

<pre>void flush_workqueue(struct workqueue_struct *queue);</pre><br>


<p class="docText">After <span class="docEmphasis">flush_workqueue</span> returns, no work function
submitted prior to the call is running anywhere in the system.</p>

<p class="docText">When you are done with a workqueue, you can get rid of it with:</p>

<pre>void destroy_workqueue(struct workqueue_struct *queue);</pre><br>


<a name="chp-7-sect-6.1"></a>
<h4 class="docSection2Title">7.6.1. The Shared Queue</h4>

<p class="docText">A device driver, in many cases, does not need its own workqueue. If
you only submit tasks to the queue occasionally, it may be more
efficient to simply use the shared, default workqueue that is
provided by the kernel. If you use this queue, however, you must be
aware that you will be sharing it with others. Among other things,
that means that you should not monopolize the queue for long periods
of time (no long sleeps), and it may take longer for your tasks to
get their turn in the processor.</p>

<p class="docText">The <span class="docEmphasis">jiq</span> ("just in
queue") module exports two files that demonstrate
the use of the shared workqueue. They use a single
<tt>work_struct</tt> structure, which is set up this way:</p>

<pre>static struct work_struct jiq_work;

    /* this line is in jiq_init(  ) */
    INIT_WORK(&amp;jiq_work, jiq_print_wq, &amp;jiq_data);</pre><br>


<p class="docText">When a
process<a name="chp-7-ITERM-5624"></a>
reads <i>/proc/jiqwq</I>, the module initiates a series
of trips through the shared workqueue with no delay. The function it
uses is:</p>

<pre>int schedule_work(struct work_struct *work);</pre><BR>


<p class="docText">Note that a different function is used when working with the shared
queue; it requires only the <tt>work_struct</tt> structure
for an argument. The actual code in <span class="docEmphasis">jiq</span> looks
like this:</P>

<pre>prepare_to_wait(&amp;jiq_wait, &amp;wait, TASK_INTERRUPTIBLE);
schedule_work(&amp;jiq_work);
schedule(  );
finish_wait(&amp;jiq_wait, &amp;wait);</pre><br>


<p class="docText">The actual work function prints out a line just like the
<span class="docEmphasis">jit</span> module does, then, if need be, resubmits the
<tt>work_struct</tt> structure into the workqueue. Here is
<span class="docEmphasis">jiq_print_wq</span> in its entirety:</p>

<pre>static void jiq_print_wq(void *ptr)
{
    struct clientdata *data = (struct clientdata *) ptr;
    
    if (! jiq_print (ptr))
        return;
    
    if (data-&gt;delay)
        schedule_delayed_work(&amp;jiq_work, data-&gt;delay);
    else
        schedule_work(&amp;jiq_work);
}</pre><br>


<p class="docText">If the user is reading the delayed device
(<I>/proc/jiqwqdelay</i>), the work function resubmits
itself in the delayed mode with
<span class="docEmphasis">schedule_delayed_work</span>:</P>

<pre>int schedule_delayed_work(struct work_struct *work, unsigned long delay);</pre><BR>


<p class="docText">If you look at the output from these two devices, it looks something
like:</P>

<pre>% <b>cat /proc/jiqwq</b>
    time  delta preempt   pid cpu command
  1113043     0       0     7   1 events/1
  1113043     0       0     7   1 events/1
  1113043     0       0     7   1 events/1
  1113043     0       0     7   1 events/1
  1113043     0       0     7   1 events/1
% <b>cat /proc/jiqwqdelay</b>
    time  delta preempt   pid cpu command
  1122066     1       0     6   0 events/0
  1122067     1       0     6   0 events/0
  1122068     1       0     6   0 events/0
  1122069     1       0     6   0 events/0
  1122070     1       0     6   0 events/0</pre><br>


<p class="docText">When <i>/proc/jiqwq</I> is read, there is no obvious
delay between the printing of each line. When, instead,
<I>/proc/jiqwqdelay</I> is read, there is a delay of
exactly one jiffy between each line. In either case, we see the same
process name printed; it is the name of the kernel thread that
implements the shared workqueue. The CPU number is printed after the
slash; we never know which CPU will be running when the
<i>/proc</I> file is read, but the work function will
always run on the same processor thereafter.</P>

<p class="docText">If you need to cancel a work entry submitted to the shared queue, you
may use <span class="docEmphasis">cancel_delayed_work</span>, as described above.
Flushing the shared workqueue requires a separate function, however:</p>

<pre>void flush_scheduled_work(void);</pre><br>


<p class="docText">Since you do not know who<a name="chp-7-ITERM-5625"></a> <a name="chp-7-ITERM-5626"></a> <a name="chp-7-ITERM-5627"></a> <a name="chp-7-ITERM-5628"></a> else might be using this queue, you
never really know how long it might take for
<span class="docEmphasis">flush_scheduled_work</span> to return.</p>



<ul></UL></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-7-sect-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
