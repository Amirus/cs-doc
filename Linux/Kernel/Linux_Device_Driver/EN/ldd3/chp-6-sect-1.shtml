<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>6.1. ioctl</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-6-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-6-sect-1"></a>
<h3 class="docSection1Title">6.1. ioctl</h3>

<p class="docText">Most drivers need—in addition<a name="chp-6-ITERM-5133"></a>
<a name="chp-6-ITERM-5134"></a>
<a name="chp-6-ITERM-5135"></a>
<a name="chp-6-ITERM-5136"></a> <a name="chp-6-ITERM-5137"></a> to the ability to read and write the
device—the ability to perform various types of hardware control
via the device driver. Most devices can perform operations beyond
simple data transfers; user space must often be able to request, for
example, that the device lock its door, eject its media, report error
information, change a baud rate, or self destruct. These operations
are usually supported via the <span class="docEmphasis">ioctl</span> method,
which implements the system call by the same name.</p>

<p class="docText">In user space, the <span class="docEmphasis">ioctl</span> system call has the
following prototype:</P>

<pre>int ioctl(int fd, unsigned long cmd, ...);</pre><br>


<p class="docText">The prototype stands out in the list of Unix system calls because of
the dots, which usually mark the function as having a variable number
of arguments. In a real system, however, a system call
can't actually have a variable number of arguments.
System calls must have a well-defined prototype, because user
programs can access them only through hardware
"gates." Therefore, the dots in the
prototype represent not a variable number of arguments but a single
optional argument, traditionally identified as <tt>char
*argp</tt>. The dots are simply there to prevent type checking
during compilation. The actual nature of the third argument depends
on the specific control command being issued (the second argument).
Some commands take no arguments, some take an integer value, and some
take a pointer to other data. Using a pointer is the way to pass
arbitrary data to the <span class="docEmphasis">ioctl</span> call; the device is
then able to exchange any amount of data with user space.</P>

<p class="docText">The unstructured nature of the <span class="docEmphasis">ioctl</span>
call<a name="chp-6-ITERM-5138"></a> has caused it to fall out of favor
among kernel developers. Each <span class="docEmphasis">ioctl</span> command is,
essentially, a separate, usually undocumented system call, and there
is no way to audit these calls in any sort of comprehensive manner.
It is also difficult to make the unstructured
<span class="docEmphasis">ioctl</span> arguments work identically on all systems;
for example, consider 64-bit systems with a user-space process
running in 32-bit mode. As a result, there is strong pressure to
implement miscellaneous control operations by just about any other
means. Possible alternatives include embedding commands into the data
stream (we will discuss this approach later in this chapter) or using
virtual filesystems, either sysfs or driver-specific filesystems. (We
will look at sysfs in <a class="docLink" href="chp-14.shtml#chp-14">Chapter 14</a>.) However, the fact remains that <span class="docEmphasis">ioctl</span> is
often the easiest and most straightforward choice for true device
operations.</P>

<p class="docText"><a name="chp-6-ITERM-5139"></a><a name="chp-6-ITERM-5140"></a>
<a name="chp-6-ITERM-5141"></a>
<a name="chp-6-ITERM-5142"></a>The <span class="docEmphasis">ioctl</span>
driver method has a prototype that differs somewhat from the
user-space version:</P>

<pre>int (*ioctl) (struct inode *inode, struct file *filp,
              unsigned int cmd, unsigned long arg);</pre><br>


<p class="docText">The <tt>inode</tt> and <tt>filp</tt> pointers are
the values corresponding to the file descriptor <tt>fd</tt>
passed on by the application and are the same parameters passed to
the <span class="docEmphasis">open</span> method. The <tt>cmd</tt>
argument is passed from the user unchanged, and the optional
<tt>arg</tt> argument is passed in the form of an
<tt>unsigned</tt> <tt>long</tt>, regardless of
whether it was given by the user as an integer or a pointer. If the
invoking program doesn't pass a third argument, the
<tt>arg</tt> value received by the driver operation is
undefined. Because type checking is disabled on the extra argument,
the compiler can't warn you if an invalid argument
is passed to <span class="docEmphasis">ioctl</span>, and any associated bug would
be difficult to spot.</p>

<p class="docText"><a name="chp-6-ITERM-5143"></a>
<a name="chp-6-ITERM-5144"></a>As you
might imagine, most <span class="docEmphasis">ioctl</span> implementations
consist of a big <tt>switch</tt> statement that selects the
correct behavior according to the <tt>cmd</tt> argument.
Different commands have different numeric values, which are usually
given symbolic names to simplify coding. The symbolic name is
assigned by a preprocessor definition. Custom drivers usually declare
such symbols in their header files; <i>scull.h</i>
declares them for <span class="docEmphasis">scull</span>. User programs must, of
course, include that header file as well to have access to those
symbols.</P>

<a name="chp-6-sect-1.1"></a>
<H4 class="docSection2Title">6.1.1. Choosing the ioctl Commands</H4>

<p class="docText">Before writing the code for <span class="docEmphasis">ioctl</span>, you
need<a name="chp-6-ITERM-5145"></a>
to choose the numbers that correspond to commands. The first instinct
of many programmers is to choose a set of small numbers starting with
or 1 and going up from there. There are, however, good reasons for
not doing things that way. The <span class="docEmphasis">ioctl</span> command
numbers should be unique across the system in order to prevent errors
caused by issuing the right command to the wrong device. Such a
mismatch is not unlikely to happen, and a program might find itself
trying to change the baud rate of a non-serial-port input stream,
such as a FIFO or an audio device. If each <span class="docEmphasis">ioctl</span>
number is unique, the application gets an <tt>EINVAL</tt>
error rather than succeeding in doing something unintended.</p>

<p class="docText"><a name="chp-6-ITERM-5146"></a><a name="chp-6-ITERM-5147"></a>To help programmers create
unique <span class="docEmphasis">ioctl</span> command codes, these codes have
been split up into several bitfields. The first versions of Linux
used 16-bit numbers: the top eight were the
"magic" numbers associated with the
device, and the bottom eight were a sequential number, unique within
the device. This happened because Linus was
"clueless" (his own word); a better
division of bitfields was conceived only later. Unfortunately, quite
a few drivers still use the old convention. They have to: changing
the command codes would break no end of binary programs, and that is
not something the kernel developers are willing to do.</P>

<p class="docText"><a name="chp-6-ITERM-5148"></a><a name="chp-6-ITERM-5149"></a><a name="chp-6-ITERM-5150"></a>To choose <span class="docEmphasis">ioctl</span>
numbers for your driver according to the Linux kernel convention, you
should first check <I>include/asm/ioctl.h</i> and
<i>Documentation/ioctl-number.txt</i>. The header
defines the bitfields you will be using: type (magic number), ordinal
number, direction of transfer, and size of argument. The
<i>ioctl-number.txt</I> file lists the magic numbers
used throughout the kernel,<sup class="docFootnote"><a class="docLink" href="chp-6-sect-1.shtml#chp-6-FNOTE-1">[1]</a></sup> so
you'll be able to choose your own magic number and
avoid overlaps. The text file also lists the reasons why the
convention should be used.</p><blockquote><p class="docFootnote"><sup><a name="chp-6-FNOTE-1">[1]</a></sup> Maintenance of this file
has been somewhat scarce as of late, however.</p></blockquote>

<p class="docText">The approved way to define <span class="docEmphasis">ioctl</span> command numbers
uses four bitfields, which have the following meanings. New symbols
introduced in this list are defined in
<I>&lt;linux/ioctl.h&gt;</i>.</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">type</span></span></span></dt></P>
<dd>
<p class="docList">The magic number. Just choose one number (after consulting
<i>ioctl-number.txt</i>) and use it throughout the
driver. This field is eight bits wide
(<tt>_IOC_TYPEBITS</tt>).</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">number</span></span></span></dt></p>
<dd>
<p class="docList">The ordinal (sequential) number. It's eight bits
(<tt>_IOC_NRBITS</tt>) wide.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">direction</span></span></span></dt></p>
<dd>
<p class="docList">The direction of data transfer, if the particular command involves a
data transfer. The possible values are <tt>_IOC_NONE</tt>
(no data transfer), <tt>_IOC_READ</tt>,
<tt>_IOC_WRITE</tt>, and
<tt>_IOC_READ|_IOC_WRITE</tt> (data is transferred both
ways). Data transfer is seen from the application's
point of view; <tt>_IOC_READ</tt> means reading
<span class="docEmphasis">from</span> the device, so the driver must write to
user space. Note that the field is a bit mask, so
<tt>_IOC_READ</tt> and <tt>_IOC_WRITE</tt> can be
extracted using a logical AND operation.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">size</span></span></span></dt></P>
<dd>
<p class="docList">The size of user data involved. The width of this field is
architecture dependent, but is usually 13 or 14 bits. You can find
its value for your specific architecture in the macro
<tt>_IOC_SIZEBITS</tt>. It's not mandatory
that you use the <tt>size</tt> field—the kernel does
not check it—but it is a good idea. Proper use of this field
can help detect user-space programming errors and enable you to
implement backward compatibility if you ever need to change the size
of the relevant data item. If you need larger data structures,
however, you can just ignore the <tt>size</tt> field.
We'll see how this field is used soon.</p>
</dd>
</dl>

<p class="docText"><a name="chp-6-ITERM-5151"></a>The header file
<I>&lt;asm/ioctl.h&gt;</I>, which is included by
<i>&lt;linux/ioctl.h&gt;</i>, defines macros that help
set up the command numbers as follows:
<tt>_IO(type,nr)</tt> (for a command that has no argument),
<tt>_IOR(type,nr,datatype)</tt> (for reading data from the
driver), <tt>_IOW(type,nr,datatype)</tt> (for writing
data), and <tt>_IOWR(type,nr,datatype)</tt> (for
bidirectional transfers). The <tt>type</tt> and
<tt>number</tt> fields are passed as arguments, and the
<tt>size</tt> field is derived by applying
<span class="docEmphasis">sizeof</span> to the <tt>datatype</tt>
argument.</p>

<p class="docText">The header also defines macros that may be used in your driver to
decode the numbers: <tt>_IOC_DIR(nr)</tt>,
<tt>_IOC_TYPE(nr)</tt>, <tt>_IOC_NR(nr)</tt>, and
<tt>_IOC_SIZE(nr)</tt>. We won't go into
any more detail about these macros because the header file is clear,
and sample code is shown later in this section.</P>

<p class="docText"><a name="chp-6-ITERM-5152"></a>Here is how some
<span class="docEmphasis">ioctl</span> commands are defined in
<span class="docEmphasis">scull</span>. In particular, these commands set and get
the driver's configurable parameters.</p>

<pre>/* Use 'k' as magic number */
#define SCULL_IOC_MAGIC  'k'
/* Please use a different 8-bit number in your code */

#define SCULL_IOCRESET    _IO(SCULL_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly with the argument value
 * G means "Get": reply by setting through a pointer
 * Q means "Query": response is on the return value
 * X means "eXchange": switch G and S atomically
 * H means "sHift": switch T and Q atomically
 */
#define SCULL_IOCSQUANTUM _IOW(SCULL_IOC_MAGIC,  1, int)
#define SCULL_IOCSQSET    _IOW(SCULL_IOC_MAGIC,  2, int)
#define SCULL_IOCTQUANTUM _IO(SCULL_IOC_MAGIC,   3)
#define SCULL_IOCTQSET    _IO(SCULL_IOC_MAGIC,   4)
#define SCULL_IOCGQUANTUM _IOR(SCULL_IOC_MAGIC,  5, int)
#define SCULL_IOCGQSET    _IOR(SCULL_IOC_MAGIC,  6, int)
#define SCULL_IOCQQUANTUM _IO(SCULL_IOC_MAGIC,   7)
#define SCULL_IOCQQSET    _IO(SCULL_IOC_MAGIC,   8)
#define SCULL_IOCXQUANTUM _IOWR(SCULL_IOC_MAGIC, 9, int)
#define SCULL_IOCXQSET    _IOWR(SCULL_IOC_MAGIC,10, int)
#define SCULL_IOCHQUANTUM _IO(SCULL_IOC_MAGIC,  11)
#define SCULL_IOCHQSET    _IO(SCULL_IOC_MAGIC,  12)

#define SCULL_IOC_MAXNR 14</pre><BR>


<p class="docText">The actual source file defines a few extra commands that have not
been shown here.</P>

<p class="docText">We chose to implement both ways of passing integer arguments: by
pointer and by explicit value (although, by an established
convention, <span class="docEmphasis">ioctl</span> should exchange values by
pointer). Similarly, both ways are used to return an integer number:
by pointer or by setting the return value. This works as long as the
return value is a positive integer; as you know by now, on return
from any system call, a positive value is preserved (as we saw for
<span class="docEmphasis">read</span> and <span class="docEmphasis">write</span>), while a
negative value is considered an error and is used to set
<tt>errno</tt> in user space.<sup class="docFootnote"><a class="docLink" href="chp-6-sect-1.shtml#chp-6-FNOTE-2">[2]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="chp-6-FNOTE-2">[2]</a></sup> Actually, all
<span class="docEmphasis">libc</span> implementations currently in use (including
uClibc) consider as error codes only values in the range -4095 to -1.
Unfortunately, being able to return large negative numbers but not
small ones is not very useful.</p></blockquote>

<p class="docText">The "exchange" and
"shift" operations are not
particularly useful for <span class="docEmphasis">scull</span>. We implemented
"exchange" to show how the driver
can combine separate operations into a single atomic one, and
"shift" to pair
"tell" and
"query." There are times when
atomic test-and-set operations like these are needed, in particular,
when applications need to set or release locks.</p>

<p class="docText">The explicit ordinal number of the command has no specific meaning.
It is used only to tell the commands apart. Actually, you could even
use the same ordinal number for a read command and a write command,
since the actual <span class="docEmphasis">ioctl</span> number is different in
the "direction" bits, but there is
no reason why you would want to do so. We chose not to use the
ordinal number of the command anywhere but in the declaration, so we
didn't assign a symbolic value to it.
That's why explicit numbers appear in the definition
given previously. The example shows one way to use the command
numbers, but you are free to do it differently.</p>

<p class="docText">With the exception of a small number of predefined commands (to be
discussed shortly), the value of the <span class="docEmphasis">ioctl</span>
<tt>cmd</tt> argument is not currently used by the kernel,
and it's quite unlikely it will be in the future.
Therefore, you could, if you were feeling lazy, avoid the complex
declarations shown earlier and explicitly declare a set of scalar
numbers. On the other hand, if you did, you wouldn't
benefit from using the bitfields, and you would encounter
difficulties if you ever submitted your code for inclusion in the
mainline kernel. The header <i>&lt;linux/kd.h&gt;</I>
is an example of this old-fashioned approach, using 16-bit scalar
values to define the <span class="docEmphasis">ioctl</span> commands. That source
file relied on scalar numbers because it used the conventions obeyed
at that time, not out of laziness. Changing it now would cause
gratuitous incompatibility.</P>


<a name="chp-6-sect-1.2"></a>
<H4 class="docSection2Title">6.1.2. The Return Value</h4>

<p class="docText">The implementation of <span class="docEmphasis">ioctl</span> is
usually<a name="chp-6-ITERM-5153"></a>
<a name="chp-6-ITERM-5154"></a> <a name="chp-6-ITERM-5155"></a>
<a name="chp-6-ITERM-5156"></a> a <tt>switch</tt>
statement based on the command number. But what should the
<tt>default</tt> selection be when the command number
doesn't match a valid operation? The question is
controversial. Several kernel functions return
<tt>-EINVAL</tt> ("Invalid
argument"), which makes sense because the command
argument is indeed not a valid one. The POSIX standard, however,
states that if an inappropriate <span class="docEmphasis">ioctl</span> command
has been issued, then <tt>-ENOTTY</tt> should be returned.
This error code is interpreted by the C library as
"inappropriate ioctl for device,"
which is usually exactly what the programmer needs to hear.
It's still pretty common, though, to return
<tt>-EINVAL</tt> in response to an invalid
<span class="docEmphasis">ioctl</span> command.</P>


<a name="chp-6-sect-1.3"></a>
<H4 class="docSection2Title">6.1.3. The Predefined Commands</h4>

<p class="docText">Although the <span class="docEmphasis">ioctl</span> system call is most often
used to act on devices, a few commands are recognized by the kernel.
Note that these commands, when applied to your device, are decoded
<span class="docEmphasis">before</span> your own file operations are called.
Thus, if you choose the same number for one of your
<span class="docEmphasis">ioctl</span> commands, you won't ever
see any request for that command, and the application gets something
<a name="chp-6-ITERM-5157"></a>unexpected
because of the conflict between the <span class="docEmphasis">ioctl</span>
numbers.</p>

<p class="docText">The predefined <a name="chp-6-ITERM-5158"></a>
<a name="chp-6-ITERM-5159"></a>commands
are divided into three groups:</p>

<ul><LI><p class="docList">Those that can be issued on any file (regular, device, FIFO, or
socket)</p></li><LI><p class="docList">Those that are issued only on regular files</p></li><LI><p class="docList">Those specific to the filesystem type</p></LI></ul>
<p class="docText">Commands in the last group are executed by the implementation of the
hosting filesystem (this is how the <span class="docEmphasis">chattr</span>
command works). Device driver writers are interested only in the
first group of commands, whose magic number is
"T." Looking at the workings of the
other groups is left to the reader as an exercise;
<span class="docEmphasis">ext2_ioctl</span> is a most interesting function (and
easier to understand than one might expect), because it implements
the append-only flag and the immutable flag.</p>

<p class="docText">The following <span class="docEmphasis">ioctl</span> commands are predefined for
any file, including device-special files:</p>

<a name="chp-6-ITERM-5160"></a><a name="chp-6-ITERM-5161"></a><a name="chp-6-ITERM-5162"></a><a name="chp-6-ITERM-5163"></a><a name="chp-6-ITERM-5164"></a><a name="chp-6-ITERM-5165"></a><a name="chp-6-ITERM-5166"></a><a name="chp-6-ITERM-5167"></a><a name="chp-6-ITERM-5168"></a><a name="chp-6-ITERM-5169"></a><a name="chp-6-ITERM-5170"></a><a name="chp-6-ITERM-5171"></a><a name="chp-6-ITERM-5172"></a><a name="chp-6-ITERM-5173"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">FIOCLEX</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5160"></a>
<a name="chp-6-ITERM-5161"></a>Set
the close-on-exec flag (File IOctl CLose on EXec). Setting this flag
causes the file descriptor to be closed when the calling process
executes a new program.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">FIONCLEX</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5162"></a>
<a name="chp-6-ITERM-5163"></a>Clear
the close-on-exec flag (File IOctl Not CLos on EXec). The command
restores the common file behavior, undoing what
<tt>FIOCLEX</tt> above does.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">FIOASYNC</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-6-ITERM-5164"></a>
<a name="chp-6-ITERM-5165"></a>Set
or reset asynchronous notification for the file (as discussed in the
<a class="docLink" href="chp-6-sect-4.shtml#chp-6-sect-4">Section 6.4</a> later in this chapter). Note that
kernel versions up to Linux 2.2.4 incorrectly used this command to
modify the <tt>O_SYNC</tt> flag. Since both actions can be
accomplished through <span class="docEmphasis">fcntl</span>, nobody actually uses
the <tt>FIOASYNC</tt> command, which is reported here only
for completeness.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">FIOQSIZE</span></span></span></dt></p>
<dd>
<p class="docList">This <a name="chp-6-ITERM-5166"></a>
<a name="chp-6-ITERM-5167"></a>command
returns the size of a file or directory; when applied to a device
file, however, it yields an <tt>ENOTTY</tt> error return.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">FIONBIO</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5168"></a>
<a name="chp-6-ITERM-5169"></a><a name="chp-6-ITERM-5170"></a><a name="chp-6-ITERM-5171"></a><a name="chp-6-ITERM-5172"></a><a name="chp-6-ITERM-5173"></a>"File IOctl Non-Blocking
I/O" (described in <a class="docLink" href="chp-6-sect-2.shtml#chp-6-sect-2.3">Section 6.2.3</a>). This call modifies the
<tt>O_NONBLOCK</tt> flag in
<tt>filp-&gt;f_flags</tt>. The third argument to the system
call is used to indicate whether the flag is to be set or cleared.
(We'll look at the role of the flag later in this
chapter.) Note that the usual way to change this flag is with the
<span class="docEmphasis">fcntl</span> system call, using the
<span class="docEmphasis">F_SETFL</span> command.</P>
</dd>
</dl>

<p class="docText">The last item in the list introduced a new system call,
<span class="docEmphasis">fcntl</span>, which looks like
<span class="docEmphasis">ioctl</span>. In fact, the <span class="docEmphasis">fcntl</span>
call is very similar to <span class="docEmphasis">ioctl</span> in that it gets a
command argument and an extra (optional) argument. It is kept
separate from <span class="docEmphasis">ioctl</span> mainly for historical
reasons: when Unix developers faced the problem of controlling I/O
operations, they decided that files and devices were different. At
the time, the only devices with <span class="docEmphasis">ioctl</span>
implementations were ttys, which explains why
<tt>-ENOTTY</tt> is the standard reply for an incorrect
<span class="docEmphasis">ioctl</span> command. Things have changed, but
<span class="docEmphasis">fcntl</span> remains a separate system call.</P>


<a name="chp-6-sect-1.4"></a>
<H4 class="docSection2Title">6.1.4. Using the ioctl Argument</h4>

<p class="docText">Another point we need to cover
<a name="chp-6-ITERM-5174"></a>before looking at the
<span class="docEmphasis">ioctl</span> code for the <span class="docEmphasis">scull</span>
driver is how to use the extra argument. If it is an integer,
it's easy: it can be used directly. If it is a
pointer, however, some care must be taken.</p>

<p class="docText">When a pointer is used to refer to user space, we must ensure that
the user address is valid. An attempt to access an unverified
user-supplied pointer can lead to incorrect behavior, a kernel oops,
system corruption, or security problems. It is the
driver's responsibility to make proper checks on
every user-space address it uses and to return an error if it is
invalid.</p>

<p class="docText"><a name="chp-6-ITERM-5175"></a>
<a name="chp-6-ITERM-5176"></a><a name="chp-6-ITERM-5177"></a><a name="chp-6-ITERM-5178"></a>In <a class="docLink" href="chp-3.shtml#chp-3">Chapter 3</a>, we looked at the
<span class="docEmphasis">copy_from_user</span> and
<span class="docEmphasis">copy_to_user</span> functions, which can be used to
safely move data to and from user space. Those functions can be used
in <span class="docEmphasis">ioctl</span> methods as well, but
<span class="docEmphasis">ioctl</span> calls often involve small data items that
can be more efficiently manipulated through other means. To start,
address verification (without transferring data) is implemented by
the function <span class="docEmphasis">access_ok</span>, which is declared in
<i>&lt;asm/uaccess.h&gt;</I>:</P>

<pre>int access_ok(int type, const void *addr, unsigned long size);</pre><BR>


<p class="docText"><a name="chp-6-ITERM-5179"></a>The first argument should be either
<tt>VERIFY_READ</tt> or <tt>VERIFY_WRITE</tt>,
depending on whether the action to be performed is reading the
user-space memory area or writing it. The <tt>addr</tt>
argument holds a user-space address, and <tt>size</tt> is a
byte count. If <span class="docEmphasis">ioctl</span>, for instance, needs to
read an integer value from user space, <tt>size</tt> is
<tt>sizeof(int)</tt>. If you need to both read and write at
the given address, use <tt>VERIFY_WRITE</tt>, since it is a
superset of <tt>VERIFY_READ</tt>.</p>

<p class="docText">Unlike most kernel functions, <span class="docEmphasis">access_ok</span> returns
a boolean value: <tt>1</tt> for success (access is OK) and
<tt>0</tt> for failure (access is not OK). If it returns
false, the driver should usually return <tt>-EFAULT</tt> to
the caller.</P>

<p class="docText">There are a couple of interesting things to note about
<span class="docEmphasis">access_ok</span>. First, it does not do the complete
job of verifying memory access; it only checks to see that the memory
reference is in a region of memory that the process might reasonably
have access to. In particular, <span class="docEmphasis">access_ok</span> ensures
that the address does not point to kernel-space memory. Second, most
driver code need not actually call <span class="docEmphasis">access_ok</span>.
The memory-access routines described later take care of that for you.
Nonetheless, we demonstrate its use so that you can see how it is
done.</P>

<p class="docText">The <span class="docEmphasis">scull</span> source exploits the bitfields in the
<span class="docEmphasis">ioctl</span> number to check the arguments before the
<tt>switch</tt>:</p>

<pre>int err = 0, tmp;
int retval = 0;
    
/*
 * extract the type and number bitfields, and don't decode
 * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok(  )
 */
 if (_IOC_TYPE(cmd) != SCULL_IOC_MAGIC) return -ENOTTY;
 if (_IOC_NR(cmd) &gt; SCULL_IOC_MAXNR) return -ENOTTY;

/*
 * the direction is a bitmask, and VERIFY_WRITE catches R/W
 * transfers. `Type' is user-oriented, while
 * access_ok is kernel-oriented, so the concept of "read" and
 * "write" is reversed
 */
if (_IOC_DIR(cmd) &amp; _IOC_READ)
    err = !access_ok(VERIFY_WRITE, (void _ _user *)arg, _IOC_SIZE(cmd));
else if (_IOC_DIR(cmd) &amp; _IOC_WRITE)
    err =  !access_ok(VERIFY_READ, (void _ _user *)arg, _IOC_SIZE(cmd));
if (err) return -EFAULT;</pre><br>


<p class="docText">After calling <span class="docEmphasis">access_ok</span>, the driver can safely
perform the actual transfer. In addition to the
<span class="docEmphasis">copy_from_user</span> and
<span class="docEmphasis">copy_to_user</span> functions, the programmer can
exploit a set of functions that are optimized for the most used data
sizes (one, two, four, and eight bytes). These functions are
described in the following list and are defined in
<i>&lt;asm/uaccess.h&gt;</i>:</P>

<a name="chp-6-ITERM-5180"></a><a name="chp-6-ITERM-5181"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">put_user(datum, ptr)</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _put_user(datum, ptr)</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-6-ITERM-5180"></a>
<a name="chp-6-ITERM-5181"></a>These
macros write the datum to user space; they are relatively fast and
should be called instead of <span class="docEmphasis">copy_to_user</span>
whenever single values are being transferred. The macros have been
written to allow the passing of any type of pointer to
<span class="docEmphasis">put_user</span>, as long as it is a user-space address.
The size of the data transfer depends on the type of the
<tt>ptr</tt> argument and is determined at compile time
using the <tt>sizeof</tt> and <tt>typeof</tt>
compiler builtins. As a result, if <tt>ptr</tt> is a char
pointer, one byte is transferred, and so on for two, four, and
possibly eight bytes.</p>
</dd>
</dl>
<p class="docText"><span class="docEmphasis">put_user</span> checks to ensure that the process is
able to write to the given memory address. It returns
<tt>0</tt> on success, and <tt>-EFAULT</tt> on
error. <span class="docEmphasis">_ _put_user</span> performs less checking (it
does not call <span class="docEmphasis">access_ok</span>), but can still fail if
the memory pointed to is not writable by the user. Thus, <span class="docEmphasis">_
_put_user</span> should only be used if the memory region has
already been verified with <span class="docEmphasis">access_ok</span>.</P>

<p class="docText">As a general rule, you call <span class="docEmphasis">_ _put_user</span> to save
a few cycles when you are implementing a <span class="docEmphasis">read</span>
method, or when you copy several items and, thus, call
<span class="docEmphasis">access_ok</span> just once before the first data
transfer, as shown above for <span class="docEmphasis">ioctl</span>.</p>

<a name="chp-6-ITERM-5182"></a><a name="chp-6-ITERM-5183"></a><a name="chp-6-ITERM-5184"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">get_user(local, ptr)</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _get_user(local, ptr)</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5182"></a>
<a name="chp-6-ITERM-5183"></a><a name="chp-6-ITERM-5184"></a>These macros are used to retrieve a
single datum from user space. They behave like
<span class="docEmphasis">put_user</span> and <span class="docEmphasis">_ _put_user</span>,
but transfer data in the opposite direction. The value retrieved is
stored in the local variable <tt>local</tt>; the return
value indicates whether the operation succeeded. Again, <span class="docEmphasis">_
_get_user</span> should only be used if the address has already
been verified with <span class="docEmphasis">access_ok</span>.</p>
</dd>
</dl>

<p class="docText">If an attempt is made to use one of the listed functions to transfer
a value that does not fit one of the specific sizes, the result is
usually a strange message from the compiler, such as
"conversion to non-scalar type
requested." In such cases,
<span class="docEmphasis">copy_to_user</span> or
<span class="docEmphasis">copy_from_user</span> must be used.</p>


<a name="chp-6-sect-1.5"></a>
<h4 class="docSection2Title">6.1.5. Capabilities and Restricted Operations</h4>

<p class="docText"><a name="chp-6-ITERM-5185"></a><a name="chp-6-ITERM-5186"></a><a name="chp-6-ITERM-5187"></a><a name="chp-6-ITERM-5188"></a><a name="chp-6-ITERM-5189"></a>Access to a device
is controlled by the permissions on the device file(s), and the
driver is not normally involved in permissions checking. There are
situations, however, where any user is granted read/write permission
on the device, but some control operations should still be denied.
For example, not all users of a tape drive should be able to set its
default block size, and a user who has been granted read/write access
to a disk device should probably still be denied the ability to
format it. In cases like these, the driver must perform additional
checks to be sure that the user is capable of performing the
requested operation.</p>

<p class="docText">Unix systems have traditionally restricted privileged operations to
the superuser account. This meant that privilege was an
all-or-nothing thing—the superuser can do absolutely anything,
but all other users are highly restricted. The Linux kernel provides
a more flexible system called <i>capabilities</I>. A
capability-based system leaves the all-or-nothing mode behind and
breaks down privileged operations into separate subgroups. In this
way, a particular user (or program) can be empowered to perform a
specific privileged operation without giving away the ability to
perform other, unrelated operations. The kernel uses capabilities
exclusively for permissions management and exports two system calls
<span class="docEmphasis">capget</span> and <span class="docEmphasis">capset</span>, to allow
them to be managed from user space.</p>

<p class="docText"><a name="chp-6-ITERM-5190"></a>
<a name="chp-6-ITERM-5191"></a>The full set of capabilities can be found
in <I>&lt;linux/capability.h&gt;</I>. These are the
only capabilities known to the system; it is not possible for driver
authors or system administrators to define new ones without modifying
the kernel source. A subset of those capabilities that might be of
interest to device driver writers includes the following:</p>

<a name="chp-6-ITERM-5192"></a><a name="chp-6-ITERM-5193"></a><a name="chp-6-ITERM-5194"></a><a name="chp-6-ITERM-5195"></a><a name="chp-6-ITERM-5196"></a><a name="chp-6-ITERM-5197"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CAP_DAC_OVERRIDE</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-6-ITERM-5192"></a>The ability to override access
restrictions (data access control, or DAC) on files and directories.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CAP_NET_ADMIN</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-6-ITERM-5193"></a>The
ability to perform network administration tasks, including those that
affect network interfaces.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CAP_SYS_MODULE</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5194"></a>The ability to load or remove kernel
modules.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CAP_SYS_RAWIO</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5195"></a>The
ability to perform "raw" I/O
operations. Examples include accessing device ports or communicating
directly with USB devices.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CAP_SYS_ADMIN</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5196"></a>A
catch-all capability that provides access to many system
administration operations.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">CAP_SYS_TTY_CONFIG</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-6-ITERM-5197"></a>The ability to perform tty
configuration tasks.</p>
</dd>
</dl>

<p class="docText"><a name="chp-6-ITERM-5198"></a>
<a name="chp-6-ITERM-5199"></a>Before
performing a privileged operation, a device driver should check that
the calling process has the appropriate capability; failure to do so
could result user processes performing unauthorized operations with
bad results on system stability or security. Capability checks are
performed with the <span class="docEmphasis">capable</span> function (defined in
<I>&lt;linux/sched.h&gt;</i>):</p>

<pre> int capable(int capability);</pre><BR>


<p class="docText">In the <span class="docEmphasis">scull</span> sample driver, any user is allowed
to query the quantum and quantum set sizes. Only privileged users,
however, may change those values, since inappropriate values could
badly affect system performance. When needed, the
<span class="docEmphasis">scull</span> implementation of
<span class="docEmphasis">ioctl</span> checks a user's privilege
level as follows:</p>

<pre> if (! capable (CAP_SYS_ADMIN))
        return -EPERM;</pre><BR>


<p class="docText">In the absence of a more specific capability for this task,
<tt>CAP_SYS_ADMIN</tt> was chosen for this test.</p>


<a name="chp-6-sect-1.6"></a>
<h4 class="docSection2Title">6.1.6. The Implementation of the ioctl Commands</h4>

<p class="docText">The <span class="docEmphasis">scull</span> implementation
<a name="chp-6-ITERM-5200"></a>
<a name="chp-6-ITERM-5201"></a>of <span class="docEmphasis">ioctl</span> only
transfers the configurable parameters of the device and turns out to
be as easy as the following:</p>

<pre>switch(cmd) {

  case SCULL_IOCRESET:
    scull_quantum = SCULL_QUANTUM;
    scull_qset = SCULL_QSET;
    break;
    
  case SCULL_IOCSQUANTUM: /* Set: arg points to the value */
    if (! capable (CAP_SYS_ADMIN))
        return -EPERM;
    retval = _ _get_user(scull_quantum, (int _ _user *)arg);
    break;

  case SCULL_IOCTQUANTUM: /* Tell: arg is the value */
    if (! capable (CAP_SYS_ADMIN))
        return -EPERM;
    scull_quantum = arg;
    break;

  case SCULL_IOCGQUANTUM: /* Get: arg is pointer to result */
    retval = _ _put_user(scull_quantum, (int _ _user *)arg);
    break;

  case SCULL_IOCQQUANTUM: /* Query: return it (it's positive) */
    return scull_quantum;

  case SCULL_IOCXQUANTUM: /* eXchange: use arg as pointer */
    if (! capable (CAP_SYS_ADMIN))
        return -EPERM;
    tmp = scull_quantum;
    retval = _ _get_user(scull_quantum, (int _ _user *)arg);
    if (retval =  = 0)
        retval = _ _put_user(tmp, (int _ _user *)arg);
    break;

  case SCULL_IOCHQUANTUM: /* sHift: like Tell + Query */
    if (! capable (CAP_SYS_ADMIN))
        return -EPERM;
    tmp = scull_quantum;
    scull_quantum = arg;
    return tmp;

  default:  /* redundant, as cmd was checked against MAXNR */
    return -ENOTTY;
}
return retval;</pre><br>


<p class="docText"><span class="docEmphasis">scull</span> also includes six entries that act on
<tt>scull_qset</tt>. These entries are identical to the
ones for <tt>scull_quantum</tt> and are not worth showing
in print.</p>

<p class="docText">The six ways to pass and receive arguments look like the following
from the caller's point of view (i.e., from user
space):</p>

<pre>int quantum;

ioctl(fd,SCULL_IOCSQUANTUM, &amp;quantum);          /* Set by pointer */
ioctl(fd,SCULL_IOCTQUANTUM, quantum);           /* Set by value */

ioctl(fd,SCULL_IOCGQUANTUM, &amp;quantum);          /* Get by pointer */
quantum = ioctl(fd,SCULL_IOCQQUANTUM);          /* Get by return value */

ioctl(fd,SCULL_IOCXQUANTUM, &amp;quantum);          /* Exchange by pointer */
quantum = ioctl(fd,SCULL_IOCHQUANTUM, quantum); /* Exchange by value */</pre><br>


<p class="docText">Of course, a normal driver would not implement such a mix of calling
modes. We have done so here only to demonstrate the different ways in
which things could be done. Normally, however, data exchanges would
be consistently performed, either through pointers or by value, and
mixing of the two techniques would be avoided.</p>


<a name="chp-6-sect-1.7"></a>
<h4 class="docSection2Title">6.1.7. Device Control Without ioctl</h4>

<p class="docText"><a name="chp-6-ITERM-5202"></a><a name="chp-6-ITERM-5203"></a><a name="chp-6-ITERM-5204"></a><a name="chp-6-ITERM-5205"></a><a name="chp-6-ITERM-5206"></a><a name="chp-6-ITERM-5207"></a>Sometimes
controlling the device is better accomplished by writing control
sequences to the device itself. For example, this technique is used
in the console driver, where so-called escape sequences are used to
move the cursor, change the default color, or perform other
configuration tasks. The benefit of implementing device control this
way is that the user can control the device just by writing data,
without needing to use (or sometimes write) programs built just for
configuring the device. When devices can be controlled in this
manner, the program issuing commands often need not even be running
on the same system as the device it is controlling.</p>

<p class="docText"><a name="chp-6-ITERM-5208"></a>
<a name="chp-6-ITERM-5209"></a>For
example, the <span class="docEmphasis">setterm</span> program acts on the console
(or another terminal) configuration by printing escape sequences. The
controlling program can live on a different computer from the
controlled device, because a simple redirection of the data stream
does the configuration job. This is what happens every time you run a
remote tty session: escape sequences are printed remotely but affect
the local tty; the technique is not restricted to ttys, though.</p>

<p class="docText"><a name="chp-6-ITERM-5210"></a><a name="chp-6-ITERM-5211"></a><a name="chp-6-ITERM-5212"></a><a name="chp-6-ITERM-5213"></a><a name="chp-6-ITERM-5214"></a>The drawback of
controlling by printing is that it adds policy constraints to the
device; for example, it is viable only if you are sure that the
control sequence can't appear in the data being
written to the device during normal operation. This is only partly
true for ttys. Although a text display is meant to display only ASCII
characters, sometimes control characters can slip through in the data
being written and can, therefore, affect the console setup. This can
happen, for example, when you <span class="docEmphasis">cat</span> a binary file
to the screen; the resulting mess can contain anything, and you often
end up with the wrong font on your console.</P>

<p class="docText">Controlling by write <span class="docEmphasis">is</span> definitely the way to go
for those devices that don't transfer data but just
respond to commands, such as robotic devices.</p>

<p class="docText">For instance, a driver written for fun by one of your authors moves a
camera on two axes. In this driver, the
"device" is simply a pair of old
stepper motors, which can't really be read from or
written to. The concept of "sending a data
stream" to a stepper motor makes little or no sense.
In this case, the driver interprets what is being written as ASCII
commands and converts the requests to sequences of impulses that
manipulate the stepper motors. The idea is similar, somewhat, to the
AT commands you send to the modem in order to set up communication,
the main difference being that the serial port used to communicate
with the modem must transfer real data as well. The advantage of
direct device control is that you can use <span class="docEmphasis">cat</span> to
move the camera without writing and compiling special code to issue
the <span class="docEmphasis">ioctl</span> calls.</P>

<p class="docText">When writing command-oriented drivers, there's no
reason to implement the <span class="docEmphasis">ioctl</span> method. An
additional command in the interpreter is easier to implement and use.</P>

<p class="docText">Sometimes, though, you might choose to act the other way around:
instead of turning the <span class="docEmphasis">write</span> method into an
interpreter and avoiding <span class="docEmphasis">ioctl</span>, you might choose
to avoid <span class="docEmphasis">write</span> altogether and use
<span class="docEmphasis">ioctl</span> commands exclusively, while accompanying
the driver with a specific command-line tool to send those commands
to the driver. This approach moves the complexity from kernel space
to user space, where it may be easier to deal with, and helps keep
the driver small while denying<a name="chp-6-ITERM-5215"></a> <a name="chp-6-ITERM-5216"></a> <a name="chp-6-ITERM-5217"></a> <a name="chp-6-ITERM-5218"></a> <a name="chp-6-ITERM-5219"></a> use of simple
<span class="docEmphasis">cat</span> or <span class="docEmphasis">echo</span> commands.</p>



<ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-6-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
