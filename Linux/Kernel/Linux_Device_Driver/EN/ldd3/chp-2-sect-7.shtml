<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>2.7. Initialization and Shutdown</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-2-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-2-sect-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-2-sect-7"></a>
<h3 class="docSection1Title">2.7. Initialization and Shutdown</H3>

<p class="docText">As already mentioned, the module<a name="chp-2-ITERM-4252"></a>
<a name="chp-2-ITERM-4253"></a>
<a name="chp-2-ITERM-4254"></a>
initialization function
<a name="chp-2-ITERM-4255"></a>registers any
facility offered by the module. By <span class="docEmphasis">facility</span>, we
mean a new functionality, be it a whole driver or a new software
abstraction, that can be accessed by an application. The actual
definition of the initialization function always looks like:</p>

<pre>static int _ _init initialization_function(void)
{
    /* Initialization code here */
}
module_init(initialization_function);</pre><br>


<p class="docText">Initialization functions should be declared
<tt>static</tt>, since they are not meant to be visible
outside the specific file; there is no hard rule about this, though,
as no function is exported to the rest of the kernel unless
explicitly requested. The <tt>_ _init</tt> token in the
definition may look a little strange; it is a hint to the kernel that
the given function is used only at initialization time. The module
loader drops the initialization function after the module is loaded,
making its memory available for other uses. There is a similar tag
(<tt>_ _initdata</tt>) for data used only during
initialization. Use of <tt>_ _init</tt> and <tt>_
_initdata</tt> is optional, but it is worth the trouble. Just be
sure not to use them for any function (or data structure) you will be
using after initialization completes. You may also encounter
<tt>_ _devinit</tt> and <tt>_ _devinitdata</tt>
in the kernel source; these translate to <tt>_ _init</tt>
and <tt>_ _initdata</tt> only if the kernel has not been
configured for hotpluggable devices. We will look at hotplug support
in <a class="docLink" href="chp-14.shtml#chp-14">Chapter 14</a>.</P>

<p class="docText">The use of
<span class="docEmphasis">module_init</span><a name="chp-2-ITERM-4256"></a>
<a name="chp-2-ITERM-4257"></a>
is mandatory. This macro adds a special section to the
module's object code stating where the
module's initialization function is to be found.
Without this definition, your initialization function is never
called.</p>

<p class="docText">Modules can register many different types of facilities, including
different kinds of devices, filesystems, cryptographic transforms,
and more. For each facility, there is a specific kernel function that
accomplishes this registration. The arguments passed to the kernel
registration functions are usually pointers to data structures
describing the new facility and the name of the facility being
registered. The data structure usually contains pointers to module
functions, which is how functions in the module body get called.</P>

<p class="docText">The items that can be registered go beyond the list of device types
mentioned in <a class="docLink" href="chp-1.shtml#chp-1">Chapter 1</a>. They
include, among others, serial ports, miscellaneous devices, sysfs
entries, <i>/proc</i> files, executable domains, and
line disciplines. Many of those registrable items support functions
that aren't directly related to hardware but remain
in the "software abstractions"
field. Those items can be registered, because they are integrated
into the driver's functionality anyway (like
<i>/proc</i> files and line disciplines for example).</p>

<p class="docText"><a name="chp-2-ITERM-4258"></a><a name="chp-2-ITERM-4259"></a>
<a name="chp-2-ITERM-4260"></a>There
are other facilities that can be registered as add-ons for certain
drivers, but their use is so specific that it's not
worth talking about them; they use the stacking technique, as
described in <a class="docLink" href="chp-2-sect-5.shtml#chp-2-sect-5">Section 2.5</a>. If you want to probe further, you can
grep for <tt>EXPORT_SYMBOL</tt> in the kernel sources, and
find the entry points offered by different drivers. Most registration
functions are prefixed with <tt>register_</tt>, so another
possible way to find them is to grep for <tt>register_</tt>
in the kernel source.</p>

<a name="chp-2-sect-7.1"></a>
<h4 class="docSection2Title">2.7.1. The Cleanup Function</h4>

<p class="docText">Every nontrivial module also requires a cleanup function, which
<a name="chp-2-ITERM-4261"></a>
<a name="chp-2-ITERM-4262"></a>unregisters interfaces and returns
all resources to the system before the module is removed. This
function is defined as:</p>

<pre>static void _ _exit cleanup_function(void)
{
    /* Cleanup code here */
}

module_exit(cleanup_function);</pre><br>


<p class="docText">The <a name="chp-2-ITERM-4263"></a>
<a name="chp-2-ITERM-4264"></a>cleanup
function has no value to return, so it is declared
<tt>void</tt>. The <tt>_ _exit</tt> modifier
marks the code as being for module unload only (by causing the
compiler to place it in a special ELF section). If your module is
built directly into the kernel, or if your kernel is configured to
disallow the unloading of modules, functions marked <tt>_
_exit</tt> are simply discarded. For this reason, a function
marked <tt>_ _exit</tt> can be called <span class="docEmphasis">only</span>
at module unload or system shutdown time; any other use is
an error. Once again, the <span class="docEmphasis">module_exit</span>
declaration is necessary to enable to kernel to find your cleanup
function.</p>

<p class="docText">If your module does not define a cleanup function, the kernel does
not allow it to be unloaded.</p>


<a name="chp-2-sect-7.2"></a>
<h4 class="docSection2Title">2.7.2. Error Handling During Initialization</H4>

<p class="docText">One thing you must always <a name="chp-2-ITERM-4265"></a>bear in mind when registering
facilities with the kernel is that the registration could fail. Even
the simplest action often requires memory allocation, and the
required memory may not be available. So module code must always
check return values, and be sure that the requested operations have
actually succeeded.</p>

<p class="docText">If any errors occur when you register utilities, the first order of
business is to decide whether the module can continue initializing
itself anyway. Often, the module can continue to operate after a
registration failure, with degraded functionality if necessary.
Whenever possible, your module should press forward and provide what
capabilities it can after things fail.</P>

<p class="docText">If it turns out that your module simply cannot load after a
particular type of failure, you must undo any registration activities
performed before the failure. <a name="chp-2-ITERM-4266"></a>Linux doesn't keep a
per-module registry of facilities that have been registered, so the
module must back out of everything itself if initialization fails at
some point. If you ever fail to unregister what you obtained, the
kernel is left in an unstable state; it contains internal pointers to
code that no longer exists. In such situations, the only recourse,
usually, is to reboot the system. You really do want to take care to
do the right thing when an initialization error occurs.</P>

<p class="docText"><a name="chp-2-ITERM-4267"></a>Error
recovery is sometimes <a name="chp-2-ITERM-4268"></a> <a name="chp-2-ITERM-4269"></a>
<a name="chp-2-ITERM-4270"></a>best
handled with the <tt>goto</tt> statement. We normally hate
to use <tt>goto</tt>, but in our opinion, this is one
situation where it is useful. Careful use of <tt>goto</tt>
in error situations can eliminate a great deal of complicated,
highly-indented, "structured"
logic. Thus, in the kernel, <tt>goto</tt> is often used as
shown here to deal with errors.</p>

<p class="docText">The following sample code (using fictitious registration and
unregistration functions) behaves correctly if initialization fails
at any point:</p>

<pre>int _ _init my_init_function(void)
{
    int err;

    /* registration takes a pointer and a name */
    err = register_this(ptr1, "skull");
    if (err) goto fail_this;
    err = register_that(ptr2, "skull");
    if (err) goto fail_that;
    err = register_those(ptr3, "skull");
    if (err) goto fail_those;

    return 0; /* success */

  fail_those: unregister_that(ptr2, "skull");
  fail_that: unregister_this(ptr1, "skull");
  fail_this: return err; /* propagate the error */
 }</pre><br>


<p class="docText">This code attempts to register three (fictitious) facilities. The
<tt>goto</tt> statement is used in case of failure to cause
the unregistration of only the facilities that had been successfully
registered before things went bad.</P>

<p class="docText"><a name="chp-2-ITERM-4271"></a><a name="chp-2-ITERM-4272"></a>Another option, requiring no hairy
<tt>goto</tt> statements, is keeping track of what has been
successfully registered and calling
<a name="chp-2-ITERM-4273"></a>
<a name="chp-2-ITERM-4274"></a>your
module's cleanup function in case of any error. The
cleanup function unrolls only the steps that have been successfully
accomplished. This alternative, however, requires more code and more
CPU time, so in fast paths you still resort to
<tt>goto</tt> as the best error-recovery tool.</p>

<p class="docText">The return value<a name="chp-2-ITERM-4275"></a> of
<span class="docEmphasis">my_init_function</span>, <tt>err</tt>, is an
error code. In the Linux kernel, error codes are negative numbers
belonging to the set defined in
<I>&lt;linux/errno.h&gt;</I>. If you want to generate
your own error codes instead of returning what you get from other
functions, you should include
<I>&lt;linux/errno.h&gt;</i> in order to use symbolic
values such as <tt>-ENODEV</tt>,
<tt>-ENOMEM</tt>, and so on. It is always good practice to
return appropriate error codes, because user programs can turn them
to meaningful strings using <span class="docEmphasis">perror</span> or similar
means.</p>

<p class="docText">Obviously, the module cleanup function must undo any registration
performed by the initialization function, and it is customary (but
not usually mandatory) to unregister facilities in the reverse order
used to register them:</p>

<pre>void _ _exit my_cleanup_function(void)
{
    unregister_those(ptr3, "skull");
    unregister_that(ptr2, "skull");
    unregister_this(ptr1, "skull");
    return;
}</pre><br>


<p class="docText">If your initialization and cleanup are more complex than dealing with
a few items, the <tt>goto</tt> approach may become
difficult to manage, because all the cleanup code must be repeated
within the initialization function, with several labels intermixed.
Sometimes, therefore, a different layout of the code proves more
successful.</P>

<p class="docText">What you'd do to minimize code duplication and keep
everything streamlined is to call the cleanup function from within
the initialization whenever an error occurs. The cleanup function
then must check the status of each item before undoing its
registration. In its simplest form, the code looks like the
following:</P>

<pre>struct something *item1;
struct somethingelse *item2;
int stuff_ok;

void my_cleanup(void)
{
    if (item1)
        release_thing(item1);
    if (item2)
        release_thing2(item2);
    if (stuff_ok)
        unregister_stuff(  );
    return;
 }

int _ _init my_init(void)
{
    int err = -ENOMEM;

    item1 = allocate_thing(arguments);
    item2 = allocate_thing2(arguments2);
    if (!item2 || !item2)
        goto fail;
    err = register_stuff(item1, item2);
    if (!err)
        stuff_ok = 1;
    else
        goto fail;
    return 0; /* success */ 
   
  fail:
    my_cleanup(  );
    return err;
}</pre><BR>


<p class="docText">As shown in this code, you may or may not need external flags to mark
success of the initialization step, depending on the semantics of the
registration/allocation function you call. Whether or not flags are
needed, this kind of initialization scales well to a large number of
items and is often better than the technique shown earlier. Note,
however, that the cleanup function cannot be marked <tt>_
_exit</tt> when it is called by nonexit code, as in the previous
example.</p>


<a name="chp-2-sect-7.3"></a>
<H4 class="docSection2Title">2.7.3. Module-Loading Races</H4>

<p class="docText">Thus far, our discussion has
skated<a name="chp-2-ITERM-4276"></a>
<a name="chp-2-ITERM-4277"></a>
<a name="chp-2-ITERM-4278"></a>
<a name="chp-2-ITERM-4279"></a> over an important aspect of module
loading: race conditions. If you are not careful in how you write
your initialization function, you can create situations that can
compromise the stability of the system as a whole. We will discuss
race conditions later in this book; for now, a couple of quick points
will have to suffice.</p>

<p class="docText">The first is that you should always
remember<a name="chp-2-ITERM-4280"></a> that some other part of
the kernel can make use of any facility you register immediately
after that registration has completed. It is entirely possible, in
other words, that the kernel will make calls into your module while
your initialization function is still running. So your code must be
prepared to be called as soon as it completes its first registration.
Do not register any facility until all of your internal
initialization needed to support that facility has been completed.</p>

<p class="docText">You must also consider what happens if your initialization function
decides to fail, but some part of the kernel is already making use of
a facility your module has registered. If this situation is possible
for your module, you should seriously consider not failing the
initialization at all. After all, the module has clearly succeeded in
exporting something useful. If initialization must fail, it must
carefully step around any possible operations going on elsewhere in
the <a name="chp-2-ITERM-4281"></a>
<a name="chp-2-ITERM-4282"></a>
<a name="chp-2-ITERM-4283"></a>kernel
until those operations have completed.</p>



<ul></UL></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-2-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-2-sect-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
