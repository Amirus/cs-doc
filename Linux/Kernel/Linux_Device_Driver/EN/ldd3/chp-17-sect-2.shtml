<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>17.2. Connecting to the Kernel</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-17-sect-2"></a>
<h3 class="docSection1Title">17.2. Connecting to the Kernel</H3>

<p class="docText">We start looking at the<a name="chp-17-ITERM-7500"></a> <a name="chp-17-ITERM-7501"></a> <a name="chp-17-ITERM-7502"></a> <a name="chp-17-ITERM-7503"></a> structure of network
drivers by dissecting the <span class="docEmphasis">snull</span> source. Keeping
the source code for several drivers handy might help you follow the
discussion and to see how real-world Linux network drivers operate.
As a place to start, we suggest <i>loopback.c</i>,
<I>plip.c</i>, and <I>e100.c</i>, in
order of increasing complexity. All these files live in
<i>drivers/net</i>, within the kernel source tree.</p>

<a name="chp-17-sect-2.1"></a>
<h4 class="docSection2Title">17.2.1. Device Registration</h4>

<p class="docText">When a driver module is loaded into
a<a name="chp-17-ITERM-7504"></a>
<a name="chp-17-ITERM-7505"></a>
running kernel, it requests resources and offers facilities;
there's nothing new in that. And
there's also nothing new in the way resources are
requested. The driver should probe for its device and its hardware
location (I/O ports and IRQ line)—but not register
them—as described in <a class="docLink" href="chp-10-sect-2.shtml#chp-10-sect-2">Section 10.2</a>.
The way a network driver
is registered by its module initialization function is different from
char and block drivers. Since there is no equivalent of major and
minor numbers for network interfaces, a network driver does not
request such a number. Instead, the driver inserts a data structure
for each newly detected interface into a global list of network
devices.</p>

<p class="docText"><a name="chp-17-ITERM-7506"></a>
<a name="chp-17-ITERM-7507"></a>Each
interface is described by a <tt>struct net_device</tt>
item, which is defined in
<span class="docEmphasis">&lt;linux/netdevice.h&gt;</span>. The
<span class="docEmphasis">snull</span> driver keeps pointers to two of these
structures (for <tt>sn0</tt> and <tt>sn1</tt>) in
a simple array:</p>

<pre>struct net_device *snull_devs[2];</pre><br>


<p class="docText">The <tt>net_device</tt> structure, like many other kernel
structures, contains a kobject and is, therefore, reference-counted
and exported via sysfs. As with other such structures, it must be
allocated dynamically. The kernel function provided to perform this
allocation is <span class="docEmphasis">alloc_netdev</span>, which has the
following prototype:</p>

<pre>struct net_device *alloc_netdev(int sizeof_priv, 
                                const char *name,
                                void (*setup)(struct net_device *));</pre><br>


<p class="docText">Here, <tt>sizeof_priv</tt> is the size of the
driver's "private
data" area; with network devices, that area is
allocated along with the <tt>net_device</tt> structure. In
fact, the two are allocated together in one large chunk of memory,
but driver authors should pretend that they don't
know that. <tt>name</tt> is the name of this interface, as
is seen by user space; this name can have a
<span class="docEmphasis">printf</span>-style <tt>%d</tt> in it. The
kernel replaces the <tt>%d</tt> with the next available
interface number. Finally, <tt>setup</tt> is a pointer to
an initialization function that is called to set up the rest of
the<a name="chp-17-ITERM-7508"></a> <tt>net_device</tt>
structure. We get to the initialization function shortly, but, for
now, suffice it to say that <span class="docEmphasis">snull</span> allocates its
two <a name="chp-17-ITERM-7509"></a>device structures in
this way:</p>

<pre>snull_devs[0] = alloc_netdev(sizeof(struct snull_priv), "sn%d",
        snull_init);
snull_devs[1] = alloc_netdev(sizeof(struct snull_priv), "sn%d",
        snull_init);
if (snull_devs[0] =  = NULL || snull_devs[1] =  = NULL)
    goto out;</pre><br>


<p class="docText">As always, we must check the return value to ensure that the
allocation succeeded.</P>

<p class="docText">The networking subsystem provides a number of helper functions
wrapped around <span class="docEmphasis">alloc_netdev</span> for various types of
interfaces. The most common is <span class="docEmphasis">alloc_etherdev</span>,
which is defined in <span class="docEmphasis">&lt;linux/etherdevice.h&gt;</span>:</p>

<pre>struct net_device *alloc_etherdev(int sizeof_priv);</pre><BR>


<p class="docText">This function allocates a network device using
<tt>eth%d</tt> for the name argument. It provides its own
initialization function (<span class="docEmphasis">ether_setup</span>) that sets
several <tt>net_device</tt> fields with appropriate values
for Ethernet devices. Thus, there is no driver-supplied
initialization function for <span class="docEmphasis">alloc_etherdev</span>; the
driver should simply do its required initialization directly after a
successful allocation. Writers of drivers for other types of devices
may want to take advantage of one of the other helper functions, such
as <span class="docEmphasis">alloc_fcdev</span> (defined in
<span class="docEmphasis">&lt;linux/fcdevice.h&gt;</span>) for fiber-channel
devices, <span class="docEmphasis">alloc_fddidev</span>
(<span class="docEmphasis">&lt;linux/fddidevice.h&gt;</span>) for FDDI devices,
or <span class="docEmphasis">alloc_trdev</span>
(<span class="docEmphasis">&lt;linux/trdevice.h&gt;</span>) for token ring
devices.</P>

<p class="docText"><span class="docEmphasis">snull</span> could use
<span class="docEmphasis">alloc_etherdev</span> without trouble; we chose to use
<span class="docEmphasis">alloc_netdev</span> instead, as a way of demonstrating
the lower-level interface and to give us control over the name
assigned to the interface.</p>

<p class="docText">Once the <tt>net_device</tt>
structure<a name="chp-17-ITERM-7510"></a> has been initialized, completing
the process is just a matter of passing the structure to
<span class="docEmphasis">register_netdev</span>. In <span class="docEmphasis">snull</span>,
the call looks as follows:</p>

<pre>for (i = 0; i &lt; 2;  i++)
    if ((result = register_netdev(snull_devs[i])))
        printk("snull: error %i registering device \"%s\"\n",
                result, snull_devs[i]-&gt;name);</pre><br>


<p class="docText">The usual cautions apply here: as soon as you call
<span class="docEmphasis">register_netdev</span>, your driver may be called to
operate on the device. Thus, you should not register the device until
everything has been completely initialized.</P>


<a name="chp-17-sect-2.2"></a>
<h4 class="docSection2Title">17.2.2. Initializing Each Device</H4>

<p class="docText">We have looked at the
allocation<a name="chp-17-ITERM-7511"></a>
<a name="chp-17-ITERM-7512"></a>
and registration of <tt>net_device</tt> structures, but we
passed over the intermediate step of completely initializing that
structure. Note that <tt>struct net_device</tt> is always
put together at runtime; it cannot be set up at compile time in the
same manner as a <tt>file_operations</tt> or
<tt>block_device_operations</tt> structure. This
initialization must be complete before
calling<a name="chp-17-ITERM-7513"></a>
<a name="chp-17-ITERM-7514"></a>
<span class="docEmphasis">register_netdev</span>. The
<tt>net_device</tt> structure is large and complicated;
fortunately, the kernel takes care of some Ethernet-wide defaults
through the
<span class="docEmphasis">ether_setup</span><a name="chp-17-ITERM-7515"></a>
<a name="chp-17-ITERM-7516"></a>
function (which is called by <span class="docEmphasis">alloc_etherdev</span>).</P>

<p class="docText">Since <span class="docEmphasis">snull</span> uses
<span class="docEmphasis">alloc_netdev</span><a name="chp-17-ITERM-7517"></a>
<a name="chp-17-ITERM-7518"></a>,
it has a separate initialization function. The core of this function
(<span class="docEmphasis">snull_init</span>) is as follows:</P>

<pre>ether_setup(dev); /* assign some of the fields */

dev-&gt;open            = snull_open;
dev-&gt;stop            = snull_release;
dev-&gt;set_config      = snull_config;
dev-&gt;hard_start_xmit = snull_tx;
dev-&gt;do_ioctl        = snull_ioctl;
dev-&gt;get_stats       = snull_stats;
dev-&gt;rebuild_header  = snull_rebuild_header;
dev-&gt;hard_header     = snull_header;
dev-&gt;tx_timeout      = snull_tx_timeout;
dev-&gt;watchdog_timeo = timeout;
/* keep the default flags, just add NOARP */
dev-&gt;flags           |= IFF_NOARP;
dev-&gt;features        |= NETIF_F_NO_CSUM;
dev-&gt;hard_header_cache = NULL;      /* Disable caching */</pre><br>


<p class="docText"><a name="chp-17-ITERM-7519"></a>
<a name="chp-17-ITERM-7520"></a><a name="chp-17-ITERM-7521"></a>The above code is a fairly routine
initialization of the <tt>net_device</tt> structure; it is
mostly a matter of storing pointers to our various driver functions.
The single unusual feature of the code is setting
<tt>IFF_NOARP</tt> in the flags. This specifies that the
interface cannot use the <a name="chp-17-ITERM-7522"></a>Address Resolution Protocol (ARP). ARP
is a low-level Ethernet protocol; its job is to turn IP addresses
into Ethernet <a name="chp-17-ITERM-7523"></a>
<a name="chp-17-ITERM-7524"></a>medium
access control (MAC) addresses. Since the
"remote" systems simulated by
<span class="docEmphasis">snull</span> do not really exist, there is nobody
available to answer ARP requests for them. Rather than complicate
<span class="docEmphasis">snull</span> with the addition of an ARP
implementation, we chose to mark the interface as being unable to
handle that protocol. The assignment to
<tt>hard_header_cache</tt> is there for a similar reason:
it disables the caching of the (nonexistent) ARP replies on this
interface. This topic is discussed in detail in <a class="docLink" href="chp-17-sect-11.shtml#chp-17-sect-11">Section 17.11</a> later in this chapter.</p>

<p class="docText"><a name="chp-17-ITERM-7525"></a><a name="chp-17-ITERM-7526"></a>The initialization code also sets a
couple of fields (<tt>tx_timeout</tt> and
<tt>watchdog_timeo</tt>) that relate to the handling of
transmission timeouts. We cover this topic thoroughly in the section
<a class="docLink" href="chp-17-sect-5.shtml#chp-17-sect-5.2">Section 17.5.2</a>.</p>

<p class="docText"><a name="chp-17-ITERM-7527"></a>We look now
at one more <tt>struct net_device</tt> field,
<tt>priv</tt>. Its role is similar to that of the
<tt>private_data</tt> pointer that we used for char
drivers. Unlike <tt>fops-&gt;private_data</tt>, this
<tt>priv</tt> pointer is allocated along with the
<tt>net_device</tt> structure. Direct access to the
<tt>priv</tt> field is also discouraged, for performance
and flexibility reasons. When a driver needs to get access to the
private data pointer, it should use the <span class="docEmphasis">netdev_priv</span>
function. Thus, the <span class="docEmphasis">snull</span> driver is
full of declarations such as:</p>

<pre>struct snull_priv *priv = netdev_priv(dev);</pre><BR>


<p class="docText">The <span class="docEmphasis">snull</span> module declares a
<tt>snull_priv</tt> data structure to be used for
<tt>priv</tt>:</P>

<pre>struct snull_priv {
    struct net_device_stats stats;
    int status;
    struct snull_packet *ppool;
    struct snull_packet *rx_queue;  /* List of incoming packets */
    int rx_int_enabled;
    int tx_packetlen;
    u8 *tx_packetdata;
    struct sk_buff *skb;
    spinlock_t lock;
};</pre><BR>


<p class="docText"><a name="chp-17-ITERM-7528"></a>
<a name="chp-17-ITERM-7529"></a>The
structure includes, among other things, an instance of
<tt>struct</tt> <tt>net_device_stats</tt>, which
is the standard place to hold interface statistics. The following
lines in <span class="docEmphasis">snull_init</span> allocate and initialize
<tt>dev-&gt;priv</tt>:</p>

<pre>priv = netdev_priv(dev);
memset(priv, 0, sizeof(struct snull_priv));
spin_lock_init(&amp;priv-&gt;lock);
snull_rx_ints(dev, 1);      /* enable receive interrupts */</pre><BR>



<a name="chp-17-sect-2.3"></a>
<H4 class="docSection2Title">17.2.3. Module Unloading</h4>

<p class="docText">Nothing special happens
<a name="chp-17-ITERM-7530"></a>
<a name="chp-17-ITERM-7531"></a>when
the module is unloaded. The module cleanup function simply
unregisters the interfaces, performs whatever internal cleanup is
required, and releases the <tt>net_device</tt> structure
back to the system:</p>

<pre>void snull_cleanup(void)
{
    int i;
    
    for (i = 0; i &lt; 2;  i++) {
        if (snull_devs[i]) {
            unregister_netdev(snull_devs[i]);
            snull_teardown_pool(snull_devs[i]);
            free_netdev(snull_devs[i]);
        }
    }
    return;
}</pre><br>


<p class="docText">The call to
<span class="docEmphasis">unregister_netdev</span><a name="chp-17-ITERM-7532"></a>
<a name="chp-17-ITERM-7533"></a>
removes the interface from the system;
<span class="docEmphasis">free_netdev</span> returns the
<tt>net_device</tt> structure to the kernel. If a reference
to that structure exists somewhere, it may continue to exist, but
your driver need not care about that. Once you have unregistered the
interface, the kernel no longer calls its methods.</p>

<p class="docText">Note that our internal cleanup (done in
<span class="docEmphasis">snull_teardown_pool</span>) cannot happen until the
device has been unregistered. It must, however, happen before we
return the <tt>net_device</tt> structure to the system;
once we have called
<span class="docEmphasis">free_netdev</span><a name="chp-17-ITERM-7534"></a>
<a name="chp-17-ITERM-7535"></a>,
we cannot make any further references to the device or our private
area.</P>



<ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
