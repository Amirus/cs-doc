<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>7.7. Quick Reference</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-7-sect-7"></a>
<h3 class="docSection1Title">7.7. Quick Reference</h3>

<p class="docText">This chapter introduced the following symbols.</p>

<a name="chp-7-sect-7.1"></a>
<H4 class="docSection2Title">7.7.1. Timekeeping</h4>

<a name="chp-7-ITERM-5629"></a><a name="chp-7-ITERM-5630"></a><a name="chp-7-ITERM-5631"></a><a name="chp-7-ITERM-5632"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/param.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">HZ</span></span></span></dt></p>
<dd>
<p class="docList">The <tt>HZ</tt> symbol specifies the number
<a name="chp-7-ITERM-5629"></a>
<a name="chp-7-ITERM-5630"></a>of clock ticks
generated per second.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/jiffies.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">volatile unsigned long jiffies</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">u64 jiffies_64</span></span></span></dt></p>
<dd>
<p class="docList">The <tt>jiffies_64</tt> variable
is<a name="chp-7-ITERM-5631"></a> incremented
<a name="chp-7-ITERM-5632"></a>once for each clock tick;
thus, it's incremented <tt>HZ</tt> times
per second. Kernel code most often refers to
<tt>jiffies</tt>, which is the same as
<tt>jiffies_64</tt> on 64-bit platforms and the least
significant half of it on 32-bit platforms.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int time_after(unsigned long a, unsigned long b);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int time_before(unsigned long a, unsigned long b);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int time_after_eq(unsigned long a, unsigned long b);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int time_before_eq(unsigned long a, unsigned long b);</span></span></span></dt></p>
<dd>
<p class="docList">These Boolean expressions compare jiffies in a safe way, without
problems in case of counter overflow and without the need to access
<tt>jiffies_64</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">u64 get_jiffies_64(void);</span></span></span></dt></p>
<dd>
<p class="docList">Retrieves <tt>jiffies_64</tt> without race conditions.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/time.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long timespec_to_jiffies(struct timespec *value);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long timeval_to_jiffies(struct timeval *value);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);</span></span></span></dt></P>
<dd>
<p class="docList">Converts time representations between jiffies and other
representations.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/msr.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">rdtsc(low32,high32);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">rdtscl(low32);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">rdtscll(var32);</span></span></span></dt></p>
<dd>
<p class="docList">x86-specific macros to read the timestamp counter. They read it as
two 32-bit halves, read only the lower half, or read all of it into a
<tt>long long</tt> variable.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/timex.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">cycles_t get_cycles(void);</span></span></span></dt></P>
<dd>
<p class="docList">Returns the timestamp counter in a platform-independent way. If the
CPU offers no timestamp feature, <tt>0</tt> is returned.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/time.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long mktime(year, mon, day, h, m, s);</span></span></span></dt></p>
<dd>
<p class="docList">Returns the number of seconds since the Epoch, based on the six
<tt>unsigned</tt> <tt>int</tt> arguments.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void do_gettimeofday(struct timeval *tv);</span></span></span></dt></p>
<dd>
<p class="docList">Returns the current time, as seconds and microseconds since the
Epoch, with the best resolution the hardware can offer. On most
platforms the resolution is one microsecond or better, although some
platforms offer only jiffies resolution.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct timespec current_kernel_time(void);</span></span></span></dt></p>
<dd>
<p class="docList">Returns the current time with the resolution of one jiffy.</p>
</dd>
</dl>


<a name="chp-7-sect-7.2"></a>
<h4 class="docSection2Title">7.7.2. Delays</h4>

<a name="chp-7-ITERM-5633"></a><a name="chp-7-ITERM-5634"></a><a name="chp-7-ITERM-5635"></a><a name="chp-7-ITERM-5636"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/wait.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">long wait_event_interruptible_timeout(wait_queue_head_t *q, condition, signed</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">long timeout);</span></span></span></dt></p>
<dd>
<p class="docList">Puts the current process to sleep on the wait queue, installing a
timeout value expressed in jiffies. Use
<span class="docEmphasis">schedule_timeout</span> (below) for noninterruptible
sleeps.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/sched.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">signed long schedule_timeout(signed long timeout);</span></span></span></dt></p>
<dd>
<p class="docList">Calls the scheduler
<a name="chp-7-ITERM-5633"></a>
<a name="chp-7-ITERM-5634"></a>
<a name="chp-7-ITERM-5635"></a>
<a name="chp-7-ITERM-5636"></a>after ensuring that the current
process is awakened at timeout expiration. The caller must invoke
<span class="docEmphasis">set_current_state</span> first to put itself in an
interruptible or noninterruptible sleep state.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/delay.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void ndelay(unsigned long nsecs);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void udelay(unsigned long usecs);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void mdelay(unsigned long msecs);</span></span></span></dt></p>
<dd>
<p class="docList">Introduces delays of an integer number of nanoseconds, microseconds,
and milliseconds. The delay achieved is at least the requested value,
but it can be more. The argument to each function must not exceed a
platform-specific limit (usually a few thousands).</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void msleep(unsigned int millisecs);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long msleep_interruptible(unsigned int millisecs);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void ssleep(unsigned int seconds);</span></span></span></dt></p>
<dd>
<p class="docList">Puts the process to sleep for the given number of milliseconds (or
seconds, in the case of <span class="docEmphasis">ssleep</span>).</p>
</dd>
</dl>


<a name="chp-7-sect-7.3"></a>
<h4 class="docSection2Title">7.7.3. Kernel Timers</h4>

<a name="chp-7-ITERM-5637"></a><a name="chp-7-ITERM-5638"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;asm/hardirq.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int in_interrupt(void);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int in_atomic(void);</span></span></span></dt></P>
<dd>
<p class="docList">Returns a
Boolean<a name="chp-7-ITERM-5637"></a>
<a name="chp-7-ITERM-5638"></a>
value telling whether the calling code is executing in interrupt
context or atomic context. Interrupt context is outside of a process
context, either during hardware or software interrupt processing.
Atomic context is when you can't schedule either an
interrupt context or a process's context with a
spinlock held.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/timer.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void init_timer(struct timer_list * timer);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct timer_list TIMER_INITIALIZER(_function, _expires, _data);</span></span></span></dt></p>
<dd>
<p class="docList">This function and the static declaration of the timer structure are
the two ways to initialize a <tt>timer_list</tt> data
structure.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void add_timer(struct timer_list * timer);</span></span></span></dt></P>
<dd>
<p class="docList">Registers the timer structure to run on the current CPU.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int mod_timer(struct timer_list *timer, unsigned long expires);</span></span></span></dt></P>
<dd>
<p class="docList">Changes the expiration time of an already scheduled timer structure.
It can also act as an alternative to <span class="docEmphasis">add_timer</span>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int timer_pending(struct timer_list * timer);</span></span></span></dt></p>
<dd>
<p class="docList">Macro that returns a Boolean value stating whether the timer
structure is already registered to run.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void del_timer(struct timer_list * timer);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void del_timer_sync(struct timer_list * timer);</span></span></span></dt></p>
<dd>
<p class="docList">Removes a timer from the list of active timers. The latter function
ensures that the timer is not currently running on another CPU.</P>
</dd>
</dl>


<a name="chp-7-sect-7.4"></a>
<h4 class="docSection2Title">7.7.4. Tasklets</H4>

<a name="chp-7-ITERM-5639"></a><a name="chp-7-ITERM-5640"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/interrupt.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DECLARE_TASKLET(name, func, data);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DECLARE_TASKLET_DISABLED(name, func, data);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long)</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">unsigned long data);</span></span></span></dt></p>
<dd>
<p class="docList">The first two macros declare a tasklet structure, while the
<span class="docEmphasis">tasklet_init</span> function initializes a tasklet
<a name="chp-7-ITERM-5639"></a>
<a name="chp-7-ITERM-5640"></a>structure that has
been obtained by allocation or other means. The second
<tt>DECLARE</tt> macro marks the tasklet as disabled.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_disable(struct tasklet_struct *t);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_disable_nosync(struct tasklet_struct *t);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_enable(struct tasklet_struct *t);</span></span></span></dt></P>
<dd>
<p class="docList">Disables and reenables a tasklet. Each <span class="docEmphasis">disable</span>
must be matched with an <span class="docEmphasis">enable</span> (you can disable
the tasklet even if it's already disabled). The
function <span class="docEmphasis">tasklet_disable</span> waits for the tasklet
to terminate if it is running on another CPU. The
<span class="docEmphasis">nosync</span> version doesn't take
this extra step.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_schedule(struct tasklet_struct *t);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_hi_schedule(struct tasklet_struct *t);</span></span></span></dt></P>
<dd>
<p class="docList">Schedules a tasklet to run, either as a
"normal" tasklet or a high-priority
one. When soft interrupts are executed, high-priority tasklets are
dealt with first, while normal tasklets run last.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void tasklet_kill(struct tasklet_struct *t);</span></span></span></dt></p>
<dd>
<p class="docList">Removes the tasklet from the list of active ones, if
it's scheduled to run. Like
<span class="docEmphasis">tasklet_disable</span>, the function may block on SMP
systems waiting for the tasklet to terminate if it's
currently running on another CPU.</p>
</dd>
</dl>


<a name="chp-7-sect-7.5"></a>
<h4 class="docSection2Title">7.7.5. Workqueues</h4>

<a name="chp-7-ITERM-5641"></a><a name="chp-7-ITERM-5642"></a><a name="chp-7-ITERM-5643"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/workqueue.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct workqueue_struct;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct work_struct;</span></span></span></dt></P>
<dd>
<p class="docList">The structures
<a name="chp-7-ITERM-5641"></a>
<a name="chp-7-ITERM-5642"></a>
<a name="chp-7-ITERM-5643"></a>representing
a workqueue and a work entry, respectively.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct workqueue_struct *create_workqueue(const char *name);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct workqueue_struct *create_singlethread_workqueue(const char *name);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void destroy_workqueue(struct workqueue_struct *queue);</span></span></span></dt></p>
<dd>
<p class="docList">Functions for creating and destroying workqueues. A call to
<span class="docEmphasis">create_workqueue</span> creates a queue with a worker
thread on each processor in the system; instead,
<span class="docEmphasis">create_singlethread_workqueue</span> creates a
workqueue with a single worker process.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">DECLARE_WORK(name, void (*function)(void *), void *data);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">INIT_WORK(struct work_struct *work, void (*function)(void *), void *data);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PREPARE_WORK(struct work_struct *work, void (*function)(void *), void *data);</span></span></span></dt></p>
<dd>
<p class="docList">Macros that declare and initialize workqueue entries.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int queue_work(struct workqueue_struct *queue, struct work_struct *work);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int queue_delayed_work(struct workqueue_struct *queue, struct work_struct</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">*work, unsigned long delay);</span></span></span></dt></P>
<dd>
<p class="docList">Functions that queue work for execution from a workqueue.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int cancel_delayed_work(struct work_struct *work);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void flush_workqueue(struct workqueue_struct *queue);</span></span></span></dt></p>
<dd>
<p class="docList">Use <span class="docEmphasis">cancel_delayed_work</span> to remove an entry from
a workqueue; <span class="docEmphasis">flush_workqueue</span> ensures that no
workqueue entries are running anywhere in the system.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int schedule_work(struct work_struct *work);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int schedule_delayed_work(struct work_struct *work, unsigned long delay);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void flush_scheduled_work(void);</span></span></span></dt></p>
<dd>
<p class="docList">Functions for working with the shared workqueue.</P>
</dd>
</dl>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-7-sect-6.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-8.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
