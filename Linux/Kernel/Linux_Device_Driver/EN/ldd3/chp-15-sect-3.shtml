<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>15.3. Performing Direct I/O</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-15-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-15-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-15-sect-3"></a>
<h3 class="docSection1Title">15.3. Performing Direct I/O</h3>

<p class="docText">Most I/O operations are <a name="chp-15-ITERM-7111"></a> <a name="chp-15-ITERM-7112"></a> <a name="chp-15-ITERM-7113"></a>
<a name="chp-15-ITERM-7114"></a>
<a name="chp-15-ITERM-7115"></a>buffered
<a name="chp-15-ITERM-7116"></a>through the kernel. The use of
a kernel-space buffer allows a degree of separation between user
space and the actual device; this separation can make programming
easier and can also yield performance benefits in many situations.
There are cases, however, where it can be beneficial to perform I/O
directly to or from a user-space buffer. If the amount of data being
transferred is large, transferring data directly without an extra
copy through kernel space can speed things up.</p>

<p class="docText">One example of direct I/O use in the 2.6 kernel is the SCSI tape
driver. Streaming tapes can pass a lot of data through the system,
and tape transfers are usually record-oriented, so there is little
benefit to buffering data in the kernel. So, when the conditions are
right (the user-space buffer is page-aligned, for example), the SCSI
tape driver performs its I/O without copying the data.</p>

<p class="docText">That said, it is important to recognize that direct I/O does not
always provide the performance boost that one might expect. The
overhead of setting up direct I/O (which involves faulting in and
pinning down the relevant user pages) can be significant, and the
benefits of buffered I/O are lost. For example, the use of direct I/O
requires that the <span class="docEmphasis">write</span> system call operate
synchronously; otherwise the application does not know when it can
reuse its I/O buffer. Stopping the application until each write
completes can slow things down, which is why applications that use
direct I/O often use asynchronous I/O operations as well.</p>

<p class="docText">The real moral of the story, in any case, is that implementing direct
I/O in a char driver is usually unnecessary and can be hurtful. You
should take that step only if you are sure that the overhead of
buffered I/O is truly slowing things down. Note also that block and
network drivers need not worry about implementing direct I/O at all;
in both cases, higher-level code in the kernel sets up and makes use
of direct I/O when it is indicated, and driver-level code need not
even know that direct I/O is being performed.</p>

<p class="docText">The key to implementing direct I/O in the 2.6 kernel is a function
called
<span class="docEmphasis">get_user_pages</span><a name="chp-15-ITERM-7117"></a>
<a name="chp-15-ITERM-7118"></a>,
which is declared in <i>&lt;linux/mm.h&gt;</i> with the
following prototype:</p>

<pre>int get_user_pages(struct task_struct *tsk, 
                   struct mm_struct *mm, 
                   unsigned long start,
                   int len, 
                   int write, 
                   int force, 
                   struct page **pages, 
                   struct vm_area_struct **vmas);</pre><br>


<p class="docText">This function has several arguments:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">tsk</span></span></span></dt></p>
<dd>
<p class="docList">A pointer to the task performing the I/O; its main purpose is to tell
the kernel who should be charged for any page faults incurred while
setting up the buffer. This argument is almost always passed as
<tt>current</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">mm</span></span></span></dt></p>
<dd>
<p class="docList">A pointer to the memory management structure describing the address
space to be mapped. The <tt>mm_struct</tt> structure is the
piece that ties together all of the parts (VMAs) of a
process's virtual address space. For driver use,
this argument should always be <tt>current-&gt;mm</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">start</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">len</span></span></span></dt></p>
<dd>
<p class="docList"><tt>start</tt> is the (page-aligned) address of the
user-space buffer, and <tt>len</tt> is the length of the
buffer in pages.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">write</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">force</span></span></span></dt></p>
<dd>
<p class="docList">If <tt>write</tt> is nonzero, the pages are mapped for
write access (implying, of course, that user space is performing a
read operation). The <tt>force</tt> flag tells
<span class="docEmphasis">get_user_pages</span> to override the protections on
the given pages to provide the requested access; drivers should
always pass <tt>0</tt> here.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">pages</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">vmas</span></span></span></dt></P>
<dd>
<p class="docList">Output parameters. Upon successful completion,
<tt>pages</tt> contain a list of pointers to the
<tt>struct page</tt> structures describing the user-space
buffer, and <tt>vmas</tt> contains pointers to the
associated VMAs. The parameters should, obviously, point to arrays
capable of holding at least <tt>len</tt> pointers. Either
parameter can be <tt>NULL</tt>, but you need, at least, the
<tt>struct</tt> <tt>page</tt> pointers to
actually operate on the buffer.</p>
</dd>
</dl>

<p class="docText"><span class="docEmphasis">get_user_pages</span> is a low-level memory management
function, with a suitably complex interface. It also requires that
the mmap reader/writer semaphore for the address space be obtained in
read mode before the call. As a result, calls to
<span class="docEmphasis">get_user_pages</span> usually look something like:</p>

<pre>down_read(&amp;current-&gt;mm-&gt;mmap_sem);
result = get_user_pages(current, current-&gt;mm, ...);
up_read(&amp;current-&gt;mm-&gt;mmap_sem);</pre><BR>


<p class="docText">The return value is the number of pages actually mapped, which could
be fewer than the number requested (but greater than zero).</p>

<p class="docText">Upon successful completion, the caller has a <tt>pages</tt>
array pointing to the user-space
buffer,<a name="chp-15-ITERM-7119"></a> which is locked into memory. To
operate on the buffer directly, the kernel-space code must turn each
<tt>struct</tt> <tt>page</tt> pointer into a
kernel virtual address with <span class="docEmphasis">kmap</span> or
<span class="docEmphasis">kmap_atomic</span>. Usually, however, devices for which
direct I/O is justified are using DMA operations, so your driver will
probably want to create a scatter/gather list from the array of
<tt>struct</tt> <tt>page</tt> pointers. We
discuss how to do this in the section, <a class="docLink" href="chp-15-sect-4.shtml#chp-15-sect-4.4.7">Section 15.4.4.7</a>.</p>

<p class="docText">Once your direct I/O operation is complete, you must release the user
pages. Before doing so, however, you must inform the kernel if you
changed the contents of those pages. Otherwise, the kernel may think
that the pages are "clean," meaning
that they match a copy found on the swap device, and free them
without writing them out to backing store. So, if you have changed
the pages (in response to a user-space read request), you must mark
each affected page dirty with a call to:</P>

<pre>void SetPageDirty(struct page *page);</pre><br>


<p class="docText">(This macro is defined in
<I>&lt;linux/page-flags.h&gt;</i>). Most code that
performs this operation checks first to ensure that the page is not
in the reserved part of the memory map, which is never swapped out.
Therefore, the code usually looks like:</p>

<pre>if (! PageReserved(page))
    SetPageDirty(page);</pre><br>


<p class="docText">Since user-space <a name="chp-15-ITERM-7120"></a>memory is not normally marked reserved,
this check should not strictly be necessary, but when you are getting
your hands dirty deep within the memory management subsystem, it is
best to be thorough and careful.</p>

<p class="docText">Regardless of whether the pages have been changed, they must be freed
from the page cache, or they stay there forever. The call to use is:</p>

<pre>void page_cache_release(struct page *page);</pre><br>


<p class="docText">This call should, of course, be made <span class="docEmphasis">after</span> the
page has been marked dirty, if need be.</p>

<a name="chp-15-sect-3.1"></a>
<h4 class="docSection2Title">15.3.1. Asynchronous I/O</h4>

<p class="docText">One of the new features added to the 2.6 kernel was the
<i>asynchronous I/O</i><a name="chp-15-ITERM-7121"></a> <a name="chp-15-ITERM-7122"></a>
capability. Asynchronous I/O allows user space to initiate operations
without waiting for their completion; thus, an application can do
other processing while its I/O is in flight. A complex,
high-performance application can also use asynchronous I/O to have
multiple operations going at the same time.</p>

<p class="docText">The implementation of
<a name="chp-15-ITERM-7123"></a>asynchronous I/O is optional, and very few
driver authors bother; most devices do not benefit from this
capability. As we will see in the coming chapters, block and network
drivers are fully asynchronous at all times, so only char drivers are
candidates for explicit asynchronous I/O support. A char device can
benefit from this support if there are good reasons for having more
than one I/O operation outstanding at any given time. One good
example is streaming tape drives, where the drive can stall and slow
down significantly if I/O operations do not arrive quickly enough. An
application trying to get the best performance out of a streaming
drive could use asynchronous I/O to have multiple operations ready to
go at any given time.</p>

<p class="docText">For the rare driver author who needs to implement asynchronous I/O,
we present a quick overview of how it works. We cover asynchronous
I/O in this chapter, because its implementation almost always
involves direct I/O operations as well (if you are buffering data in
the kernel, you can usually implement asynchronous behavior without
imposing the added complexity on user space).</P>

<p class="docText">Drivers supporting asynchronous I/O should include
<i>&lt;linux/aio.h&gt;</I>. There are three
<span class="docEmphasis">file_operations</span> methods for the implementation
of asynchronous I/O:</P>

<pre>ssize_t (*aio_read) (struct kiocb *iocb, char *buffer, 
                     size_t count, loff_t offset);
ssize_t (*aio_write) (struct kiocb *iocb, const char *buffer, 
                      size_t count, loff_t offset);
int (*aio_fsync) (struct kiocb *iocb, int datasync);</pre><br>


<p class="docText">The <span class="docEmphasis">aio_fsync</span><a name="chp-15-ITERM-7124"></a>
<a name="chp-15-ITERM-7125"></a>
<a name="chp-15-ITERM-7126"></a>
operation is only of interest to filesystem code, so we do not
discuss it further here. The other two, <span class="docEmphasis">aio_read</span>
and <span class="docEmphasis">aio_write</span>, look very much like the regular
<span class="docEmphasis">read</span> and <span class="docEmphasis">write</span> methods but
with a couple of exceptions. One is that the
<tt>offset</tt> parameter is passed by value; asynchronous
operations never change the file position, so there is no reason to
pass a pointer to it. These methods also take the
<tt>iocb</tt> ("I/O control
block") parameter, which we get to in a moment.</p>

<p class="docText">The purpose of the <span class="docEmphasis">aio_read</span> and
<span class="docEmphasis">aio_write</span> methods is to initiate a read or write
operation that may or may not be complete by the time they return. If
it <span class="docEmphasis">is</span> possible to complete the operation
immediately, the method should do so and return the usual status: the
number of bytes transferred or a negative error code. Thus, if your
driver has a <span class="docEmphasis">read</span> method called
<span class="docEmphasis">my_read</span>, the following
<span class="docEmphasis">aio_read</span> method is entirely correct (though
rather pointless):</p>

<pre>static ssize_t my_aio_read(struct kiocb *iocb, char *buffer, 
                           ssize_t count, loff_t offset)
{
    return my_read(iocb-&gt;ki_filp, buffer, count, &amp;offset);
}</pre><BR>


<p class="docText">Note that the <tt>struct</tt> <tt>file</tt>
pointer is found in the <tt>ki_filp</tt> field of the
<tt>kiocb</tt> structure.</p>

<p class="docText">If you support asynchronous I/O, you must be aware of the fact that
the kernel can, on occasion, create "synchronous
IOCBs." These are, essentially, asynchronous
operations that must actually be executed synchronously. One may well
wonder why things are done this way, but it's best
to just do what the kernel asks. Synchronous operations are marked in
the IOCB; your driver should query that status with:</P>

<pre>int is_sync_kiocb(struct kiocb *iocb);</pre><BR>


<p class="docText">If this function returns a nonzero value, your driver must execute
the operation synchronously.</P>

<p class="docText">In the end, however, the point of all this structure is to enable
asynchronous operations. If your driver is able to initiate the
operation (or, simply, to queue it until some future time when it can
be executed), it must do two things: remember everything it needs to
know about the operation, and return <tt>-EIOCBQUEUED</tt>
to the caller. Remembering the operation information includes
arranging access to the user-space buffer; once you return, you will
not again have the opportunity to access that buffer while running in
the context of the calling process. In general, that means you will
likely have to set up a direct kernel mapping (with
<span class="docEmphasis">get_user_pages</span>) or a DMA mapping. The
<tt>-EIOCBQUEUED</tt> error code indicates that the
operation is not yet complete, and its final status will be posted
later.</p>

<p class="docText">When "later" comes, your driver
must inform the kernel that the operation has completed. That is done
with a call to <span class="docEmphasis">aio_complete</span>:</p>

<pre>int aio_complete(struct kiocb *iocb, long res, long res2);</pre><br>


<p class="docText">Here, <tt>iocb</tt> is the same IOCB that was initially
passed to you, and <tt>res</tt> is the usual result status
for the operation. <tt>res2</tt> is a second result code
that will be returned to user space; most asynchronous I/O
implementations pass <tt>res2</tt> as <tt>0</tt>.
Once you call <span class="docEmphasis">aio_complete</span>, you should not touch
the IOCB or user buffer again.</p>

<a name="chp-15-sect-3.1.1"></a>
<H5 class="docSection3Title">15.3.1.1 An asynchronous I/O example</H5>

<p class="docText">The page-oriented <span class="docEmphasis">scullp</span> driver in the example
source implements asynchronous I/O. The implementation is simple, but
it is enough to show how asynchronous operations should be
structured.</P>

<p class="docText">The <span class="docEmphasis">aio_read</span> and <span class="docEmphasis">aio_write</span>
methods don't actually do much:</p>

<pre>static ssize_t scullp_aio_read(struct kiocb *iocb, char *buf, size_t count,
        loff_t pos)
{
    return scullp_defer_op(0, iocb, buf, count, pos);
}

static ssize_t scullp_aio_write(struct kiocb *iocb, const char *buf,
        size_t count, loff_t pos)
{
    return scullp_defer_op(1, iocb, (char *) buf, count, pos);
}</pre><BR>


<p class="docText">These methods simply call a common function:</P>

<pre>struct async_work {
    struct kiocb *iocb;
    int result;
    struct work_struct work;
};

static int scullp_defer_op(int write, struct kiocb *iocb, char *buf,
        size_t count, loff_t pos)
{
    struct async_work *stuff;
    int result;

    /* Copy now while we can access the buffer */
    if (write)
        result = scullp_write(iocb-&gt;ki_filp, buf, count, &amp;pos);
    else
        result = scullp_read(iocb-&gt;ki_filp, buf, count, &amp;pos);

    /* If this is a synchronous IOCB, we return our status now. */
    if (is_sync_kiocb(iocb))
        return result;

    /* Otherwise defer the completion for a few milliseconds. */
    stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
    if (stuff =  = NULL)
        return result; /* No memory, just complete now */
    stuff-&gt;iocb = iocb;
    stuff-&gt;result = result;
    INIT_WORK(&amp;stuff-&gt;work, scullp_do_deferred_op, stuff);
    schedule_delayed_work(&amp;stuff-&gt;work, HZ/100);
    return -EIOCBQUEUED;
}</pre><br>


<p class="docText">A more complete implementation would use
<span class="docEmphasis">get_user_pages</span> to map the user buffer into
kernel space. We chose to keep life simple by just copying over the
data at the outset. Then a call is made to
<span class="docEmphasis">is_sync_kiocb</span> to see if this operation must be
completed synchronously; if so, the result status is returned, and we
are done. Otherwise we remember the relevant information in a little
structure, arrange for "completion"
via a workqueue, and return <tt>-EIOCBQUEUED</tt>. At this
point, control returns to user space.</p>

<p class="docText">Later on, the workqueue executes our completion function:</p>

<pre>static void scullp_do_deferred_op(void *p)
{
    struct async_work *stuff = (struct async_work *) p;
    aio_complete(stuff-&gt;iocb, stuff-&gt;result, 0);
    kfree(stuff);
}</pre><br>


<p class="docText">Here, it is simply a matter of calling
<span class="docEmphasis">aio_complete</span> with our saved information. A real
driver's asynchronous I/O implementation is somewhat
more complicated, of course, but it follows this<a name="chp-15-ITERM-7127"></a> <a name="chp-15-ITERM-7128"></a> sort <a name="chp-15-ITERM-7129"></a> <a name="chp-15-ITERM-7130"></a> <a name="chp-15-ITERM-7131"></a> <a name="chp-15-ITERM-7132"></a> <a name="chp-15-ITERM-7133"></a>of structure.</P>




<ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-15-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-15-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
