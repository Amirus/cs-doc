<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>14.5. Classes</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-6.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-14-sect-5"></a>
<H3 class="docSection1Title">14.5. Classes</H3>

<p class="docText">The final device model <a name="chp-14-ITERM-6782"></a> <a name="chp-14-ITERM-6783"></a>
<a name="chp-14-ITERM-6784"></a>
<a name="chp-14-ITERM-6785"></a>
<a name="chp-14-ITERM-6786"></a>concept we examine in this
chapter is the <i>class</i>. A class is a
higher-level view of a device that abstracts out low-level
implementation details. Drivers may see a SCSI disk or an ATA disk,
but, at the class level, they are all simply disks. Classes allow
user space to work with devices based on what they do, rather than
how they are connected or how they work.</p>

<p class="docText">Almost all classes show up in sysfs under
<i>/sys/class</I>. Thus, for example, all network
interfaces can be found under <i>/sys/class/net</i>,
regardless of the type of interface. Input devices can be found in
<I>/sys/class/input</i>, and serial devices are in
<i>/sys/class/tty</I>. The one exception is block
devices, which can be found under <i>/sys/block</I> for
historical reasons.</p>

<p class="docText">Class membership is usually handled by high-level code without the
need for explicit support from drivers. When the
<span class="docEmphasis">sbull</span> driver (see <a class="docLink" href="chp-16.shtml#chp-16">Chapter 16</a>) creates a virtual disk
device, it automatically appears in <i>/sys/block</i>.
The <span class="docEmphasis">snull</span> network driver (see <a class="docLink" href="chp-17.shtml#chp-17">Chapter 17</a>) does not have to do
anything special for its interfaces to be represented in
<i>/sys/class/net</i>. There will be times, however,
when drivers end up dealing with classes directly.</p>

<p class="docText">In many cases, the class subsystem is the best way of exporting
information to user space. When a subsystem creates a class, it owns
the class entirely, so there is no need to worry about which module
owns the attributes found there. It also takes very little time
wandering around in the more hardware-oriented parts of sysfs to
realize that it can be an unfriendly place for direct browsing. Users
more happily find information in
<i>/sys/class/some-widget</i> than under, say,
<i>/sys/devices/pci0000:00/0000:00:10.0/usb2/2-0:1.0</i>.</p>

<p class="docText">The driver core exports two distinct interfaces for managing classes.
The <span class="docEmphasis">class_simple</span> routines are designed to make
it as easy as possible to add new classes to the system; their main
purpose, usually, is to expose attributes containing device numbers
to enable the automatic creation of device nodes. The regular class
interface is more complex but offers more features as well. We start
with the simple version.</p>

<a name="chp-14-sect-5.1"></a>
<h4 class="docSection2Title">14.5.1. The class_simple Interface</H4>

<p class="docText">The <span class="docEmphasis">class_simple</span><a name="chp-14-ITERM-6787"></a>
<a name="chp-14-ITERM-6788"></a>
interface was intended to be so easy to use that nobody would have
any excuse for not exporting, at a minimum, an attribute containing a
device's assigned number. Using this interface is
simply a matter of a couple of function calls, with little of the
usual boilerplate associated with the Linux device model.</p>

<p class="docText">The first step is to create the class itself. That is accomplished
with a call to <span class="docEmphasis">class_simple_create</span>:</P>

<pre>struct class_simple *class_simple_create(struct module *owner, char *name);</pre><BR>


<p class="docText">This function creates a class with the given <tt>name</tt>.
The operation can fail, of course, so the return value should always
be checked (using <span class="docEmphasis">IS_ERR</span>, described in the
<a class="docLink" href="chp-1-sect-8.shtml#chp-1-sect-8">Section 1.8</a> in <a class="docLink" href="chp-11.shtml#chp-11">Chapter 11</a>) before continuing.</p>

<p class="docText">A simple class can be destroyed with:</p>

<pre>void class_simple_destroy(struct class_simple *cs);</pre><br>


<p class="docText">The real purpose of creating a simple class is to add devices to it;
that task is achieved with:</P>

<pre>struct class_device *class_simple_device_add(struct class_simple *cs,
                                             dev_t devnum,
                                             struct device *device,
                                             const char *fmt, ...);</pre><br>


<p class="docText">Here, <tt>cs</tt> is the previously created simple class,
<tt>devnum</tt> is the assigned device number,
<tt>device</tt> is the <tt>struct</tt>
<tt>device</tt> representing this device, and the remaining
parameters are a <span class="docEmphasis">printk</span>-style format string and
arguments to create the device name. This call adds an entry to the
class containing one attribute, <tt>dev</tt>, which holds
the device number. If the <tt>device</tt> parameter is not
<tt>NULL</tt>, a symbolic link (called
<tt>device</tt>) points to the device's
entry under <I>/sys/devices</I>.</P>

<p class="docText">It is possible to add other attributes to a device entry. It is just
a matter of using <span class="docEmphasis">class_device_create_file</span>,
which we discuss in the next section with the rest of the full class
subsystem.</p>

<p class="docText">Classes generate hotplug events when devices come and go. If your
driver needs to add variables to the environment for the user-space
event handler, it can set up a hotplug callback with:</p>

<pre>int class_simple_set_hotplug(struct class_simple *cs, 
                             int (*hotplug)(struct class_device *dev, 
                                            char **envp, int num_envp, 
                                            char *buffer, int buffer_size));</pre><br>


<p class="docText">When your device goes away, the class entry should be removed with:</p>

<pre>void class_simple_device_remove(dev_t dev);</pre><BR>


<p class="docText">Note that the <tt>class_device</tt> structure returned by
<span class="docEmphasis">class_simple_device_add</span> is not needed here; the
device number (which should certainly be unique) is sufficient.</P>


<a name="chp-14-sect-5.2"></a>
<H4 class="docSection2Title">14.5.2. The Full Class Interface</h4>

<p class="docText">The <span class="docEmphasis">class_simple</span> interface suffices
<a name="chp-14-ITERM-6789"></a>
<a name="chp-14-ITERM-6790"></a>for many needs, but sometimes more
flexibility is required. The following discussion describes how to
use the full class mechanism, upon which
<span class="docEmphasis">class_simple</span> is based. It is brief: the class
functions and structures follow the same patterns as the rest of the
device model, so there is little that is truly new here.</P>

<a name="chp-14-sect-5.2.1"></a>
<H5 class="docSection3Title">14.5.2.1 Managing classes</h5>

<p class="docText">A class is defined by an
<a name="chp-14-ITERM-6791"></a>
<a name="chp-14-ITERM-6792"></a>instance
of <tt>struct class</tt>:</p>

<pre>struct class {
    char *name;
    struct class_attribute *class_attrs;
    struct class_device_attribute *class_dev_attrs;
    int (*hotplug)(struct class_device *dev, char **envp, 
                   int num_envp, char *buffer, int buffer_size);
    void (*release)(struct class_device *dev);
    void (*class_release)(struct class *class);
    /* Some fields omitted */
};</pre><br>


<p class="docText">Each class needs a unique <tt>name</tt>, which is how this
class appears under <i>/sys/class</I>. When the class
is registered, all of the attributes listed in the
(<tt>NULL</tt>-terminated) array pointed to by
<tt>class_attrs</tt> is created. There is also a set of
default attributes for every device added to the class;
<tt>class_dev_attrs</tt> points to those. There is the
usual <span class="docEmphasis">hotplug</span> function for adding variables to
the environment when events are generated. There are also two
<span class="docEmphasis">release</span> methods: <span class="docEmphasis">release</span> is
called whenever a device is removed from the class, while
<span class="docEmphasis">class_release</span> is called when the class itself is
released.</p>

<p class="docText">The registration functions are:</p>

<pre>int class_register(struct class *cls);
void class_unregister(struct class *cls);</pre><BR>


<p class="docText">The interface for working with attributes should not surprise anybody
at this point:</p>

<pre>struct class_attribute {
    struct attribute attr;
    ssize_t (*show)(struct class *cls, char *buf);
    ssize_t (*store)(struct class *cls, const char *buf, size_t count);
};

CLASS_ATTR(name, mode, show, store);

int class_create_file(struct class *cls, 
                      const struct class_attribute *attr);
void class_remove_file(struct class *cls, 
                       const struct class_attribute *attr);</pre><br>




<a name="chp-14-sect-5.2.2"></a>
<H5 class="docSection3Title">14.5.2.2 Class devices</h5>

<p class="docText">The real purpose of a
<a name="chp-14-ITERM-6793"></a>
<a name="chp-14-ITERM-6794"></a>class is to serve as a container for the
devices that are members of that class. A member is represented by
<tt>struct class_device</tt>:</P>

<pre>struct class_device {
    struct kobject kobj;
    struct class *class;
    struct device *dev;
    void *class_data;
    char class_id[BUS_ID_SIZE];
};</pre><br>


<p class="docText">The<a name="chp-14-ITERM-6795"></a>
<tt>class_id</tt> field holds the name of this device as it
appears in sysfs. The <tt>class</tt> pointer should point
to the class holding this device, and <tt>dev</tt> should
point to the associated <tt>device</tt> structure. Setting
<tt>dev</tt> is optional; if it is
non-<tt>NULL</tt>, it is used to create a symbolic link
from the class entry to the corresponding entry under
<i>/sys/devices</i>, making it easy to find the device
entry in user space. The class can use <tt>class_data</tt>
to hold a private pointer.</p>

<p class="docText">The usual registration functions have been provided:</p>

<pre>int class_device_register(struct class_device *cd);
void class_device_unregister(struct class_device *cd);</pre><br>


<p class="docText">The class device interface also allows the renaming of an already
registered entry:</p>

<pre>int class_device_rename(struct class_device *cd, char *new_name);</pre><br>


<p class="docText">Class device entries have attributes:</p>

<pre>struct class_device_attribute {
   struct attribute attr;
   ssize_t (*show)(struct class_device *cls, char *buf);
   ssize_t (*store)(struct class_device *cls, const char *buf, 
                    size_t count);
};

CLASS_DEVICE_ATTR(name, mode, show, store);

int class_device_create_file(struct class_device *cls, 
                             const struct class_device_attribute *attr);
void class_device_remove_file(struct class_device *cls, 
                              const struct class_device_attribute *attr);</pre><br>


<p class="docText">A default set of attributes, in the class's
<tt>class_dev_attrs</tt> field, is created when the class
device is registered; <span class="docEmphasis">class_device_create_file</span>
may be used to create additional attributes. Attributes may also be
added to class devices created with the
<span class="docEmphasis">class_simple</span> interface.</p>



<a name="chp-14-sect-5.2.3"></a>
<h5 class="docSection3Title">14.5.2.3 Class interfaces</h5>

<p class="docText">The class
subsystem<a name="chp-14-ITERM-6796"></a>
has an
<a name="chp-14-ITERM-6797"></a>
<a name="chp-14-ITERM-6798"></a>additional
concept not found in other parts of the Linux device model. This
mechanism is called an <I>interface</i>, but it is,
perhaps, best thought of as a sort of trigger mechanism that can be
used to get notification when devices enter or leave the class.</P>

<p class="docText">An interface is represented by:</P>

<pre>struct class_interface {
    struct class *class;
    int (*add) (struct class_device *cd);
    void (*remove) (struct class_device *cd);
};</pre><br>


<p class="docText">Interfaces can be registered and unregistered with:</p>

<pre>int class_interface_register(struct class_interface *intf);
void class_interface_unregister(struct class_interface *intf);</pre><br>


<p class="docText">The functioning of an interface is straightforward. Whenever a class
device is added to the <tt>class</tt> specified in the
<tt>class_interface</tt> structure, the
interface's <span class="docEmphasis">add</span> function is
called. That function can perform any additional setup required for
that device; this setup often takes the form of adding more
attributes, but other applications are possible. When the device is
removed from the class, the <span class="docEmphasis">remove</span> method is
called to perform any required cleanup.</P>

<p class="docText">Multiple interfaces<a name="chp-14-ITERM-6799"></a> <a name="chp-14-ITERM-6800"></a> <a name="chp-14-ITERM-6801"></a> <a name="chp-14-ITERM-6802"></a> <a name="chp-14-ITERM-6803"></a> can be registered for a class.</p>




<UL></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-6.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
