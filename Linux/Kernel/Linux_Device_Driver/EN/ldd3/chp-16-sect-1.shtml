<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>16.1. Registration</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-16.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-16-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-16-sect-1"></a>
<h3 class="docSection1Title">16.1. Registration</h3>

<p class="docText">Block drivers, like char<a name="chp-16-ITERM-7300"></a>
<a name="chp-16-ITERM-7301"></a>
<a name="chp-16-ITERM-7302"></a> drivers, must use a set of
registration interfaces to make their devices available to the
kernel. The concepts are similar, but the details of block device
registration are all different. You have a whole new set of data
structures and device operations to learn.</p>

<a name="chp-16-sect-1.1"></a>
<h4 class="docSection2Title">16.1.1. Block Driver Registration</h4>

<p class="docText">The first step taken by most block drivers is to register themselves
with the kernel. The function for this task
is<a name="chp-16-ITERM-7303"></a>
<a name="chp-16-ITERM-7304"></a>
<span class="docEmphasis">register_blkdev</span> (which is declared in
<i>&lt;linux/fs.h&gt;</i>):</p>

<pre>int register_blkdev(unsigned int major, const char *name);</pre><br>


<p class="docText">The arguments are the major number that your device will be using and
the associated name (which the kernel will display in
<i>/proc/devices</i>). If <tt>major</tt> is
passed as <tt>0</tt>, the kernel allocates a new major
number and returns it to the caller. As always, a negative return
value from <span class="docEmphasis">register_blkdev</span> indicates that an
error has occurred.</p>

<p class="docText">The corresponding function for canceling a block driver registration
is:</P>

<pre>int unregister_blkdev(unsigned int major, const char *name);</pre><br>


<p class="docText">Here, the arguments must match those passed to
<span class="docEmphasis">register_blkdev</span>, or the function returns
<tt>-EINVAL</tt> and not unregister anything.</P>

<p class="docText">In the 2.6 kernel, the call to <span class="docEmphasis">register_blkdev</span>
is entirely optional. The functions performed by
<span class="docEmphasis">register_blkdev</span> have been decreasing over time;
the only tasks performed by this call at this point are (1)
allocating a dynamic major number if requested, and (2) creating an
entry in <I>/proc/devices</i>. In future kernels,
<span class="docEmphasis">register_blkdev</span> may be removed altogether.
Meanwhile, however, most drivers still call it; it's
traditional.</p>


<a name="chp-16-sect-1.2"></a>
<h4 class="docSection2Title">16.1.2. Disk Registration</H4>

<p class="docText">While <span class="docEmphasis">register_blkdev</span> can be
<a name="chp-16-ITERM-7305"></a>
<a name="chp-16-ITERM-7306"></a>used
to obtain a major number, it does not make any disk drives available
to the system. There is a separate registration interface that you
must use to manage individual drives. Using this interface requires
familiarity with a pair of new structures, so that is where we start.</p>

<a name="chp-16-sect-1.2.1"></a>
<H5 class="docSection3Title">16.1.2.1 Block device operations</H5>

<p class="docText">Char devices<a name="chp-16-ITERM-7307"></a>
<a name="chp-16-ITERM-7308"></a> make their operations available to the
system by way of the <tt>file_operations</tt> structure. A
similar structure is used with block devices; it is
<tt>struct</tt> <tt>block_device_operations</tt>,
which is declared in <I>&lt;linux/fs.h&gt;</i>. The
following is a brief overview of the fields found in this structure;
we revisit them in more detail when we get into the details of the
<span class="docEmphasis">sbull</span> driver:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*open)(struct inode *inode, struct file *filp);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*release)(struct inode *inode, struct file *filp);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that work just like their char driver equivalents; they are
called whenever the device is opened and closed. A block driver might
respond to an open call by spinning up the device, locking the door
(for removable media), etc. If you lock media into the device, you
should certainly unlock it in the <span class="docEmphasis">release</span>
method.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*ioctl)(struct inode *inode, struct file *filp, unsigned int cmd</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">unsigned long arg);</span></span></span></dt></P>
<dd>
<p class="docList">Method that implements the <span class="docEmphasis">ioctl</span> system call.
The block layer first intercepts a large number of standard requests,
however; so most block driver <span class="docEmphasis">ioctl</span> methods are
fairly short.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*media_changed) (struct gendisk *gd);</span></span></span></dt></p>
<dd>
<p class="docList">Method called by the kernel to check whether the user has changed the
media in the drive, returning a nonzero value if so. Obviously, this
method is only applicable to drives that support removable media (and
that are smart enough to make a "media
changed" flag available to the driver); it can be
omitted in other cases.</p>
</dd>
</dl>
<p class="docText">The <tt>struct gendisk</tt> argument is how the kernel
represents a single disk; we will be looking at that structure in the
next section.</P>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*revalidate_disk) (struct gendisk *gd);</span></span></span></dt></p>
<dd>
<p class="docList">The <span class="docEmphasis">revalidate_disk</span> method is called in response
to a media change; it gives the driver a chance to perform whatever
work is required to make the new media ready for use. The function
returns an <tt>int</tt> value, but that value is ignored by
the kernel.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct module *owner;</span></span></span></dt></p>
<dd>
<p class="docList">A pointer to the module that owns this structure; it should usually
be initialized to <tt>THIS_MODULE</tt>.</p>
</dd>
</dl>

<p class="docText">Attentive readers may have noticed an interesting omission from this
list: there are no functions that actually read or write data. In the
block I/O subsystem, these operations are handled by the
<span class="docEmphasis">request</span> function, which deserves a large section
of its own and is discussed later in the chapter. Before we can talk
about servicing requests, we must complete our discussion of disk
registration.</p>



<a name="chp-16-sect-1.2.2"></a>
<h5 class="docSection3Title">16.1.2.2 The gendisk structure</h5>

<p class="docText"><tt>struct</tt>
<tt>gendisk</tt><a name="chp-16-ITERM-7309"></a>
<a name="chp-16-ITERM-7310"></a>
(declared in <i>&lt;linux/genhd.h&gt;</i>) is the
kernel's representation of an individual disk
device. In fact, the kernel also uses <tt>gendisk</tt>
structures to represent partitions, but driver authors need not be
aware of that. There are several fields in <tt>struct
gendisk</tt> that must be initialized by a block driver:</p>

<a name="chp-16-ITERM-7311"></a><a name="chp-16-ITERM-7312"></a><a name="chp-16-ITERM-7313"></a><a name="chp-16-ITERM-7314"></a><a name="chp-16-ITERM-7315"></a><a name="chp-16-ITERM-7316"></a><a name="chp-16-ITERM-7317"></a><a name="chp-16-ITERM-7318"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int major;</span></span><a name="chp-16-ITERM-7311"></a></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int first_minor;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int minors;</span></span><a name="chp-16-ITERM-7312"></a></span></dt></P>
<dd>
<p class="docList">Fields that describe the device number(s) used by the disk. At a
minimum, a drive must use at least one minor number. If your drive is
to be partitionable, however (and most should be), you want to
allocate one minor number for each possible partition as well. A
common value for <tt>minors</tt> is 16, which allows for
the "full disk" device and 15
partitions. Some disk drivers use 64 minor numbers for each device.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">char disk_name[32];</span></span><a name="chp-16-ITERM-7313"></a></span></dt></P>
<dd>
<p class="docList">Field that should be set to the name of the disk device. It shows up
in <i>/proc/partitions</i> and sysfs.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct block_device_operations *fops;</span></span><a name="chp-16-ITERM-7314"></a></span></dt></P>
<dd>
<p class="docList">Set of device operations from the previous section.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct request_queue *queue;</span></span><a name="chp-16-ITERM-7315"></a></span></dt></P>
<dd>
<p class="docList">Structure used by the kernel to manage I/O requests for this device;
we examine it in <a class="docLink" href="chp-16-sect-3.shtml#chp-16-sect-3">Section 16.3</a>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int flags;</span></span><a name="chp-16-ITERM-7316"></a></span></dt></p>
<dd>
<p class="docList">A (little-used) set of flags describing the state of the drive. If
your device has removable media, you should set
<tt>GENHD_FL_REMOVABLE</tt>. CD-ROM drives can set
<tt>GENHD_FL_CD</tt>. If, for some reason, you do not want
partition information to show up in
<I>/proc/partitions</i>, set
<tt>GENHD_FL_SUPPRESS_PARTITION_INFO</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sector_t capacity;</span></span><a name="chp-16-ITERM-7317"></a></span></dt></p>
<dd>
<p class="docList">The capacity of this drive, in 512-byte sectors. The
<tt>sector_t</tt> type can be 64 bits wide. Drivers should
not set this field directly; instead, pass the number of sectors to
<span class="docEmphasis">set_capacity</span>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *private_data;</span></span><a name="chp-16-ITERM-7318"></a></span></dt></p>
<dd>
<p class="docList">Block drivers may use this field for a pointer to their own internal
data.</p>
</dd>
</dl>

<p class="docText">The kernel provides a small set of functions for working with
<tt>gendisk</tt> structures. We introduce them here, then
see how <span class="docEmphasis">sbull</span> uses them to make its disk devices
available to the system.</p>

<p class="docText"><tt>struct</tt> <tt>gendisk</tt> is a dynamically
allocated structure that requires special kernel manipulation to be
<a name="chp-16-ITERM-7319"></a>initialized; drivers cannot allocate
the structure on their own. Instead, you must call:</p>

<pre>struct gendisk *alloc_disk(int minors);</pre><br>


<p class="docText">The <tt>minors</tt> argument should be the number of minor
numbers this disk uses; note that you cannot change the
<tt>minors</tt> field later and expect things to work
properly.</p>

<p class="docText">When a disk is no longer needed, it should
be<a name="chp-16-ITERM-7320"></a>
<a name="chp-16-ITERM-7321"></a>
freed with:</p>

<pre>void del_gendisk(struct gendisk *gd);</pre><br>


<p class="docText">A <tt>gendisk</tt> is a reference-counted structure (it
contains a kobject). There are <span class="docEmphasis">get_disk</span> and
<span class="docEmphasis">put_disk</span> functions available to manipulate the
reference count, but drivers should never need to do that. Normally,
the call to <span class="docEmphasis">del_gendisk</span> removes the final
reference to a gendisk, but there are no guarantees of that. Thus, it
is possible that the structure could continue to exist (and your
methods could be called) after a call to
<span class="docEmphasis">del_gendisk</span>. If you delete the structure when
there are no users (that is, after the final
<span class="docEmphasis">release</span> or in your module
<span class="docEmphasis">cleanup</span> function), however, you can be sure that
you will not hear from it again.</p>

<p class="docText">Allocating a
<tt>gendisk</tt><a name="chp-16-ITERM-7322"></a> structure does not make the disk
available to the system. To do that, you must initialize the
structure and call <span class="docEmphasis">add_disk</span>:</p>

<pre>void add_disk(struct gendisk *gd);</pre><br>


<p class="docText">Keep one important thing in mind here: as soon as you call
<span class="docEmphasis">add_disk</span>, the disk is
"live" and its methods can be
called at any time. In fact, the first such calls will probably
happen even before <span class="docEmphasis">add_disk</span> returns; the kernel
will read the first few blocks in an attempt to find a partition
table. So you should not call <span class="docEmphasis">add_disk</span> until
your driver is completely initialized and ready to respond to
requests on that disk.</p>



<a name="chp-16-sect-1.3"></a>
<h4 class="docSection2Title">16.1.3. Initialization in sbull</H4>

<p class="docText">It is time to get down to
<a name="chp-16-ITERM-7323"></a> <a name="chp-16-ITERM-7324"></a>
<a name="chp-16-ITERM-7325"></a>
<a name="chp-16-ITERM-7326"></a>
<a name="chp-16-ITERM-7327"></a>
<a name="chp-16-ITERM-7328"></a>
<a name="chp-16-ITERM-7329"></a>some examples. The
<span class="docEmphasis">sbull</span> driver (available from
O'Reilly's FTP site with the rest
of the example source) implements a set of in-memory virtual disk
drives. For each drive, <span class="docEmphasis">sbull</span> allocates (with
<span class="docEmphasis">vmalloc</span>, for simplicity) an array of memory; it
then makes that array available via block operations. The
<span class="docEmphasis">sbull</span> driver can be tested by partitioning the
virtual device, building filesystems on it, and mounting it in the
system hierarchy.</p>

<p class="docText">Like our other example drivers, <span class="docEmphasis">sbull</span> allows a
major number to be specified at compile or module load time. If no
number is specified, one is allocated dynamically. Since a call to
<span class="docEmphasis">register_blkdev</span> is required for dynamic
allocation, <span class="docEmphasis">sbull</span> does so:</P>

<pre>sbull_major = register_blkdev(sbull_major, "sbull");
if (sbull_major &lt;= 0) {
    printk(KERN_WARNING "sbull: unable to get major number\n");
    return -EBUSY;
 }</pre><BR>


<p class="docText">Also, like the other virtual devices we have presented in this book,
the <span class="docEmphasis">sbull</span> device is described by an internal
structure:</p>

<pre>struct sbull_dev {
        int size;                       /* Device size in sectors */
        u8 *data;                       /* The data array */
        short users;                    /* How many users */
        short media_change;             /* Flag a media change? */
        spinlock_t lock;                /* For mutual exclusion */
        struct request_queue *queue;    /* The device request queue */
        struct gendisk *gd;             /* The gendisk structure */
        struct timer_list timer;        /* For simulated media changes */
};</pre><br>


<p class="docText">Several steps are required to initialize this structure and make the
associated device available to the system. We start with basic
initialization and allocation of the underlying memory:</p>

<pre>memset (dev, 0, sizeof (struct sbull_dev));
dev-&gt;size = nsectors*hardsect_size;
dev-&gt;data = vmalloc(dev-&gt;size);
if (dev-&gt;data =  = NULL) {
    printk (KERN_NOTICE "vmalloc failure.\n");
    return;
}
spin_lock_init(&amp;dev-&gt;lock);</pre><BR>


<p class="docText">It's important to allocate and initialize a spinlock
before the next step, which is the allocation of the request queue.
We look at this process in more detail when we get to request
processing; for now, suffice it to say that the necessary call is:</p>

<pre>dev-&gt;queue = blk_init_queue(sbull_request, &amp;dev-&gt;lock);</pre><BR>


<p class="docText">Here,
<span class="docEmphasis">sbull_request</span><a name="chp-16-ITERM-7330"></a>
<a name="chp-16-ITERM-7331"></a>
is our <span class="docEmphasis">request</span> function—the function that
actually performs block read and write requests. When we allocate a
request queue, we must provide a spinlock that controls access to
that queue. The lock is provided by the driver rather than the
general parts of the kernel because, often, the request queue and
other driver data structures fall within the same critical section;
they tend to be accessed together. As with any function that
allocates memory, <span class="docEmphasis">blk_init_queue</span> can fail, so
you must check the return value before continuing.</P>

<p class="docText">Once we have our device memory and request queue in place, we can
allocate, initialize, and install the corresponding
<tt>gendisk</tt> structure. The code that does this work
is:</P>

<pre>dev-&gt;gd = alloc_disk(SBULL_MINORS);
if (! dev-&gt;gd) {
    printk (KERN_NOTICE "alloc_disk failure\n");
    goto out_vfree;
}
dev-&gt;gd-&gt;major = sbull_major;
dev-&gt;gd-&gt;first_minor = which*SBULL_MINORS;
dev-&gt;gd-&gt;fops = &amp;sbull_ops;
dev-&gt;gd-&gt;queue = dev-&gt;queue;
dev-&gt;gd-&gt;private_data = dev;
snprintf (dev-&gt;gd-&gt;disk_name, 32, "sbull%c", which + 'a');
set_capacity(dev-&gt;gd, nsectors*(hardsect_size/KERNEL_sectOR_SIZE));
add_disk(dev-&gt;gd);</pre><br>


<p class="docText">Here, <tt>SBULL_MINORS</tt> is the number of minor numbers
each <span class="docEmphasis">sbull</span> device supports. When we set the
first minor number for each device, we must take into account all of
the numbers taken by prior devices. The name of the disk is set such
that the first one is <i>sbulla</i>, the second
<i>sbullb</I>, and so on. User space can then add
partition numbers so that the third partition on the second device
might be <I>/dev/sbullb3</I>.</p>

<p class="docText">Once everything is set up, we finish with a call to
<span class="docEmphasis">add_disk</span>. Chances are that several of our
methods will have been called for that disk by the time
<span class="docEmphasis">add_disk</span> returns, so we take care to make that
call the very last step in the initialization of our device.</P>


<a name="chp-16-sect-1.4"></a>
<H4 class="docSection2Title">16.1.4. A Note on Sector Sizes</h4>

<p class="docText">As we have mentioned<a name="chp-16-ITERM-7332"></a>
<a name="chp-16-ITERM-7333"></a> before, the kernel treats every disk
as a linear array of 512-byte sectors. Not all hardware uses that
sector size, however. Getting a device with a different sector size
to work is not particularly hard; it is just a matter of taking care
of a few details. The <span class="docEmphasis">sbull</span> device exports a
<tt>hardsect_size</tt> parameter that can be used to change
the "hardware" sector size of the
device; by looking at its implementation, you can see how to add this
sort of support to your own drivers.</p>

<p class="docText">The first of those details is to inform the kernel of the sector size
your device supports. The hardware sector size is a parameter in the
request queue, rather than in the <tt>gendisk</tt>
structure. This size is set with a call to
<span class="docEmphasis">blk_queue_hardsect_size</span><a name="chp-16-ITERM-7334"></a>
<a name="chp-16-ITERM-7335"></a>
immediately after the queue is allocated:</p>

<pre>blk_queue_hardsect_size(dev-&gt;queue, hardsect_size);</pre><br>


<p class="docText">Once that is done, the kernel adheres to your
device's hardware sector size. All I/O requests are
properly aligned at the beginning of a hardware sector, and the
length of each request is an integral number of sectors. You must
remember, however, that the kernel always expresses itself in
512-byte sectors; thus, it is necessary to translate all sector
numbers accordingly. So, for example, when <span class="docEmphasis">sbull</span>
sets the capacity of the device in its <tt>gendisk</tt>
structure, the call looks like:</P>

<pre>set_capacity(dev-&gt;gd, nsectors*(hardsect_size/KERNEL_sectOR_SIZE));</pre><br>


<p class="docText"><tt>KERNEL_sectOR_SIZE</tt> is a locally-defined constant
that we use to scale between the kernel's 512-byte
sectors and whatever size we have been told to use. This sort of
calculation pops up frequently as we <a name="chp-16-ITERM-7336"></a> <a name="chp-16-ITERM-7337"></a> <a name="chp-16-ITERM-7338"></a>look at the <span class="docEmphasis">sbull</span>
request processing logic.</p>



<UL></ul></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-16.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-16-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
