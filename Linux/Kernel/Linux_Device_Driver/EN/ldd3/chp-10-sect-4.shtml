<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>10.4. Top and Bottom Halves</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-10-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-10-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-10-sect-4"></a>
<h3 class="docSection1Title" >10.4. Top and Bottom Halves</h3>

<p class="docText">One of the main problems with interrupt<a name="chp-10-ITERM-6127"></a> <a name="chp-10-ITERM-6128"></a> <a name="chp-10-ITERM-6129"></a>
handling is how to perform lengthy tasks within a handler. Often a
substantial amount of work must be done in response to a device
interrupt, but interrupt handlers need to finish up quickly and not
keep interrupts blocked for long. These two needs (work and speed)
conflict with each other, leaving the driver writer in a bit of a
bind.</p>

<p class="docText">Linux (along with many other systems) resolves this problem by
splitting the interrupt handler into two halves. The so-called
<I>top half</i> is the routine that actually responds
to the interrupt—the one you register with
<span class="docEmphasis">request_irq</span>. The <I>bottom
half</I> is a routine that is scheduled by the top half to be
executed later, at a safer time. The big difference between the
top-half handler and the bottom half is that all interrupts are
enabled during execution of the bottom
half—that's why it runs at a safer time. In
the typical scenario, the top half saves device data to a
device-specific buffer, schedules its bottom half, and exits: this
operation is very fast. The bottom half then performs whatever other
work is required, such as awakening processes, starting up another
I/O operation, and so on. This setup permits the top half to service
a new interrupt while the bottom half is still working.</P>

<p class="docText">Almost every serious interrupt handler is split this way. For
instance, when a network interface reports the arrival of a new
packet, the handler just retrieves the data and pushes it up to the
protocol layer; actual processing of the packet is performed in a
bottom half.</p>

<p class="docText">The Linux kernel has two different mechanisms that may be used to
implement bottom-half processing, both of which were introduced in
<a class="docLink" href="chp-7.shtml#chp-7">Chapter 7</a>. Tasklets are often
the preferred mechanism for bottom-half processing; they are very
fast, but all tasklet code must be atomic. The alternative to
tasklets is workqueues, which may have a higher latency but that are
allowed to sleep.</p>

<p class="docText">The following discussion works, once again, with the
<span class="docEmphasis">short</span> driver. When loaded with a module option,
<span class="docEmphasis">short</span> can be told to do interrupt processing in
a top/bottom-half mode with either a tasklet or workqueue handler. In
this case, the top half executes quickly; it simply remembers the
current time and schedules the bottom half processing. The bottom
half is then charged with encoding this time and awakening any user
processes that may be waiting for data.</p>

<a name="chp-10-sect-4.1"></a>
<h4 class="docSection2Title">10.4.1. Tasklets</H4>

<p class="docText"><a name="chp-10-ITERM-6130"></a><a name="chp-10-ITERM-6131"></a><a name="chp-10-ITERM-6132"></a>Remember that tasklets are a special
function that may be scheduled to run, in software interrupt context,
at a system-determined safe time. They may be scheduled to run
multiple times, but tasklet scheduling is not cumulative; the tasklet
runs only once, even if it is requested repeatedly before it is
launched. No tasklet ever runs in parallel with itself, since they
run only once, but tasklets can run in parallel with other tasklets
on SMP systems. Thus, if your driver has multiple tasklets, they must
employ some sort of locking to avoid conflicting with each other.</P>

<p class="docText">Tasklets are also guaranteed to run on the same CPU as the function
that first schedules them. Therefore, an interrupt handler can be
secure that a tasklet does not begin executing before the handler has
completed. However, another interrupt can certainly be delivered
while the tasklet is running, so locking between the tasklet and the
interrupt handler may still be required.</P>

<p class="docText"><a name="chp-10-ITERM-6133"></a>
<a name="chp-10-ITERM-6134"></a>Tasklets
must be declared with the <tt>DECLARE_TASKLET</tt> macro:</p>

<pre>DECLARE_TASKLET(name, function, data);</pre><BR>


<p class="docText"><tt>name</tt> is the name to be given to the tasklet,
<span class="docEmphasis">function</span> is the function that is called to
execute the tasklet (it takes one <tt>unsigned long</tt>
argument and returns <tt>void</tt>), and
<tt>data</tt> is an unsigned long value to be passed to the
<span class="docEmphasis">tasklet</span> function.</P>

<p class="docText">The <span class="docEmphasis">short</span> driver declares its tasklet as follows:</p>

<pre>void short_do_tasklet(unsigned long);
DECLARE_TASKLET(short_tasklet, short_do_tasklet, 0);</pre><br>


<p class="docText"><a name="chp-10-ITERM-6135"></a>
<a name="chp-10-ITERM-6136"></a>The
function <span class="docEmphasis">tasklet_schedule</span> is used to schedule a
tasklet for running. If <span class="docEmphasis">short</span> is loaded with
<tt>tasklet=1</tt>, it installs a different interrupt
handler that saves data and schedules the tasklet as follows:</p>

<pre>irqreturn_t short_tl_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
    do_gettimeofday((struct timeval *) tv_head); /* cast to stop 'volatile' warning */
    short_incr_tv(&amp;tv_head);
    tasklet_schedule(&amp;short_tasklet);
    short_wq_count++; /* record that an interrupt arrived */
    return IRQ_HANDLED;
}</pre><br>


<p class="docText">The actual tasklet routine, <span class="docEmphasis">short_do_tasklet</span>,
will be executed shortly (so to speak) at the
system's convenience. As mentioned earlier, this
routine performs the bulk of the work of handling the interrupt; it
looks like this:</P>

<pre>void short_do_tasklet (unsigned long unused)
{
    int savecount = short_wq_count, written;
    short_wq_count = 0; /* we have already been removed from the queue */
    /*
     * The bottom half reads the tv array, filled by the top half,
     * and prints it to the circular text buffer, which is then consumed
     * by reading processes
     */

    /* First write the number of interrupts that occurred before this bh */
    written = sprintf((char *)short_head,"bh after %6i\n",savecount);
    short_incr_bp(&amp;short_head, written);

    /*
     * Then, write the time values. Write exactly 16 bytes at a time,
     * so it aligns with PAGE_SIZE
     */

    do {
        written = sprintf((char *)short_head,"%08u.%06u\n",
                (int)(tv_tail-&gt;tv_sec % 100000000),
                (int)(tv_tail-&gt;tv_usec));
        short_incr_bp(&amp;short_head, written);
        short_incr_tv(&amp;tv_tail);
    } while (tv_tail != tv_head);

    wake_up_interruptible(&amp;short_queue); /* awake any reading process */
}</pre><br>


<p class="docText">Among other things, this tasklet makes a note of how many interrupts
have arrived since it was last called. A device such as
<span class="docEmphasis">short</span> can generate a great many interrupts in a
brief period, so it is not uncommon for several to arrive before the
bottom half is executed. Drivers must always be prepared for this
possibility and must be able to determine how much work there is to
perform from the information left by the top half.</p>


<a name="chp-10-sect-4.2"></a>
<H4 class="docSection2Title">10.4.2. Workqueues</h4>

<p class="docText">Recall that
<a name="chp-10-ITERM-6137"></a>
<a name="chp-10-ITERM-6138"></a>workqueues
invoke a function at some future time in the context of a special
worker process. Since the <span class="docEmphasis">workqueue</span> function
runs in process context, it can sleep if need be. You cannot,
however, copy data into user space from a workqueue, unless you use
the advanced techniques we demonstrate in <a class="docLink" href="chp-15.shtml#chp-15">Chapter 15</a>; the worker process does
not have access to any other process's address
space.</p>

<p class="docText">The <span class="docEmphasis">short</span> driver, if loaded with the
<tt>wq</tt> option set to a nonzero value, uses a workqueue
for its bottom-half processing. It uses the system default workqueue,
so there is no special setup code required; if your driver has
special latency requirements (or might sleep for a long time in the
<span class="docEmphasis">workqueue</span> function), you may want to create your
own, dedicated workqueue. We do need a <tt>work_struct</tt>
structure, which is declared and initialized with the following:</P>

<pre>static struct work_struct short_wq;

    /* this line is in short_init(  ) */
    INIT_WORK(&amp;short_wq, (void (*)(void *)) short_do_tasklet, NULL);</pre><br>


<p class="docText">Our worker function is <span class="docEmphasis">short_do_tasklet</span>, which
we have already seen in the previous section.</P>

<p class="docText">When working with a workqueue, <span class="docEmphasis">short</span> establishes
yet another interrupt handler that looks like this:</p>

<pre>irqreturn_t short_wq_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
    /* Grab the current time information. */
    do_gettimeofday((struct timeval *) tv_head);
    short_incr_tv(&amp;tv_head);

    /* Queue the bh. Don't worry about multiple enqueueing */
    schedule_work(&amp;short_wq);

    short_wq_count++; /* record that an interrupt arrived */
    return IRQ_HANDLED;
}</pre><br>


<p class="docText">As you can see, the interrupt handler <a name="chp-10-ITERM-6139"></a> <a name="chp-10-ITERM-6140"></a> <a name="chp-10-ITERM-6141"></a>looks very much like the tasklet
version, with the exception that it calls
<span class="docEmphasis">schedule_work</span> to arrange the bottom-half
processing.</p>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-10-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-10-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
