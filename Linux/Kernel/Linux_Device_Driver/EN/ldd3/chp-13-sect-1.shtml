<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>13.1. USB Device Basics</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-13.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-13-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="chp-13-sect-1"></a>
<h3 class="docSection1Title" >13.1. USB Device Basics</h3>

<p class="docText">A USB device is a very complex thing, as described in the official
USB documentation (available at <a class="docLink" target="_blank" href="http://www.usb.org">http://www.usb.org</a>). Fortunately, the Linux
kernel provides a subsystem called the <i>USB
core</i> to handle most of the complexity. This chapter
describes the interaction between a driver and the USB core. <a class="docLink" href="chp-13.shtml#chp-13-FIG-1">Figure 13-1</a> shows how USB devices
consist of configurations, interfaces, and endpoints and how USB
drivers bind to USB interfaces, not the entire USB device.</P>

<a name="chp-13-FIG-2"></a><p><center>
<H5 class="docFigureTitle">Figure 13-2. USB device overview</H5>
<img border="0" alt=""  width="220" height="207" SRC="images/0596005903/figs/ldr3_1302.gif"></center></p><br>

<a name="chp-13-sect-1.1"></a>
<h4 class="docSection2Title">13.1.1. Endpoints</H4>

<p class="docText">The most basic form of
<a name="chp-13-ITERM-6407"></a>USB
communication is through something called an
<i>endpoint</I>. A USB endpoint can carry data in
only one direction, either from the host computer to the device
(called an <span class="docEmphasis">OUT</span> endpoint) or from the device to
the host computer (called an <span class="docEmphasis">IN</span> endpoint).
Endpoints can be thought of as <a name="chp-13-ITERM-6408"></a>unidirectional pipes.</P>

<p class="docText">A USB endpoint can be one of four different types that describe how
the data is transmitted:</P>

<a name="chp-13-ITERM-6409"></a><a name="chp-13-ITERM-6410"></a><a name="chp-13-ITERM-6411"></a><dl class="docList"><dt><span class="docPubcolor"><a name="chp-13-ITERM-6409"></a>CONTROL </span></dt></p>
<dd>
<p class="docList">Control endpoints are used to allow access to different parts of the
USB device. They are commonly used for configuring the device,
retrieving information about the device, sending commands to the
device, or retrieving status reports about the device. These
endpoints are usually small in size. Every USB device has a control
endpoint called "endpoint 0" that
is used by the USB core to configure the device at insertion time.
These transfers are guaranteed by the USB protocol to always have
enough reserved bandwidth to make it through to the device.</p>
</dd>
<dt><I><span class="docPubcolor">INTERRUPT </span></i></dt></P>
<dd>
<p class="docList">Interrupt endpoints transfer small amounts of data at a fixed rate
every time the USB host asks the device for data. These endpoints are
the primary transport method for USB keyboards and mice. They are
also commonly used to send data to USB devices to control the device,
but are not generally used to transfer large amounts of data. These
transfers are guaranteed by the USB protocol to always have enough
reserved bandwidth to make it through.</P>
</dd>
<dt><span class="docPubcolor"><a name="chp-13-ITERM-6410"></a>BULK </span></dt></p>
<dd>
<p class="docList">Bulk endpoints transfer large amounts of data. These endpoints are
usually much larger (they can hold more characters at once) than
interrupt endpoints. They are common for devices that need to
transfer any data that must get through with no data loss. These
transfers are not guaranteed by the USB protocol to always make it
through in a specific amount of time. If there is not enough room on
the bus to send the whole BULK packet, it is split up across multiple
transfers to or from the device. These endpoints are common on
printers, storage, and network devices.</p>
</dd>
<dt><span class="docPubcolor"><a name="chp-13-ITERM-6411"></a>ISOCHRONOUS </span></dt></p>
<dd>
<p class="docList">Isochronous endpoints also transfer large amounts of data, but the
data is not always guaranteed to make it through. These endpoints are
used in devices that can handle loss of data, and rely more on
keeping a constant stream of data flowing. Real-time data
collections, such as audio and video devices, almost always use these
endpoints.</P>
</dd>
</dl>

<p class="docText">Control and bulk endpoints are used for asynchronous data transfers,
whenever the driver decides to use them. Interrupt and isochronous
endpoints are periodic. This means that these endpoints are set up to
transfer data at fixed times continuously, which causes their
bandwidth to be reserved by the USB core.</p>

<p class="docText">USB endpoints are described in the kernel with the structure
<tt>struct</tt> <tt>usb_host_endpoint</tt>. This
structure contains the real endpoint information in another structure
called <tt>struct</tt>
<tt>usb_endpoint_descriptor</tt>. The latter structure
contains all of the USB-specific data in the exact format that the
device itself specified. The fields of this structure that drivers
care about are:</p>

<a name="chp-13-ITERM-6412"></a><a name="chp-13-ITERM-6413"></a><a name="chp-13-ITERM-6414"></a><a name="chp-13-ITERM-6415"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">bEndpointAddress</span></span><a name="chp-13-ITERM-6412"></a>  </span></dt></P>
<dd>
<p class="docList">This is the USB address of this specific endpoint. Also included in
this 8-bit value is the direction of the endpoint. The bitmasks
<tt>USB_DIR_OUT</tt> and <tt>USB_DIR_IN</tt> can
be placed against this field to determine if the data for this
endpoint is directed to the device or to the host.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">bmAttributes</span></span><a name="chp-13-ITERM-6413"></a>  </span></dt></p>
<dd>
<p class="docList">This is the type of endpoint. The bitmask
<tt>USB_ENDPOINT_XFERTYPE_MASK</tt> should be placed
against this value in order to determine if the endpoint is of type
<tt>USB_ENDPOINT_XFER_ISOC</tt>,
<tt>USB_ENDPOINT_XFER_BULK</tt>, or of type
<tt>USB_ENDPOINT_XFER_INT</tt>. These macros define a
isochronous, bulk, and interrupt endpoint, respectively.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">wMaxPacketSize</span></span><a name="chp-13-ITERM-6414"></a>  </span></dt></p>
<dd>
<p class="docList">This is the maximum size in bytes that this endpoint can handle at
once. Note that it is possible for a driver to send amounts of data
to an endpoint that is bigger than this value, but the data will be
divided up into <tt>wMaxPacketSize</tt> chunks when
actually transmitted to the device. For high-speed devices, this
field can be used to support a high-bandwidth mode for the endpoint
by using a few extra bits in the upper part of the value. See the USB
specification for more details about how this is done.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">bInterval</span></span><a name="chp-13-ITERM-6415"></a>  </span></dt></p>
<dd>
<p class="docList">If this endpoint is of type interrupt, this value is the interval
setting for the endpoint—that is, the time between interrupt
requests for the endpoint. The value is represented in milliseconds.</p>
</dd>
</dl>

<p class="docText">The fields of this structure do not have a
"traditional" Linux kernel naming
scheme. This is because these fields directly correspond to the field
names in the USB specification. The USB kernel programmers felt that
it was more important to use the specified names, so as to reduce
confusion when reading the specification, than it was to have
variable names that look familiar to Linux programmers.</P>


<a name="chp-13-sect-1.2"></a>
<h4 class="docSection2Title">13.1.2. Interfaces</H4>

<p class="docText">USB endpoints are bundled up
<a name="chp-13-ITERM-6416"></a>
<a name="chp-13-ITERM-6417"></a>into
<I>interfaces</i>. USB interfaces handle only one
type of a USB logical connection, such as a mouse, a keyboard, or a
audio stream. Some USB devices have multiple interfaces, such as a
USB speaker that might consist of two interfaces: a USB keyboard for
the buttons and a USB audio stream. Because a USB interface
represents basic functionality, each USB driver controls an
interface; so, for the speaker example, Linux needs two different
drivers for one hardware device.</p>

<p class="docText">USB interfaces may have alternate settings, which are different
choices for parameters of the interface. The initial state of a
interface is in the first setting, numbered <tt>0</tt>.
Alternate settings can be used to control individual endpoints in
different ways, such as to reserve different amounts of USB bandwidth
for the device. Each device with an isochronous endpoint uses
alternate settings for the same interface.</p>

<p class="docText">USB interfaces are described in the kernel with the
<tt>struct</tt> <tt>usb_interface</tt> structure.
This structure is what the USB core passes to USB drivers and is what
the USB driver then is in charge of controlling. The important fields
in this structure are:</P>

<a name="chp-13-ITERM-6418"></a><a name="chp-13-ITERM-6419"></a><a name="chp-13-ITERM-6420"></a><a name="chp-13-ITERM-6421"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct usb_host_interface *altsetting</span></span><a name="chp-13-ITERM-6418"></a>  </span></dt></P>
<dd>
<p class="docList">An array of interface structures containing all of the alternate
settings that may be selected for this interface. Each
<tt>struct</tt> <tt>usb_host_interface</tt>
consists of a set of endpoint configurations as defined by the
<tt>struct</tt> <tt>usb_host_endpoint</tt>
structure described above. Note that these interface structures are
in no particular order.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned num_altsetting</span></span><a name="chp-13-ITERM-6419"></a>  </span></dt></p>
<dd>
<p class="docList">The number of alternate settings pointed to by the
<tt>altsetting</tt> pointer.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct usb_host_interface *cur_altsetting</span></span><a name="chp-13-ITERM-6420"></a>  </span></dt></P>
<dd>
<p class="docList">A pointer into the array <tt>altsetting</tt>, denoting the
currently active setting for this interface.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int minor</span></span><a name="chp-13-ITERM-6421"></a>  </span></dt></p>
<dd>
<p class="docList">If the USB driver bound to this interface uses the USB major number,
this variable contains the minor number assigned by the USB core to
the interface. This is valid only after a successful call to
<tt>usb_register_dev</tt> (described later in this
chapter).</p>
</dd>
</dl>

<p class="docText">There are other fields in the<a name="chp-13-ITERM-6422"></a> <tt>struct</tt>
<tt>usb_interface</tt> structure, but USB drivers do not
need to be aware of them.</p>


<a name="chp-13-sect-1.3"></a>
<h4 class="docSection2Title">13.1.3. Configurations</H4>

<p class="docText">USB interfaces are t<a name="chp-13-ITERM-6423"></a>
<a name="chp-13-ITERM-6424"></a>
<a name="chp-13-ITERM-6425"></a>hemselves bundled up into
<i>configurations</i>. A USB device can have multiple
configurations and might switch between them in order to change the
state of the device. For example, some devices that allow firmware to
be downloaded to them contain multiple configurations to accomplish
this. A single configuration can be enabled only at one point in
time. Linux does not handle multiple configuration USB devices very
well, but, thankfully, they are rare.</P>

<p class="docText">Linux describes USB configurations with the structure
<tt>struct</tt> <tt>usb_host_config</tt> and
entire USB devices with the structure <tt>struct</tt>
<tt>usb_device</tt>. USB device drivers do not generally
ever need to read or write to any values in these structures, so they
are not defined in detail here. The curious reader can find
descriptions of them in the file
<i>include/linux/usb.h</i> in the kernel source tree.</P>

<p class="docText">A USB device driver commonly has to convert data from a given
<tt>struct</tt> <tt>usb_interface</tt> structure
into a <tt>struct</tt> <tt>usb_device</tt>
structure that the USB core needs for a wide range of function calls.
To do this, the function <span class="docEmphasis">interface_to_usbdev</span> is
provided. Hopefully, in the future, all USB calls that currently need
a <tt>struct</tt> <tt>usb_device</tt> will be
converted to take a <tt>struct</tt>
<tt>usb_interface</tt> parameter and will not require the
drivers to do the conversion.</p>

<p class="docText">So to summarize, USB devices are quite complex and are made up of
lots of different <a name="chp-13-ITERM-6426"></a>logical units. The relationships among
these units can be simply described as follows:</P>

<ul><li><p class="docList">Devices usually have one or more configurations.</p></li><li><p class="docList">Configurations often have one or more interfaces.</p></li><li><p class="docList">Interfaces usually have one or more settings.</p></li><li><p class="docList">Interfaces have zero or more endpoints.</p></li></UL>


<ul></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-13.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-13-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
