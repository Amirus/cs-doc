<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>6.6. Access Control on a Device File</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-6-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-6-sect-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-6-sect-6"></a>
<h3 class="docSection1Title">6.6. Access Control on a Device File</h3>

<p class="docText"><a name="chp-6-ITERM-5378"></a> <a name="chp-6-ITERM-5379"></a> <a name="chp-6-ITERM-5380"></a> <a name="chp-6-ITERM-5381"></a>Offering
access control is sometimes vital for the reliability of a device
node. Not only should unauthorized users not be permitted to use the
device (a restriction is enforced by the filesystem permission bits),
but sometimes only one authorized user should be allowed to open the
device at a time.</p>

<p class="docText">The problem is similar to that of using ttys. In that case, the
<span class="docEmphasis">login</span><a name="chp-6-ITERM-5382"></a>
<a name="chp-6-ITERM-5383"></a>
process changes the ownership of the device node whenever a user logs
into the system, in order to prevent other users from interfering
with or sniffing the tty data flow. However, it's
impractical to use a privileged program to change the ownership of a
device every time it is opened just to grant unique access to it.</P>

<p class="docText">None of the code shown up to now implements any access control beyond
the filesystem permission bits. If the <span class="docEmphasis">open</span>
system call forwards the request to the driver,
<span class="docEmphasis">open</span> succeeds. We now introduce a few techniques
for implementing some additional checks.</p>

<p class="docText">Every device shown in this section has the same behavior as the bare
<span class="docEmphasis">scull</span> device (that is, it implements a
persistent memory area) but differs from <span class="docEmphasis">scull</span>
in access control, which is implemented in the
<span class="docEmphasis">open</span> and <span class="docEmphasis">release</span>
operations.</P>

<a name="chp-6-sect-6.1"></a>
<H4 class="docSection2Title">6.6.1. Single-Open Devices</H4>

<p class="docText"><a name="chp-6-ITERM-5384"></a>
<a name="chp-6-ITERM-5385"></a><a name="chp-6-ITERM-5386"></a><a name="chp-6-ITERM-5387"></a>The brute-force way
to provide access control is to permit a device to be opened by only
one process at a time (single openness). This technique is best
avoided because it inhibits user ingenuity. A user might want to run
different processes on the same device, one reading status
information while the other is writing data. In some cases, users can
get a lot done by running a few simple programs through a shell
script, as long as they can access the device concurrently. In other
words, implementing a single-open behavior amounts to creating
policy, which may get in the way of what your users want to do.</p>

<p class="docText">Allowing only a single process to open a device has undesirable
properties, but it is also the easiest access control to implement
for a device driver, so it's shown here. The source
code is extracted from a device called
<span class="docEmphasis">scullsingle</span>.</p>

<p class="docText"><a name="chp-6-ITERM-5388"></a>
<a name="chp-6-ITERM-5389"></a>The
<span class="docEmphasis">scullsingle</span><a name="chp-6-ITERM-5390"></a>
<a name="chp-6-ITERM-5391"></a>
device maintains an <tt>atomic_t</tt> variable called
<tt>scull_s_available</tt>; that variable is initialized to
a value of one, indicating that the device is indeed available. The
<span class="docEmphasis">open</span> call decrements and tests
<tt>scull_s_available</tt> and refuses access if somebody
else already has the device open:</p>

<pre>static atomic_t scull_s_available = ATOMIC_INIT(1);

static int scull_s_open(struct inode *inode, struct file *filp)
{
    struct scull_dev *dev = &amp;scull_s_device; /* device information */

    if (! atomic_dec_and_test (&amp;scull_s_available)) {
        atomic_inc(&amp;scull_s_available);
        return -EBUSY; /* already open */
    }

    /* then, everything else is copied from the bare scull device */
    if ( (filp-&gt;f_flags &amp; O_ACCMODE) =  = O_WRONLY)
        scull_trim(dev);
    filp-&gt;private_data = dev;
    return 0;          /* success */
}</pre><br>


<p class="docText"><a name="chp-6-ITERM-5392"></a>
<a name="chp-6-ITERM-5393"></a>The
<span class="docEmphasis">release</span> call, on the other hand, marks the
device as no longer busy:</P>

<pre>static int scull_s_release(struct inode *inode, struct file *filp)
{
    atomic_inc(&amp;scull_s_available); /* release the device */
    return 0;
}</pre><BR>


<p class="docText">Normally, we recommend that you put the open flag
<tt>scull_s_available</tt> within the device structure
(<tt>Scull_Dev</tt> here) because, conceptually, it belongs
to the device. The <span class="docEmphasis">scull</span> driver, however, uses
standalone variables to hold the flag so it can use the same device
structure and methods as the bare <span class="docEmphasis">scull</span> device
and minimize code duplication.</P>


<a name="chp-6-sect-6.2"></a>
<h4 class="docSection2Title">6.6.2. Restricting Access to a Single User at a Time</H4>

<p class="docText">The next step beyond a<a name="chp-6-ITERM-5394"></a>
<a name="chp-6-ITERM-5395"></a> single-open device is to let a single user
open a device in multiple processes but allow only one user to have
the device open at a time. This solution makes it easy to test the
device, since the user can read and write from several processes at
once, but assumes that the user takes some responsibility for
maintaining the integrity of the data during multiple accesses. This
is accomplished by adding checks in the <span class="docEmphasis">open</span>
method; such checks are performed <span class="docEmphasis">after</span> the
normal permission checking and can only make access more restrictive
than that specified by the owner and group permission bits. This is
the same access policy as that used for ttys, but it
doesn't resort to an external privileged program.</P>

<p class="docText">Those access policies are a little trickier to implement than
single-open policies. In this case, two items are needed: an open
count and the uid of the "owner" of
the device. Once again, the best place for such items is within the
device structure; our example uses global variables instead, for the
reason explained earlier for <span class="docEmphasis">scullsingle</span>. The
name of the device is <span class="docEmphasis">sculluid</span>.</p>

<p class="docText"><a name="chp-6-ITERM-5396"></a>
<a name="chp-6-ITERM-5397"></a>The
<span class="docEmphasis">open</span> call grants access on first open but
remembers the owner of the device. This means that a user can open
the device multiple times, thus allowing cooperating processes to
work concurrently on the device. At the same time, no other user can
open it, thus avoiding external interference. Since this version of
the function is almost identical to the preceding one, only the
relevant part is reproduced here:</p>

<pre>    spin_lock(&amp;scull_u_lock);
    if (scull_u_count &amp;&amp; 
            (scull_u_owner != current-&gt;uid) &amp;&amp;  /* allow user */
            (scull_u_owner != current-&gt;euid) &amp;&amp; /* allow whoever did su */
            !capable(CAP_DAC_OVERRIDE)) { /* still allow root */
        spin_unlock(&amp;scull_u_lock);
        return -EBUSY;   /* -EPERM would confuse the user */
    }

    if (scull_u_count =  = 0)
        scull_u_owner = current-&gt;uid; /* grab it */

    scull_u_count++;
    spin_unlock(&amp;scull_u_lock);</pre><br>


<p class="docText">Note that the
<span class="docEmphasis">sculluid</span><a name="chp-6-ITERM-5398"></a>
<a name="chp-6-ITERM-5399"></a>
code has two variables (<tt>scull_u_owner</tt> and
<tt>scull_u_count</tt>) that control access to the device
and that could be accessed concurrently by multiple processes. To
make these variables safe, we control access to them with a spinlock
(<tt>scull_u_lock</tt>). Without that locking, two (or
more) processes could test <tt>scull_u_count</tt> at the
same time, and both could conclude that they were entitled to take
ownership of the device. A spinlock is indicated here, because the
lock is held for a very short time, and the driver does nothing that
could sleep while holding the lock.</p>

<p class="docText">We chose to return <tt>-EBUSY</tt> and not
<tt>-EPERM</tt>, even though the code is performing a
permission check, in order to point a user who is denied access in
the right direction. The reaction to "Permission
denied" is usually to check the mode and owner of
the <I>/dev</i> file, while "Device
busy" correctly suggests that the user should look
for a process already using the device.</p>

<p class="docText"><a name="chp-6-ITERM-5400"></a>This code also checks to see if the
process attempting the open has the ability to override file access
permissions; if so, the open is allowed even if the opening process
is not the owner of the device. The
<tt>CAP_DAC_OVERRIDE</tt> capability fits the task well in
this case.</P>

<p class="docText">The <span class="docEmphasis">release</span> method looks like the following:</p>

<pre>static int scull_u_release(struct inode *inode, struct file *filp)
{
    spin_lock(&amp;scull_u_lock);
    scull_u_count--; /* nothing else */
    spin_unlock(&amp;scull_u_lock);
    return 0;
}</pre><br>


<p class="docText">Once again, we must obtain the lock prior to modifying the count to
ensure that we do not race with another process.</P>


<a name="chp-6-sect-6.3"></a>
<h4 class="docSection2Title">6.6.3. Blocking open as an Alternative to EBUSY</H4>

<p class="docText"><a name="chp-6-ITERM-5401"></a>
<a name="chp-6-ITERM-5402"></a>
<a name="chp-6-ITERM-5403"></a><a name="chp-6-ITERM-5404"></a><a name="chp-6-ITERM-5405"></a><a name="chp-6-ITERM-5406"></a><a name="chp-6-ITERM-5407"></a>When
the device isn't accessible, returning an error is
usually the most sensible approach, but there are situations in which
the user would prefer to wait for the device.</p>

<p class="docText">For example, if a data communication channel is used both to transmit
reports on a regular, scheduled basis (using
<span class="docEmphasis">crontab</span>) and for casual usage according to
people's needs, it's much better
for the scheduled operation to be slightly delayed rather than fail
just because the channel is currently busy.</p>

<p class="docText">This is one of the choices that the programmer must make when
designing a device driver, and the right answer depends on the
particular problem being solved.</p>

<p class="docText">The alternative to <tt>EBUSY</tt>, as you may have guessed,
is to implement blocking <span class="docEmphasis">open</span>. The
<span class="docEmphasis">scullwuid</span> device is a version of
<span class="docEmphasis">sculluid</span> that waits for the device on
<span class="docEmphasis">open</span> instead of returning
<tt>-EBUSY</tt>. It differs from
<span class="docEmphasis">sculluid</span> only in the following part of the
<span class="docEmphasis">open</span> operation:</p>

<pre>spin_lock(&amp;scull_w_lock);
while (! scull_w_available(  )) {
    spin_unlock(&amp;scull_w_lock);
    if (filp-&gt;f_flags &amp; O_NONBLOCK) return -EAGAIN;
    if (wait_event_interruptible (scull_w_wait, scull_w_available(  )))
        return -ERESTARTSYS; /* tell the fs layer to handle it */
    spin_lock(&amp;scull_w_lock);
}
if (scull_w_count =  = 0)
    scull_w_owner = current-&gt;uid; /* grab it */
scull_w_count++;
spin_unlock(&amp;scull_w_lock);</pre><br>


<p class="docText">The implementation is based once again on a wait queue. If the device
is not currently available, the process attempting to open it is
placed on the wait queue until the owning process closes the device.</p>

<p class="docText"><a name="chp-6-ITERM-5408"></a>
<a name="chp-6-ITERM-5409"></a>
<a name="chp-6-ITERM-5410"></a>The <span class="docEmphasis">release</span>
method, then, is in charge of awakening any pending process:</p>

<pre>static int scull_w_release(struct inode *inode, struct file *filp)
{
    int temp;

    spin_lock(&amp;scull_w_lock);
    scull_w_count--;
    temp = scull_w_count;
    spin_unlock(&amp;scull_w_lock);

    if (temp =  = 0)
        wake_up_interruptible_sync(&amp;scull_w_wait); /* awake other uid's */
    return 0;
}</pre><br>


<p class="docText">Here is an example of where calling
<span class="docEmphasis">wake_up_interruptible_sync</span> makes sense. When we
do the wakeup, we are just about to return to user space, which is a
natural scheduling point for the system. Rather than potentially
reschedule when we do the wakeup, it is better to just call the
"sync" version and finish our job.</p>

<p class="docText">The problem with a blocking-open implementation is that it is really
unpleasant for the interactive user, who has to keep guessing what is
going wrong. The interactive user usually invokes standard commands,
such as <span class="docEmphasis">cp</span> and <span class="docEmphasis">tar</span>, and
can't just add <tt>O_NONBLOCK</tt> to the
<span class="docEmphasis">open</span> call. Someone who's making
a backup using the tape drive in the next room would prefer to get a
plain "device or resource busy"
message instead of being left to guess why the hard drive is so
silent today, while <span class="docEmphasis">tar</span> should be scanning it.</p>

<p class="docText">This kind of problem (a need for different, incompatible policies for
the same device) is often best solved by implementing one device node
for each access policy. An example of this practice can be found in
the Linux tape driver, which provides multiple device files for the
same device. Different device files will, for example, cause the
drive to record with or without compression, or to automatically
rewind the tape when the device is closed.</p>


<a name="chp-6-sect-6.4"></a>
<h4 class="docSection2Title">6.6.4. Cloning the Device on open</h4>

<p class="docText">Another <a name="chp-6-ITERM-5411"></a>
<a name="chp-6-ITERM-5412"></a>technique
to manage access control is to create different private copies of the
device, depending on the process opening it.</P>

<p class="docText">Clearly, this is possible only if the device is not bound to a
hardware object; <span class="docEmphasis">scull</span> is an example of such a
"software" device. The internals of
<i>/dev/tty</I> use a similar technique in order to
give its process a different "view"
of what the <I>/dev</i> entry point represents. When
copies of the device are created by the software driver, we call them
<span class="docEmphasis">virtual devices</span>—just as virtual consoles
use a single physical tty device.</p>

<p class="docText">Although this kind of access control is rarely needed, the
implementation can be enlightening in showing how easily kernel code
can change the application's perspective of the
surrounding world (i.e., the computer).</p>

<p class="docText">The <I>/dev/scullpriv</i> device node implements
virtual devices within the <span class="docEmphasis">scull</span> package. The
<span class="docEmphasis">scullpriv</span> implementation uses the device number
of the process's controlling tty as a key to access
the virtual device. Nonetheless, you can easily modify the sources to
use any integer value for the key; each choice leads to a different
policy. For example, using the <tt>uid</tt> leads to a
different virtual device for each user, while using a
<tt>pid</tt> key creates a new device for each process
accessing it.</P>

<p class="docText">The decision to use the controlling terminal is meant to enable easy
testing of the device using I/O redirection: the device is shared by
all commands run on the same virtual terminal and is kept separate
from the one seen by commands run on another terminal.</P>

<p class="docText">The <span class="docEmphasis">open</span> method looks like the following code.
It must look for the right virtual device and possibly create one.
The final part of the function is not shown because it is copied from
the bare <span class="docEmphasis">scull</span>, which we've
already seen.</P>

<pre>/* The clone-specific data structure includes a key field */

struct scull_listitem {
    struct scull_dev device;
    dev_t key;
    struct list_head list;
    
};

/* The list of devices, and a lock to protect it */
static LIST_HEAD(scull_c_list);
static spinlock_t scull_c_lock = SPIN_LOCK_UNLOCKED;

/* Look for a device or create one if missing */
static struct scull_dev *scull_c_lookfor_device(dev_t key)
{
    struct scull_listitem *lptr;

    list_for_each_entry(lptr, &amp;scull_c_list, list) {
        if (lptr-&gt;key =  = key)
            return &amp;(lptr-&gt;device);
    }

    /* not found */
    lptr = kmalloc(sizeof(struct scull_listitem), GFP_KERNEL);
    if (!lptr)
        return NULL;

    /* initialize the device */
    memset(lptr, 0, sizeof(struct scull_listitem));
    lptr-&gt;key = key;
    scull_trim(&amp;(lptr-&gt;device)); /* initialize it */
    init_MUTEX(&amp;(lptr-&gt;device.sem));

    /* place it in the list */
    list_add(&amp;lptr-&gt;list, &amp;scull_c_list);

    return &amp;(lptr-&gt;device);
}

static int scull_c_open(struct inode *inode, struct file *filp)
{
    struct scull_dev *dev;
    dev_t key;
 
    if (!current-&gt;signal-&gt;tty) { 
        PDEBUG("Process \"%s\" has no ctl tty\n", current-&gt;comm);
        return -EINVAL;
    }
    key = tty_devnum(current-&gt;signal-&gt;tty);

    /* look for a scullc device in the list */
    spin_lock(&amp;scull_c_lock);
    dev = scull_c_lookfor_device(key);
    spin_unlock(&amp;scull_c_lock);

    if (!dev)
        return -ENOMEM;

    /* then, everything else is copied from the bare scull device */</pre><br>


<p class="docText"><a name="chp-6-ITERM-5413"></a>
<a name="chp-6-ITERM-5414"></a>The <span class="docEmphasis">release</span> method
does nothing special. It would normally release the device on last
close, but we chose not to maintain an open count in order to
simplify the testing of the driver. If the device were released on
last close, you wouldn't be able to read the same
data after writing to the device, unless a background process were to
keep it open. The sample driver takes the easier approach of keeping
the data, so that at the next <span class="docEmphasis">open</span>,
you'll find it there. The devices are released when
<span class="docEmphasis">scull_cleanup</span><a name="chp-6-ITERM-5415"></a>
<a name="chp-6-ITERM-5416"></a>
is called.</p>

<p class="docText">This code uses the generic Linux linked list mechanism in preference
to reimplementing the same capability from scratch. Linux lists are
discussed in <a class="docLink" href="chp-11.shtml#chp-11">Chapter 11</a>.</p>

<p class="docText">Here's the <span class="docEmphasis">release</span>
implementation for <i>/dev/scullpriv</I>, which closes
the discussion of device methods.</P>

<a name="chp-6-ITERM-5417"></a><a name="chp-6-ITERM-5418"></a><a name="chp-6-ITERM-5419"></a><a name="chp-6-ITERM-5420"></a><pre>static int scull_c_release(struct inode *inode, struct file *filp)
{
    /*
     * Nothing to do, because the device is persistent.
     * A `real' cloned device should be freed on last close
     */
    return 0;



}</pre><BR>




<ul></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-6-sect-5.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-6-sect-7.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
